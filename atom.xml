<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EscLife. Blog</title>
  
  <subtitle>炼丹、刷题--notes</subtitle>
  <link href="https://ywj1.github.io/atom.xml" rel="self"/>
  
  <link href="https://ywj1.github.io/"/>
  <updated>2020-10-26T08:14:36.000Z</updated>
  <id>https://ywj1.github.io/</id>
  
  <author>
    <name>EscLife</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Trident Network</title>
    <link href="https://ywj1.github.io/2020/10/26/Trident-Network/"/>
    <id>https://ywj1.github.io/2020/10/26/Trident-Network/</id>
    <published>2020-10-26T07:30:54.000Z</published>
    <updated>2020-10-26T08:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Scale-Aware-Trident-Networks-for-Object-Detection-用于物体检测的可感知规模的三叉戟网络"><a href="#Scale-Aware-Trident-Networks-for-Object-Detection-用于物体检测的可感知规模的三叉戟网络" class="headerlink" title="Scale-Aware Trident Networks for Object Detection(用于物体检测的可感知规模的三叉戟网络)"></a>Scale-Aware Trident Networks for Object Detection(用于物体检测的可感知规模的三叉戟网络)</h2><h3 id="初步阅读"><a href="#初步阅读" class="headerlink" title="初步阅读"></a>初步阅读</h3><p><strong>作者写作目的</strong></p><p>scale variation在目标检测中是一个十分重要的问题，因此作者提出了Trident block来进行多尺度特征检测。</p><p><strong>作者新颖的方法</strong></p><p>针对之前Feature Fusion中的一些问题，例如特征不连续等，提出了Trident Network，其实这个的关键在于Trident block，对于一个feature map使用三条支路（不同的带孔卷积）。</p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><h4 id="Trident-Networks"><a href="#Trident-Networks" class="headerlink" title="Trident Networks"></a>Trident Networks</h4><p>作者首先说明三个对于目标检测影响的重要因素：1.downsample rate 2. network depth 3. receptive field。对于第三个作者做了实验来说明该影响，对于大的scale物体，使用dilation大的带孔卷积效果会更好。</p><h5 id="Trident-block"><a href="#Trident-block" class="headerlink" title="Trident block"></a>Trident block</h5><p>于是作者在上述实验的基础之上，提出了Trident block，对于同一个模块，使用不同dilation的带孔卷积，从而达到不同scale的训练，并且针对FPN的feature inconsistency，作者的Trident block使用了uniform representational power。</p><p><img src="/2020/10/26/Trident-Network/network.jpg" alt="avatar"></p><p>并且作者提出了三个策略</p><ol><li>weigh sharing among branches，通过带孔卷积间的权重共享，可以减少参数个数，并且使用一个uniform transformation with the same representational power。</li><li>scale-aware training scheme，对于每个branch设置了不同的范围，之后对于不同的RoI使用不同的branch来进行训练。</li><li>使用middle branch来进行inference。加快了速度。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Scale-Aware-Trident-Networks-for-Object-Detection-用于物体检测的可感知规模的三叉戟网络&quot;&gt;&lt;a href=&quot;#Scale-Aware-Trident-Networks-for-Object-Detection-用于</summary>
      
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Object detection" scheme="https://ywj1.github.io/tags/Object-detection/"/>
    
    <category term="multi-scale" scheme="https://ywj1.github.io/tags/multi-scale/"/>
    
  </entry>
  
  <entry>
    <title>AFF</title>
    <link href="https://ywj1.github.io/2020/10/24/AFF/"/>
    <id>https://ywj1.github.io/2020/10/24/AFF/</id>
    <published>2020-10-24T05:56:50.000Z</published>
    <updated>2020-10-24T06:39:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Attention-Feature-Fusion-AFF-注意力机制的特征融合"><a href="#Attention-Feature-Fusion-AFF-注意力机制的特征融合" class="headerlink" title="Attention Feature Fusion(AFF:注意力机制的特征融合)"></a>Attention Feature Fusion(AFF:注意力机制的特征融合)</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><p><strong>作者写作目的</strong></p><p>To better fuse features of inconsistent semantics and scales. 因为之前的feature fusion有三个drawbacks:</p><ol><li>semantic inconsistency(语义不连续，模型通过feature fusion之后会造成语义不连续)</li><li>unsophisticated initial integration(简单的初步整合，对于俩个feature，仅仅通过element-wise summation)</li><li>仅仅对于global feature进行feature fusion，这会造成biased context aggregation scale</li></ol><p><strong>作者新颖之处</strong></p><p>作者基于SENet和SKNet提出了AFF模型，通过结合局部特征和全局特征的attention机制来进行feature fusion。</p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><h4 id="Attention-Feature-Fusion"><a href="#Attention-Feature-Fusion" class="headerlink" title="Attention Feature Fusion"></a>Attention Feature Fusion</h4><h5 id="MS-CAM-model"><a href="#MS-CAM-model" class="headerlink" title="MS_CAM model"></a>MS_CAM model</h5><p>下图是MS_CAM模型：</p><p><img src="/2020/10/24/AFF/MS_CAM.png" alt="avatar"></p><p>MS_CAM采用了bottleneck structure，左边是global feature，右边是local feature，其中左边的global feature与SENet不同之处在于，将SENet的Fully connected layer变为了Point-wise Conv layer，这样的目的是减小了计算量。其中+表示的element-wise summation，✖表示的element-wise multiplication。</p><h5 id="AFF-model"><a href="#AFF-model" class="headerlink" title="AFF model"></a>AFF model</h5><p><img src="/2020/10/24/AFF/AFF.png" alt="avatar"></p><p><img src="/2020/10/24/AFF/function-aff.png" alt="avatar"></p><p>其中Z表示的fused feature，我觉得该feature fusion想法类似于Cross Entropy。（理解起来还挺简单，但是想到是真的难！）对于其中的initial integration仅仅使用了简单的element-wise summation。因此作者在此基础之上又提出了iAFF，其实iAFF就是俩层AFF，对于X,Y在使用一次MS_CAM模型。如图：</p><p><img src="/2020/10/24/AFF/iAFF.png" alt="avatar"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Attention-Feature-Fusion-AFF-注意力机制的特征融合&quot;&gt;&lt;a href=&quot;#Attention-Feature-Fusion-AFF-注意力机制的特征融合&quot; class=&quot;headerlink&quot; title=&quot;Attention Feat</summary>
      
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Feature Fusion" scheme="https://ywj1.github.io/tags/Feature-Fusion/"/>
    
    <category term="Object detection" scheme="https://ywj1.github.io/tags/Object-detection/"/>
    
  </entry>
  
  <entry>
    <title>ConerNet</title>
    <link href="https://ywj1.github.io/2020/10/23/ConerNet/"/>
    <id>https://ywj1.github.io/2020/10/23/ConerNet/</id>
    <published>2020-10-23T01:43:03.000Z</published>
    <updated>2020-10-23T02:33:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CornerNet-Detecting-Objects-as-Paired-Keypoints-ConerNet-以成对的关键点检测目标"><a href="#CornerNet-Detecting-Objects-as-Paired-Keypoints-ConerNet-以成对的关键点检测目标" class="headerlink" title="CornerNet: Detecting Objects as Paired Keypoints(ConerNet:以成对的关键点检测目标)"></a>CornerNet: Detecting Objects as Paired Keypoints(ConerNet:以成对的关键点检测目标)</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><p><strong>作者写作目的？</strong></p><p>在之前的object detector中，由于anchor boxes的存在，会产生一些问题</p><ol><li>需要产生大量的anchor boxes</li><li>需要调整很多的参数，例如aspect ratios，scale等</li></ol><p>因此作者希望使用一个anchor-free detector来实现目标检测。</p><p><strong>新颖之处</strong></p><p>对于检测object，不像之前那样，需要检测center points，而是进行top-left and bottom-right的检测，并且设计了corner pooling来进行localize corner。作者借鉴了人体姿态估计的思想（embedding vector）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CornerNet-Detecting-Objects-as-Paired-Keypoints-ConerNet-以成对的关键点检测目标&quot;&gt;&lt;a href=&quot;#CornerNet-Detecting-Objects-as-Paired-Keypoints-Cone</summary>
      
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Object detection" scheme="https://ywj1.github.io/tags/Object-detection/"/>
    
    <category term="anchor-free" scheme="https://ywj1.github.io/tags/anchor-free/"/>
    
  </entry>
  
  <entry>
    <title>RetinaNet</title>
    <link href="https://ywj1.github.io/2020/10/18/RetinaNet/"/>
    <id>https://ywj1.github.io/2020/10/18/RetinaNet/</id>
    <published>2020-10-18T02:23:59.000Z</published>
    <updated>2020-10-18T06:01:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Focal-Loss-for-Dense-Object-Detection"><a href="#Focal-Loss-for-Dense-Object-Detection" class="headerlink" title="Focal Loss for Dense Object Detection"></a>Focal Loss for Dense Object Detection</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><h4 id="作者写作的目的"><a href="#作者写作的目的" class="headerlink" title="作者写作的目的"></a>作者写作的目的</h4><p>为了能够使one-stage的准确率能够提升到和two-stage差不多类似的精度，在不丧失速度的前提下。作者觉得这是由于one-stage的正负比例不均匀，导致训练之后的准确率不高。</p><h4 id="作者提出的新颖的方法"><a href="#作者提出的新颖的方法" class="headerlink" title="作者提出的新颖的方法"></a>作者提出的新颖的方法</h4><p>作者提出了一个新的损失函数(Focal Loss)，来进行平衡class imbalance。</p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>由于one-stage并没有像two-stage那样，提出region proposal，因此对于one-stage模型，会产生大量的negative samples，这就会造成class imbalance。class imbalance会造成俩个后果，引用原文：</p><ol><li>training is inefficient as most locations are easy negatives that contribute no useful learning signal.</li><li>en masse, the easy negatives can overwhelm training and lead to degenerate models.</li></ol><p>负样本数量过大，并且都是容易分类的样本，因此模型的优化并不是朝着我们希望的方向。因此本文针对类别不平衡，提出了一个新的loss function(Focal Loss function)。</p><h4 id="RetinaNet"><a href="#RetinaNet" class="headerlink" title="RetinaNet"></a>RetinaNet</h4><h5 id="Focal-Loss-Function"><a href="#Focal-Loss-Function" class="headerlink" title="Focal Loss Function"></a>Focal Loss Function</h5><p>在cross entropy和balanced cross entropy基础之上，作者提出了Focal Loss，it is defined as:</p><script type="math/tex; mode=display">\begin{equation}FL(p_t) =\begin{cases}-\alpha(1-p_t)^{\gamma}log(p_t),& y=1 \\(1-\alpha)(p_t)^{\gamma}log(1-p_t), & y = 0\\\end{cases}\end{equation}</script><p>因为balanced cross entropy能平衡正负样本，但是无法控制easy/hard examples，因此作者提出了Focal Loss，focus training on hard negatives。其中$\gamma$为调制系数(modulating factor)。目的是通过减少易分类样本的权重，从而使模型在训练时候更专注难分类的样本。$\alpha$可以控制正负样本权重。</p><p>对于Focal Loss有俩个重要的性质：</p><ol><li><p>当样本被分错之后，$p_t$很小，因此$(1-p_t)^{\gamma}$趋于1，相比于原来的loss没什么区别，当$p_t$趋于1时候(样本分类正确，且是易分类样本)，参数区域0，对于总的loss贡献很小。</p></li><li><p>$\gamma$增加时候，前面的参数也会增加。</p></li></ol><h5 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h5><p><img src="/2020/10/18/RetinaNet/RetinaNet.jpg" alt="avator"></p><p>使用ResNet+FPN为backbone，在每层的feature map中使用class subnet和box subnet。（具体如图所示）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Focal-Loss-for-Dense-Object-Detection&quot;&gt;&lt;a href=&quot;#Focal-Loss-for-Dense-Object-Detection&quot; class=&quot;headerlink&quot; title=&quot;Focal Loss for Den</summary>
      
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Object detection" scheme="https://ywj1.github.io/tags/Object-detection/"/>
    
    <category term="one-stage" scheme="https://ywj1.github.io/tags/one-stage/"/>
    
  </entry>
  
  <entry>
    <title>MobileNetv2</title>
    <link href="https://ywj1.github.io/2020/10/15/MobileNetv2/"/>
    <id>https://ywj1.github.io/2020/10/15/MobileNetv2/</id>
    <published>2020-10-15T12:13:32.000Z</published>
    <updated>2020-10-15T13:18:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MobileNetV2-Inverted-Residuals-and-Linear-Bottlenecks-MobileNetV2：残差和线性瓶颈"><a href="#MobileNetV2-Inverted-Residuals-and-Linear-Bottlenecks-MobileNetV2：残差和线性瓶颈" class="headerlink" title="MobileNetV2: Inverted Residuals and Linear Bottlenecks(MobileNetV2：残差和线性瓶颈)"></a>MobileNetV2: Inverted Residuals and Linear Bottlenecks(MobileNetV2：残差和线性瓶颈)</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><h4 id="作者写作的目的"><a href="#作者写作的目的" class="headerlink" title="作者写作的目的"></a>作者写作的目的</h4><p>保证模型的accuracy的同时降低模操作和内存消耗，使这个模型更能够部署在Mobile application中</p><h4 id="作者创新的方法"><a href="#作者创新的方法" class="headerlink" title="作者创新的方法"></a>作者创新的方法</h4><p>使用一个Inverted Residuals和Linear Bottlenecks来对原有的MobileNetv1进行改进。</p><h3 id="MobileNetV2"><a href="#MobileNetV2" class="headerlink" title="MobileNetV2"></a>MobileNetV2</h3><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p>MobileNetV2使用Inverted Residuals模块来进行构造网络结构。</p><h5 id="Inverted-Residuals"><a href="#Inverted-Residuals" class="headerlink" title="Inverted Residuals"></a>Inverted Residuals</h5><p>其实这个就是类似于Residuals network中的残差块，都是先用$1\times 1$卷积，使用$3\times 3$，再使用$1\times 1$进行操作，最后使用残差连接，其中不同的点在于残差网络中，先对原有的feature map进行降维，之后进行升维，Inverted Residuals对于feature map进行升维之后进行降维。</p><p><img src="/2020/10/15/MobileNetv2/difference-residual.jpg" alt="avatar"></p><h5 id="Body-Architecture"><a href="#Body-Architecture" class="headerlink" title="Body Architecture"></a>Body Architecture</h5><p><img src="/2020/10/15/MobileNetv2/network.png" alt="avatar"></p><p>本文提出了针对非线性激活函数提出了俩个猜想</p><ol><li>If the mainifold of interest remains non-zeros volume after ReLU transformation, it corresponds to a linear transformation.</li><li>ReLU is capable of preserving complete infromation about the input mainifold, but only if the input mainifold lies in a low-dimensional subspace of the input shape.</li></ol><p>第一个理论理解应该使简单因为$ReLU(x) = max(0,x)$，因此对于大于0的情况下，他就是线性的变化。对于猜想中的mainifold of interest理解成$w\times h\times c$的feature map上的一个点的c维特征，文章使用Linear Bottlenecks来进行说明网络的最后一层不使用ReLU非线性激活函数的原因。因为对于ReLU激活函数会造成信息的损失，但是随着输出维度的增加，信息的丢失会减小，因此使用线性层来减少信息的丢失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MobileNetV2-Inverted-Residuals-and-Linear-Bottlenecks-MobileNetV2：残差和线性瓶颈&quot;&gt;&lt;a href=&quot;#MobileNetV2-Inverted-Residuals-and-Linear-Bottl</summary>
      
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="backbone" scheme="https://ywj1.github.io/tags/backbone/"/>
    
    <category term="classfication" scheme="https://ywj1.github.io/tags/classfication/"/>
    
  </entry>
  
  <entry>
    <title>MobileNetv1</title>
    <link href="https://ywj1.github.io/2020/10/15/MobileNetv1/"/>
    <id>https://ywj1.github.io/2020/10/15/MobileNetv1/</id>
    <published>2020-10-15T12:13:26.000Z</published>
    <updated>2020-10-15T12:49:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MobileNets-Efficient-Convolutional-Neural-Networks-for-Mobile-Vision-Applications-MobileNets：用于移动视觉应用的高效卷积神经网络"><a href="#MobileNets-Efficient-Convolutional-Neural-Networks-for-Mobile-Vision-Applications-MobileNets：用于移动视觉应用的高效卷积神经网络" class="headerlink" title="MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications(MobileNets：用于移动视觉应用的高效卷积神经网络)"></a>MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications(MobileNets：用于移动视觉应用的高效卷积神经网络)</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><h4 id="作者写作的目的"><a href="#作者写作的目的" class="headerlink" title="作者写作的目的"></a>作者写作的目的</h4><p>为了能够将深度学习模型应用于移动应用中（例如手机等），因此需要降低模型的复杂度，从而降低对于运算时间和内存的消耗。</p><h4 id="作者的创新点"><a href="#作者的创新点" class="headerlink" title="作者的创新点"></a>作者的创新点</h4><p>使用Depthwise Separable Convolution(深度可分离卷积)和pointwise convolution(逐点卷积)来对传统的卷积操作进行切分，这样子就降低了模型的参数，从而就降低了运算时间和内存消耗。</p><h3 id="MobileNets"><a href="#MobileNets" class="headerlink" title="MobileNets"></a>MobileNets</h3><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p>网络的主要的单元是由Depthwise Separable Convolution和Pointwise Convolution来代替普通卷积来构成的。</p><p><img src="/2020/10/15/MobileNetv1/network.jpg" alt="avatar"></p><p>在每个深度可分离卷积和逐点卷积之后加上BN和ReLU层来进行操作。接下来分别说一说这俩个卷积。</p><h5 id="Depthwise-Separable-Convolution"><a href="#Depthwise-Separable-Convolution" class="headerlink" title="Depthwise Separable Convolution"></a>Depthwise Separable Convolution</h5><p>对于传统的卷积模型，要将$D_K\times D_k\times M$经过卷积成$D_K\times D_K\times N$,要使用(kernel_size = m)的卷积核$m\times m\times M\times N$</p><p>因此对于FLOPs，为$D_K\times D_K\times m\times m\times M\times N$，从理论上来说传统的卷积，是对于一个channel来说有$m\times m\times N$的size的卷积核来与feature map进行卷积操作。</p><p>对于Depthwise Separable Convolution，卷积核的一个channel对应于feature map的一个channel，因此只需要使用$m\times m \times M$ size的卷积核即可进行深度可分离卷积。</p><h5 id="Pointwise-Convolution"><a href="#Pointwise-Convolution" class="headerlink" title="Pointwise Convolution"></a>Pointwise Convolution</h5><p>对于深度可分离卷积操作过后的output我们是没办法改变它的channel的，因此需要逐点卷积来进行channel的改变，因此需要$1\times 1\times M \times N$size的卷积核。</p><p>因此对于上述操作之后，FLOPs为$D_K\times D_K \times m\times m\times M+D_K\times D_K\times M\times N$，因此相对于传统的卷积，FLOPs降低了$m^2$</p><h5 id="Body-Architecture"><a href="#Body-Architecture" class="headerlink" title="Body Architecture"></a>Body Architecture</h5><p>下图是它的模型的整体参数</p><p><img src="/2020/10/15/MobileNetv1/Body Architecture.jpg" alt="avatar"></p><p>对于模型我们引入俩个参数$\alpha$(宽度因子)和$\rho$(分辨率因子)来分别控制输入通道，输出通道的大小和输入图片的size。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MobileNets-Efficient-Convolutional-Neural-Networks-for-Mobile-Vision-Applications-MobileNets：用于移动视觉应用的高效卷积神经网络&quot;&gt;&lt;a href=&quot;#MobileNets</summary>
      
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="backbone" scheme="https://ywj1.github.io/tags/backbone/"/>
    
    <category term="classfication" scheme="https://ywj1.github.io/tags/classfication/"/>
    
  </entry>
  
  <entry>
    <title>EfficientDet</title>
    <link href="https://ywj1.github.io/2020/10/13/EfficientDet/"/>
    <id>https://ywj1.github.io/2020/10/13/EfficientDet/</id>
    <published>2020-10-13T07:35:23.000Z</published>
    <updated>2020-10-22T07:38:48.000Z</updated>
    
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="object detection" scheme="https://ywj1.github.io/tags/object-detection/"/>
    
    <category term="one-stage" scheme="https://ywj1.github.io/tags/one-stage/"/>
    
  </entry>
  
  <entry>
    <title>EfficientNet</title>
    <link href="https://ywj1.github.io/2020/10/13/EfficientNet/"/>
    <id>https://ywj1.github.io/2020/10/13/EfficientNet/</id>
    <published>2020-10-13T07:35:03.000Z</published>
    <updated>2020-10-22T07:38:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EfficientNet-Rethinking-Model-Scaling-for-Convolutional-Neural-Networks-EfficientNet-对卷积神经网络缩放的重新思考"><a href="#EfficientNet-Rethinking-Model-Scaling-for-Convolutional-Neural-Networks-EfficientNet-对卷积神经网络缩放的重新思考" class="headerlink" title="EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks(EfficientNet:对卷积神经网络缩放的重新思考)"></a>EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks(EfficientNet:对卷积神经网络缩放的重新思考)</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><p><strong>作者写作目的?</strong></p><p>作者为了能够量化卷积神经网络的缩放（即深度，宽度和图片的解析率）对accuracy造成的影响，作者设计了compound scaling。同时扩展模型的不同维度来增加模型的效率，并保持accuracy增加。</p><p><strong>作者的新颖之处</strong></p><p>我觉得这篇文章的一个亮点，就是设计了compound scaling，将指标进行了量化，在增长accuracy的同时，提高了模型的efficiency。其中EfficientNet只是一个backbone，基于之前的模型设计出来的。</p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>从Net的名字可以看出，这是一个Efficient work，文章的主题思路，设计了一个compound scaling：</p><script type="math/tex; mode=display">depth:d = \alpha^\phi\\width:w=\beta^\phi\\resolution:r=\gamma^\phi\\s.t. \alpha\times\beta^2\times\gamma^2≈2</script><p>而这个compound scaling是从俩个observation中的得出的：</p><ul><li>Observation 1：对于网络的深度，宽度，分辨率中任何维度进行随访都可以提高精度，但是当模型足够大时候，会达到饱和。</li><li>Observation 2：为了追求更好的精度和效率，在缩放时平衡网络所有维度至关重要。</li></ul><p>为了确定constant参数，首先固定$\phi = 1$，进行一个小范围的搜索，最终确定的值为，$\alpha=1.2,\beta=1.1,\gamma=1.15$，之后的EfficientNetB1-B7都是基于该参数进行缩放的。</p><h4 id="EfficientNet"><a href="#EfficientNet" class="headerlink" title="EfficientNet"></a>EfficientNet</h4><p>EfficientNet基于mobile invered bottlenetc MBConv来进行设计，总体架构如下图所示：</p><p><img src="/2020/10/13/EfficientNet/Network.jpg" alt="avatar"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;EfficientNet-Rethinking-Model-Scaling-for-Convolutional-Neural-Networks-EfficientNet-对卷积神经网络缩放的重新思考&quot;&gt;&lt;a href=&quot;#EfficientNet-Rethinki</summary>
      
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="backbone" scheme="https://ywj1.github.io/tags/backbone/"/>
    
    <category term="classification" scheme="https://ywj1.github.io/tags/classification/"/>
    
  </entry>
  
  <entry>
    <title>SSD</title>
    <link href="https://ywj1.github.io/2020/10/09/SSD/"/>
    <id>https://ywj1.github.io/2020/10/09/SSD/</id>
    <published>2020-10-09T05:47:08.000Z</published>
    <updated>2020-10-14T12:42:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSD-Single-Shot-MultiBox-Detector"><a href="#SSD-Single-Shot-MultiBox-Detector" class="headerlink" title="SSD: Single Shot MultiBox Detector"></a>SSD: Single Shot MultiBox Detector</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><p><strong>作者写作目的？</strong></p><p>加快检测速度，并提高准确率</p><p><strong>新颖的方法？</strong></p><p>SSD提取了不同尺度的特征图来进行预测。</p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>从名字可以读出SSD是一个多框预测算法，并且在准确度和速度上都比YOLO算法要好，SSD相对于YOLO算法有俩个很重要的改变：1. 提取了不同尺度的特征图来进行检测，使用大尺度来检测小物体，小尺度来进行检测大物体。2. 使用Default boxes(anchor boxes)来进行多框预测，并且不同于YOLO算法使用Fully connected，SSD使用$3\times 3$filter来进行结果预测。</p><h4 id="SSD模型"><a href="#SSD模型" class="headerlink" title="SSD模型"></a>SSD模型</h4><p>使用VGG模型(改造过)进行特征提取，在VGG提取之后，继续使用卷积核来继续进行特征图提取，并且对于不同的feature map使用$3\times 3$ filter来进行边界框预测和分类，最后使用NMS算法，删除多余的候选框，最后得到预测的边界框。(如下图)</p><p><img src="/2020/10/09/SSD/model.jpg" alt="avatar"></p><h5 id="SSD模型的改进之处"><a href="#SSD模型的改进之处" class="headerlink" title="SSD模型的改进之处"></a>SSD模型的改进之处</h5><p><strong>用于目标检测的多尺度特征图</strong></p><p>在改造过后的VGGNet使用卷积层继续提取feature map，使用后续的feature map来进行object detection。从而达到了多尺度的效果。(因为使用同一张图的不同feature map可以提高语义分割的质量，这类似于使用不同尺度的相同种类图片)</p><p><strong>使用卷积核来进行目标预测</strong></p><p>如上图所示，不同于YOLO算法在backbone之后使用fully connected layer，SSD使用convolutional layer来进行目标的预测。</p><p><strong>默认框和高宽比</strong></p><p>即使用了anchor boxes在每个特征图中。</p><h5 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h5><p><strong>匹配策略</strong></p><p>对于default boxes和ground truth，使用IoU大于0.5的当作正样本。</p><p><strong>目标函数</strong></p><script type="math/tex; mode=display">L(x,c,l,g) = \frac{1}{N}(L_{conf}(x,c)+\alpha L_{loc}(x,l,g))</script><p>$L_{conf}$表示的分类损失函数，使用softmax loss函数来进行计算</p><script type="math/tex; mode=display">L_{conf}(x,c) = -\sum^N_{i\in Pos(T)}x_{ij}^plog(\hat{c}_i^p)-\sum_{i\in Neg(F)}log(\hat{c}_0^i)</script><script type="math/tex; mode=display">\hat{c}_i^p = \frac{exp(c_i^p)}{\sum_jexp(c_i^j)}​</script><p>$L_{loc}$表示的是回归损失函数，使用Smooth L1函数来进行计算，其中回归表示的边界框损失回归。(详见Faster R-CNN)</p><p><strong>为default boxes选不同的scales和aspect ratios</strong></p><p>scale of default boxes is defined as:</p><script type="math/tex; mode=display">s_k = s_{min} + \frac{s_{max} - s_{min}}{m-1}(k-1), k\in[1,m]</script><p>论文中设置$s_{min} = 0.2, s_{max} = 0.9，m = 6$，并且设置$aspect  ratios\in \{1,2,3,1/2,1/3\} $，对于ration为1的default boxes，继续设置scale为$\sqrt{s_ks_{k+1}}$，对于每个default boxes我们设置中心点为</p><script type="math/tex; mode=display">(\frac{i+0.5}{|f_k|},\frac{j+0.5}{|f_k|})</script><p>$|f_k|$表示的是第k个feature map的面积。</p><p>并且对于VGG中的feature map和最后一层feature map只设置4个default boxes，不设置3，1/3这俩个高宽比。</p><p><strong>设置训练样本</strong></p><p>按照default boxes产生的负样本会有很多，因此会产生正负样本比例失调，从而导致了欠拟合，因此我们将负样本按照IoU从大到小排序，并选取3：1的正负样本比例。</p><p><strong>VGGNet的改进</strong></p><p>将VGG16的全连接层fc6和fc7换成$3\times 3$的卷积层和$1\times 1$的卷积层，并将前一层的池化层使用Atrous Algorithm(带孔卷积\\扩展卷积)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SSD-Single-Shot-MultiBox-Detector&quot;&gt;&lt;a href=&quot;#SSD-Single-Shot-MultiBox-Detector&quot; class=&quot;headerlink&quot; title=&quot;SSD: Single Shot MultiBox </summary>
      
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Object detection" scheme="https://ywj1.github.io/tags/Object-detection/"/>
    
    <category term="one-stage" scheme="https://ywj1.github.io/tags/one-stage/"/>
    
  </entry>
  
  <entry>
    <title>AI在医学应用</title>
    <link href="https://ywj1.github.io/2020/10/08/AI%E5%9C%A8%E5%8C%BB%E5%AD%A6%E5%BA%94%E7%94%A8/"/>
    <id>https://ywj1.github.io/2020/10/08/AI%E5%9C%A8%E5%8C%BB%E5%AD%A6%E5%BA%94%E7%94%A8/</id>
    <published>2020-10-08T06:36:33.000Z</published>
    <updated>2020-10-08T06:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h4><p>two-stage相对于one-stage具有更高的精度，因此使用two-stage来进行检测</p><p>医学图像的正负样本不均衡，使用data augmentation来进行样本扩充。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;注意的点&quot;&gt;&lt;a href=&quot;#注意的点&quot; class=&quot;headerlink&quot; title=&quot;注意的点&quot;&gt;&lt;/a&gt;注意的点&lt;/h4&gt;&lt;p&gt;two-stage相对于one-stage具有更高的精度，因此使用two-stage来进行检测&lt;/p&gt;
&lt;p&gt;医学图像的正负</summary>
      
    
    
    
    
    <category term="Object detection" scheme="https://ywj1.github.io/tags/Object-detection/"/>
    
  </entry>
  
  <entry>
    <title>YOLO9000</title>
    <link href="https://ywj1.github.io/2020/10/07/YOLO9000/"/>
    <id>https://ywj1.github.io/2020/10/07/YOLO9000/</id>
    <published>2020-10-07T06:19:40.000Z</published>
    <updated>2020-10-07T06:19:42.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>论文常用单词与句子</title>
    <link href="https://ywj1.github.io/2020/09/29/%E8%AE%BA%E6%96%87%E5%B8%B8%E7%94%A8%E5%8D%95%E8%AF%8D%E4%B8%8E%E5%8F%A5%E5%AD%90/"/>
    <id>https://ywj1.github.io/2020/09/29/%E8%AE%BA%E6%96%87%E5%B8%B8%E7%94%A8%E5%8D%95%E8%AF%8D%E4%B8%8E%E5%8F%A5%E5%AD%90/</id>
    <published>2020-09-29T09:53:25.000Z</published>
    <updated>2020-09-29T10:11:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="论文常用单词与句子"><a href="#论文常用单词与句子" class="headerlink" title="论文常用单词与句子"></a>论文常用单词与句子</h2><h4 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h4><p>via    conj. 通过</p><p>low-resolution    n. 低分辨率</p><p>semantically strong feature    特征语义强</p><p>infeasible    adj.不可行的</p><p>spatial    adj.空间的</p><p>practical solution    实际的解决方案</p><p>frame……as……    视作，将这框为</p><p>refreshingly    adv.令人耳目一新地,及其</p><p>lag behind    落后</p><p>pretrain    预训练</p><p>resolution    分辨率(图片的尺寸)</p><p>invariant    不变的</p><p>design defect    设计缺陷</p><p>remarkable    卓越的</p><p>deep convolutional networks(ConvNets)</p><p>without bells and whistles    没有任何技巧</p><p>outperform    超过</p><p>tackle the problem    解决问题</p><p>methodology    方法</p><h4 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h4><p>The goal of this paper is to ……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;论文常用单词与句子&quot;&gt;&lt;a href=&quot;#论文常用单词与句子&quot; class=&quot;headerlink&quot; title=&quot;论文常用单词与句子&quot;&gt;&lt;/a&gt;论文常用单词与句子&lt;/h2&gt;&lt;h4 id=&quot;单词&quot;&gt;&lt;a href=&quot;#单词&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="笔记" scheme="https://ywj1.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://ywj1.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>AugFPN</title>
    <link href="https://ywj1.github.io/2020/09/27/AugFPN/"/>
    <id>https://ywj1.github.io/2020/09/27/AugFPN/</id>
    <published>2020-09-27T05:16:09.000Z</published>
    <updated>2020-10-24T05:58:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AugFPN-Improving-Multi-scale-Feature-Learning-for-Object-Detection-改进用于目标检测的多尺度特征学习"><a href="#AugFPN-Improving-Multi-scale-Feature-Learning-for-Object-Detection-改进用于目标检测的多尺度特征学习" class="headerlink" title="AugFPN: Improving Multi-scale Feature Learning for Object Detection(改进用于目标检测的多尺度特征学习)"></a>AugFPN: Improving Multi-scale Feature Learning for Object Detection(改进用于目标检测的多尺度特征学习)</h2><h3 id="初步阅读（10-20-）"><a href="#初步阅读（10-20-）" class="headerlink" title="初步阅读（10%-20%）"></a>初步阅读（10%-20%）</h3><p><strong>作者的写作目的？</strong></p><p>为了提高FPN网络的性能，在FPN网络基础之上，对FPN网络进行改进。首先分析FPN网络各个模块的问题（<font color="red">3个问题</font>)(待解决)，之后提出了AugFPN，AugFPN分为三个模块（待解决）</p><p><strong>作者用的方法？</strong></p><p>提出AugFPN网络，AugFPN网络分为三个类别：Consistant Supervision，Residual Feature Augmentation，Soft ROI Selection</p><p><strong>FPN存在的三个问题</strong></p><ol><li>before feature fusion: 对于原图像使用$1\times1$卷积减少通道时候，会减弱图像的多尺度特征表达（水平方向）</li><li>top-down feature fusion: 在特征融合过程中，顶层由于减少了通道，会造成最高层特征图的信息减少（垂直方向）</li><li>after feature fusion: <font color="red">FPN中每个候选区域(ROI)的特征都是根据proposal的尺度来决定相应的特征图从哪一层选择，然而\那些忽略的层也是包含着丰富信息的，它们对最终的分类和回归结果也有着影响。直接忽略了其它层的特征势必会影响到最终的检测结果。</font></li></ol><p><strong>AugFPN三个策略解决问题</strong></p><ol><li>Consistent Supervision</li><li>Residual Feature Augmentation</li><li>Soft RoI Selection</li></ol><hr><h3 id="进一步阅读-20-60"><a href="#进一步阅读-20-60" class="headerlink" title="进一步阅读(20%-60%)"></a>进一步阅读(20%-60%)</h3><h4 id="design-defects"><a href="#design-defects" class="headerlink" title="design defects"></a>design defects</h4><p>文章根据FPN的三个不同阶段的三个缺陷提出了不同的解决方法，最后将这三个方法整合在一起，形成了AugFPN。</p><p>这三个不同阶段分别是特征融合(feature fusion)前，特征融合中，特征融合后</p><p>特征融合前：由于在特征融合之前，对于backbone生成的不同feature map要使用$1\times 1$卷积，将会降低多尺度特征表达(??)，因为没有考虑semantic gap。(？？)使用存在语义差异的特征进行融合，可能会导致次优解。</p><p>特征融合中：对于top-down pathway的feature map和backbone的feature map进行element-wise相加，可能会损失空间解析率和空间细节，因为可能有多个物体存在一个照片中。</p><p>特征融合后：每个目标的proposal都是基于从一个特征层次上汇聚的特征网格进行细化的，这些特征网格是根据proposals的尺度启发式地选择的。但是，来自其他级别的被忽略的特性可能对对象分类或回归有益。考虑到这个问题，PANet集合了所有金字塔层的RoIs特征，并将它们以max操作方式融合，然后将它们与独立的全连接层融合。然而，max融合会忽略响应较小的特性，而这些特性可能也很有帮助，并且仍然不能充分利用其他级别的特性。同时，额外的全连通层显著增加了模型参数（不太懂，只是翻译）</p><h4 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h4><p><img src="/2020/09/27/AugFPN/architecture.jpg" alt="avatar"></p><h5 id="Consistent-Supervision"><a href="#Consistent-Supervision" class="headerlink" title="Consistent Supervision"></a>Consistent Supervision</h5><p>对融合后的特征图M2~M5进行监督，具体方法使对RPN网络得到的每一个候选区域分别映射到M2~M5上的到相应的feature map，对feature map进行分类和回归，这样得到一个损失函数，将这个损失函数和网络本身的损失进行一个加权求和。</p><h5 id="Residual-Feature-Augmentation"><a href="#Residual-Feature-Augmentation" class="headerlink" title="Residual Feature Augmentation"></a>Residual Feature Augmentation</h5><p>在融合之前使用$1\times 1$的卷积进行特征降维，会造成信息损失，因为C5的信息使没有损失的，因此将C5的特征融合到M5中，减少了信息损失。</p><h5 id="Soft-RoI-Selection"><a href="#Soft-RoI-Selection" class="headerlink" title="Soft RoI Selection"></a>Soft RoI Selection</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;AugFPN-Improving-Multi-scale-Feature-Learning-for-Object-Detection-改进用于目标检测的多尺度特征学习&quot;&gt;&lt;a href=&quot;#AugFPN-Improving-Multi-scale-Feature-</summary>
      
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Feature Fusion" scheme="https://ywj1.github.io/tags/Feature-Fusion/"/>
    
    <category term="Object detection" scheme="https://ywj1.github.io/tags/Object-detection/"/>
    
  </entry>
  
  <entry>
    <title>FPN</title>
    <link href="https://ywj1.github.io/2020/09/26/FPN/"/>
    <id>https://ywj1.github.io/2020/09/26/FPN/</id>
    <published>2020-09-26T05:55:23.000Z</published>
    <updated>2020-10-24T05:58:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Feature-Pyramid-Networks-for-Object-Detection-用于目标检测的特征金字塔网络"><a href="#Feature-Pyramid-Networks-for-Object-Detection-用于目标检测的特征金字塔网络" class="headerlink" title="Feature Pyramid Networks for Object Detection(用于目标检测的特征金字塔网络)"></a>Feature Pyramid Networks for Object Detection(用于目标检测的特征金字塔网络)</h2><h3 id="初步阅读-10-40"><a href="#初步阅读-10-40" class="headerlink" title="初步阅读(10%-40%)"></a>初步阅读(10%-40%)</h3><p><strong>作者的写作目的是什么？</strong></p><p>为了解决目标检测算法在处理多尺度变化问题时候的不足，因为Faster R-CNN, Fast R-CNN都是基于单个高层特征（即通过CNN提取后的特征图）来进行目标检测的，这种方法对于小物体不是特别友好（因为提取之后的特征图语义特征比较强，分辨率比较低）因此对于小物体定位并不是很好，因此设计出来特征金字塔来进行特征的提取，使不同尺度的特征具有较强的语义信息。</p><p><strong>作者提出的方法？</strong></p><p>作者提出了FPN(Feature Pyramid Network)来构建特征金字塔，由于现有的特征金字塔网络回答来极大的计算量和内存需求。</p><p>FPN网络有俩个层次构成，一个是自下而上的过程，另一个是自顶向下(top-down architecture)和侧向连接(lateral connections)</p><p><img src="/2020/09/26/FPN/Network.jpg" alt="avatar"></p><hr><h3 id="进一步阅读-40-80"><a href="#进一步阅读-40-80" class="headerlink" title="进一步阅读(40%-80%)"></a>进一步阅读(40%-80%)</h3><p>特征金字塔是CV中常用的技巧，主要目的是能够让网络识别不同尺度中的目标，使网络具有尺度不变性(scale-invariant)。但是随着DL的应用，feature pyramid使用的比较少。</p><ul><li>首先因为CNN就具有较强的robust再尺度改变的情况下</li><li>在DL中使用特征金字塔，会产生很大的内存开销和更长的运算时间，在实践中基本只会在测试中使用，这就会造成train/test不连续。</li></ul><h4 id="CNN提取图像特征的性质"><a href="#CNN提取图像特征的性质" class="headerlink" title="CNN提取图像特征的性质"></a>CNN提取图像特征的性质</h4><p>我们知道CNN使用Conv/Pooling来操作图像，不同深度的layer会产生不同的feature map和spatial dimension，深层的feature map具有更高的语义特征（semantically strong features）和低分辨率（low-resoltion），底层的feature map则相反。因此该文章的目的使通过结合不同的feature map形成一个在不同尺度下有强语义特征的图像。</p><p>对比不同的Feature Pyramid:</p><p><img src="/2020/09/26/FPN/Pyramid-feature.png" alt="avatar"></p><p>(a): 将图像做成金字塔，分别使用一个NN来进行预测，计算量很大(HOG)</p><p>(b): 只在最后一层的feature map来进行预测，只在single scale(faster R-CNN等)</p><p>(c): 将各个layer的输出feature map堪称feature pyramid来进行(SSD)</p><p>(d): 本文的做法，对于不同层级的feature map进行merge，使每个level的语义信息比较强。</p><h4 id="FPN具体实现"><a href="#FPN具体实现" class="headerlink" title="FPN具体实现"></a>FPN具体实现</h4><p><strong>Bottom-up pathway</strong>: 就是一个前向传播，相当于一个backbone，进行特征的提取。</p><p><strong>Top-down pathway and lateral connection</strong>：将上层的feature map进行upsamling（高层的feature map有更强的语义特征，通过upsampling变成有更高分辨率），并且与bottom-up获</p><p>得feature map（使用$1\times 1$卷积改变通道）进行lateral connection进行增强。如下图所示：</p><p><img src="/2020/09/26/FPN/lateral-connection.png" alt="avatar"></p><p>高层的feature map经过upsampling和横向的bottom-up的feature map进行element-wise的相加。</p><p>并且为了减少上采样的混叠效果(reduce the aliasing effect of upsampling)，对于每个merged map使用一个$3\times 3$卷积来进行处理。</p><p>下面使tensorflow实现：</p><pre class=" language-lang-python"><code class="language-lang-python">import  tensorflow as tffrom    tensorflow.keras import layersclass FPN(tf.keras.Model):    def __init__(self, out_channels=256, **kwargs):        '''        Feature Pyramid Networks        Attributes        ---            out_channels: int. the channels of pyramid feature maps.        '''        super(FPN, self).__init__(**kwargs)        self.out_channels = out_channels        #lateral connection        self.fpn_c2p2 = layers.Conv2D(out_channels, (1, 1),                                       kernel_initializer='he_normal', name='fpn_c2p2')        self.fpn_c3p3 = layers.Conv2D(out_channels, (1, 1),                                       kernel_initializer='he_normal', name='fpn_c3p3')        self.fpn_c4p4 = layers.Conv2D(out_channels, (1, 1),                                       kernel_initializer='he_normal', name='fpn_c4p4')        self.fpn_c5p5 = layers.Conv2D(out_channels, (1, 1),                                       kernel_initializer='he_normal', name='fpn_c5p5')        #top-down pathway        self.fpn_p3upsampled = layers.UpSampling2D(size=(2, 2), name='fpn_p3upsampled')        self.fpn_p4upsampled = layers.UpSampling2D(size=(2, 2), name='fpn_p4upsampled')        self.fpn_p5upsampled = layers.UpSampling2D(size=(2, 2), name='fpn_p5upsampled')        #减少upsampling的混叠效果        self.fpn_p2 = layers.Conv2D(out_channels, (3, 3), padding='SAME',                                     kernel_initializer='he_normal', name='fpn_p2')        self.fpn_p3 = layers.Conv2D(out_channels, (3, 3), padding='SAME',                                     kernel_initializer='he_normal', name='fpn_p3')        self.fpn_p4 = layers.Conv2D(out_channels, (3, 3), padding='SAME',                                     kernel_initializer='he_normal', name='fpn_p4')        self.fpn_p5 = layers.Conv2D(out_channels, (3, 3), padding='SAME',                                     kernel_initializer='he_normal', name='fpn_p5')        self.fpn_p6 = layers.MaxPooling2D(pool_size=(1, 1), strides=2, name='fpn_p6')    def call(self, inputs, training=True):        C2, C3, C4, C5 = inputs        P5 = self.fpn_c5p5(C5)        P4 = self.fpn_c4p4(C4) + self.fpn_p5upsampled(P5)        P3 = self.fpn_c3p3(C3) + self.fpn_p4upsampled(P4)        P2 = self.fpn_c2p2(C2) + self.fpn_p3upsampled(P3)        # Attach 3x3 conv to all P layers to get the final feature maps.        P2 = self.fpn_p2(P2)        P3 = self.fpn_p3(P3)        P4 = self.fpn_p4(P4)        P5 = self.fpn_p5(P5)        # subsampling from P5 with stride of 2.        P6 = self.fpn_p6(P5)        return [P2, P3, P4, P5, P6]    def compute_output_shape(self, input_shape):        C2_shape, C3_shape, C4_shape, C5_shape = input_shape        C2_shape, C3_shape, C4_shape, C5_shape = \            C2_shape.as_list(), C3_shape.as_list(), C4_shape.as_list(), C5_shape.as_list()        C6_shape = [C5_shape[0], (C5_shape[1] + 1) // 2, (C5_shape[2] + 1) // 2, self.out_channels]        C2_shape[-1] = self.out_channels        C3_shape[-1] = self.out_channels        C4_shape[-1] = self.out_channels        C5_shape[-1] = self.out_channels        return [tf.TensorShape(C2_shape),                tf.TensorShape(C3_shape),                tf.TensorShape(C4_shape),                tf.TensorShape(C5_shape),                tf.TensorShape(C6_shape)]</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Feature-Pyramid-Networks-for-Object-Detection-用于目标检测的特征金字塔网络&quot;&gt;&lt;a href=&quot;#Feature-Pyramid-Networks-for-Object-Detection-用于目标检测的特征金字塔网络</summary>
      
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Feature Fusion" scheme="https://ywj1.github.io/tags/Feature-Fusion/"/>
    
    <category term="Object detection" scheme="https://ywj1.github.io/tags/Object-detection/"/>
    
  </entry>
  
  <entry>
    <title>YOLOv1</title>
    <link href="https://ywj1.github.io/2020/09/22/YOLOv1/"/>
    <id>https://ywj1.github.io/2020/09/22/YOLOv1/</id>
    <published>2020-09-22T05:57:59.000Z</published>
    <updated>2020-10-07T05:59:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="You-Only-Look-Once-Unified-Real-Time-Object-Detection-统一，实时的目标检测"><a href="#You-Only-Look-Once-Unified-Real-Time-Object-Detection-统一，实时的目标检测" class="headerlink" title="You Only Look Once: Unified, Real-Time Object Detection(统一，实时的目标检测)"></a>You Only Look Once: Unified, Real-Time Object Detection(统一，实时的目标检测)</h2><h4 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h4><p><strong>作者写作目的？</strong></p><p>因为two-stage的目标检测耗时长，并且难训练（因为每个部分是独立的），无法做到实时的检测，因此作者提出了one-stage的算法Yolo。</p><p><strong>作者提出新的方法？</strong></p><p>作者将目标检测视为回归问题，使用一个整合的网络，来进行目标检测的训练，最后输出位置，类别等信息。</p><h4 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h4><p><strong>YOLO算法的优势</strong></p><ol><li>faster</li><li>reason globally about the image：在预测图片时候，可以分析全局的图像，不像two-stage那样，只分析region proposal</li><li>learn the generalizable representations of object：学习概述的特征，可以用于艺术的识别</li></ol><p><strong>YOLO模型的框架</strong></p><p><img src="/2020/09/22/YOLOv1/YOLOv1.png" alt="The architecture"></p><p>输入resize: $448\times 448\times 3$</p><p>输出: $7\times 7\times 30$</p><p>其中输出为$7\times 7$表示的是将图像分为$7\times 7$的网格，最后30分为20和10，10为俩个bounding box(坐标和confidence: 表示是否是物体)，20为一个20个类别。</p><p>bounding box: 四个坐标(x,y,w,h), confidence表示该边界框是否包含目标，$confidence = Pr(object)*IOU_{pred}^{truth}$</p><p>激活函数使用Leaky relu函数来进行</p><p><img src="/2020/09/22/YOLOv1/loss_function.png" alt="loss function"></p><p>其中$\lambda_{coord} = 5, \lambda_{noobj} = 0.5$</p><p><strong>YOLO的缺点</strong></p><p>对于小物体效果不好，并且一个网格中只能预测了俩个框，并且只属于一类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;You-Only-Look-Once-Unified-Real-Time-Object-Detection-统一，实时的目标检测&quot;&gt;&lt;a href=&quot;#You-Only-Look-Once-Unified-Real-Time-Object-Detection-统一</summary>
      
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Object detection" scheme="https://ywj1.github.io/tags/Object-detection/"/>
    
    <category term="one-stage" scheme="https://ywj1.github.io/tags/one-stage/"/>
    
  </entry>
  
  <entry>
    <title>如何写学术论文</title>
    <link href="https://ywj1.github.io/2020/09/21/%E5%A6%82%E4%BD%95%E5%86%99%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"/>
    <id>https://ywj1.github.io/2020/09/21/%E5%A6%82%E4%BD%95%E5%86%99%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/</id>
    <published>2020-09-21T13:57:52.000Z</published>
    <updated>2020-09-25T12:04:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何书写学术论文（学术论文-70-思考-计划-30-写作-修改）"><a href="#如何书写学术论文（学术论文-70-思考-计划-30-写作-修改）" class="headerlink" title="如何书写学术论文（学术论文 = 70%思考/计划+30%写作/修改）"></a>如何书写学术论文（学术论文 = 70%思考/计划+30%写作/修改）</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>首先有个好的idea（标题很重要）<ul><li>寻找idea的几种思路（全新的发现，新的方法，新理论或者新模型，新应用，改进原有的方法获得更好的性能）后俩者比较容易</li><li>多读文献多思考（必须多看，才有想法，才会对这一块了解）</li></ul></li><li>想好文章的核心观点</li><li>构思论文的大框架</li><li>提前整理好数据</li><li>论文写作和修改<ul><li>多英文文献时候（作者是老外），记录好的句型和好的词汇（修饰词和专业术语）</li><li>Grammy插件</li></ul></li><li>投稿</li></ol><h3 id="如何思考"><a href="#如何思考" class="headerlink" title="如何思考"></a>如何思考</h3><p><strong>画出你的研究（Picturing your research）</strong>：</p><ol><li><p>what？ </p><ul><li>main research question文章主要讲的是什么</li><li>Disciplines 研究问题涵盖的所有领域或者学科</li></ul></li><li><p>why？</p><ul><li>Reasons 为什么做这个研究（创新点是什么）Most important</li></ul></li><li>how？<ul><li>Methods 如何去解决这个问题</li></ul></li></ol><h3 id="书写方法"><a href="#书写方法" class="headerlink" title="书写方法"></a>书写方法</h3><h5 id="引言部分"><a href="#引言部分" class="headerlink" title="引言部分"></a>引言部分</h5><p>找十篇相关文献，研究写作思路，之后构思自己的研究思路，在进行模仿写作。</p><ul><li>第一段介绍课题背景或者起源</li><li>第二段介绍前辈的研究动态，引用大量文献（这个一定要自我整理）</li><li>总结自己的研究，主要解决的是什么问题，在哪些方面做出贡献等</li></ul><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p>标题：有一个简明扼要并且具有吸引力的标题</p><hr><h2 id="如何写好论文和评审（笔记）"><a href="#如何写好论文和评审（笔记）" class="headerlink" title="如何写好论文和评审（笔记）"></a>如何写好论文和评审（笔记）</h2><h3 id="如何写好Paper"><a href="#如何写好Paper" class="headerlink" title="如何写好Paper"></a>如何写好Paper</h3><ol><li>首先确定自己的主题</li><li>简单介绍其他方法，为什么不够好</li><li>介绍你的方法，与其他方法比较，优势在哪里</li><li>最后，介绍相关工作</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何书写学术论文（学术论文-70-思考-计划-30-写作-修改）&quot;&gt;&lt;a href=&quot;#如何书写学术论文（学术论文-70-思考-计划-30-写作-修改）&quot; class=&quot;headerlink&quot; title=&quot;如何书写学术论文（学术论文 = 70%思考/计划+30%</summary>
      
    
    
    
    <category term="笔记" scheme="https://ywj1.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="论文书写" scheme="https://ywj1.github.io/tags/%E8%AE%BA%E6%96%87%E4%B9%A6%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建博客</title>
    <link href="https://ywj1.github.io/2020/09/21/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://ywj1.github.io/2020/09/21/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-09-21T02:31:00.000Z</published>
    <updated>2020-09-28T02:56:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>当hexo g -d发生以下错误时候</p><p><img src="/2020/09/21/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/error.png" alt="avatar"></p><p>使用以下命令可以解决</p><pre><code>git config --global user.email &quot;you@example.com&quot; git config --global user.name &quot;Your Name&quot;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当hexo g -d发生以下错误时候&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/09/21/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/error.png&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用以下命令可以解决&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="笔记" scheme="https://ywj1.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://ywj1.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>论文进度</title>
    <link href="https://ywj1.github.io/2020/09/19/%E8%AE%BA%E6%96%87%E8%BF%9B%E5%BA%A6/"/>
    <id>https://ywj1.github.io/2020/09/19/%E8%AE%BA%E6%96%87%E8%BF%9B%E5%BA%A6/</id>
    <published>2020-09-19T10:25:36.000Z</published>
    <updated>2020-10-20T06:33:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h3><p>PS：</p><ul><li>10%-20%: abstract, figure and conclusion(问自己作者的目的，新颖的方法是什么)</li><li>20%-40%：新颖的方法是什么大概的步骤</li><li>40%-60%：文章使用方法的具体步骤</li><li>60%-80%：开代码+写blog 理清文章</li><li>80%-100%：文章实验看看</li></ul><div class="table-container"><table><thead><tr><th>Source</th><th>10%-20%</th><th>20%-40%</th><th>40%-60%</th><th>60%-80%</th><th>80%-100%</th></tr></thead><tbody><tr><td>Feature Pyramid Networks for Object Detection</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td><td></td></tr><tr><td>AugFPN: Improving Multi-scale Feature Learning for Object Detection</td><td>✔</td><td>✔</td><td></td><td></td><td></td></tr><tr><td>Bridging the Gap Between Anchor-based and Anchor-free Detection via Adaptive Training Sample Selection</td><td>✔</td><td></td><td></td><td></td><td></td></tr><tr><td>CentripetalNet: Pursuing High-quality Key-point Pairs for Object Detection</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Few-Shot Object Detection with Attention-RPN and Multi-Relation Detector</td><td>✔</td><td></td><td></td><td></td><td></td></tr><tr><td>Multi-task Collaborative Network for Joint Referring Expression Comprehension and Segmentation</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Hit-Detector: Hierarchical Trinity Architecture Search for Object Detection</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>SSD: Single Shot MultiBox Detector</td><td>✔</td><td>✔</td><td>✔</td><td></td><td></td></tr><tr><td>You Only Look Once:Unified, Real-Time Object Detection</td><td>✔</td><td></td><td></td><td></td><td></td></tr><tr><td>YOLO9000: Better, Faster, Stronger</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>YOLOv3: An Incremental Improvement</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications</td><td>✔</td><td>✔</td><td>✔</td><td></td><td></td></tr><tr><td>MobileNetV2 Inverted Residuals and Linear Bottlenecks</td><td>✔</td><td>✔</td><td>✔</td><td></td><td></td></tr><tr><td>Focal Loss for Dense Object Detection</td><td>✔</td><td>✔</td><td></td><td></td><td></td></tr><tr><td>EfficientDet Scalable and Efficient Object Detection</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CenterNet: Keypoint Triplets for Object Detection</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Scale-Aware Trident Networks for Object Detection</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Objects as Points</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CornerNet Detecting Objects as Paired Keypoints</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><h3 id="医学论文"><a href="#医学论文" class="headerlink" title="医学论文"></a>医学论文</h3><div class="table-container"><table><thead><tr><th>Source</th><th>10%-20%</th><th>20%-40%</th><th>40%-60%</th><th>60%-80%</th><th>80%-100%</th></tr></thead><tbody><tr><td>Artificial Intelligence (AI) Assisted MRI Image Fusion Technique in Preoperative Evaluation of a Pelvic Bone Osteosarcoma</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>MSFCN-multiple supervised fully convolutional networks for the osteosarcoma segmentation of CT images</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Multiple supervised residual network for osteosarcoma segmentation in CT images</td><td>✔</td><td>✔</td><td>✔</td><td></td><td></td></tr><tr><td>Deep Learning-Based Multi-Omics</td><td></td><td></td><td></td><td></td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;目标检测&quot;&gt;&lt;a href=&quot;#目标检测&quot; class=&quot;headerlink&quot; title=&quot;目标检测&quot;&gt;&lt;/a&gt;目标检测&lt;/h3&gt;&lt;p&gt;PS：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;10%-20%: abstract, figure and conclusion(问自己作</summary>
      
    
    
    
    <category term="记录" scheme="https://ywj1.github.io/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Plan" scheme="https://ywj1.github.io/tags/Plan/"/>
    
    <category term="论文" scheme="https://ywj1.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode--2020.9</title>
    <link href="https://ywj1.github.io/2020/09/18/Leetcode-2020-9/"/>
    <id>https://ywj1.github.io/2020/09/18/Leetcode-2020-9/</id>
    <published>2020-09-18T07:36:05.000Z</published>
    <updated>2021-06-01T12:07:47.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode—2020-9"><a href="#Leetcode—2020-9" class="headerlink" title="Leetcode—2020.9"></a>Leetcode—2020.9</h2><h3 id="Day01"><a href="#Day01" class="headerlink" title="Day01"></a>Day01</h3><p><a href="https://leetcode-cn.com/problems/permutations/"><strong>题目链接</strong></a></p><p><strong>题目介绍</strong></p><pre class=" language-lang-python"><code class="language-lang-python">给定一个 没有重复 数字的序列，返回其所有可能的全排列。示例:输入: [1,2,3]输出:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre><p><strong>题目思路</strong>：</p><p>首先这是一个树，每个位置可填入的不同的数字就构成了一个树，然后采用深度遍历方法就可以实现这个算法。</p><ol><li>定义递归函数back(first, output)，从左到右来填到first这个位置，并且当前排列是output</li><li>数组长度是n，如果first == n即最后一个位置，那么就输出当前排列，如果first &lt; n，那么就要在first这里填入需要填的数，然后使用递归函数back(first+1, output)。<ul><li>在first &lt; n的时候，在first处填入这个数，我们可以使用交换法来进行，这样子就节省了一部分数据空间，通过对于输入的数组nums[]，其中nums[0,first-1]是已经填过的，nums[first, n-1]是没有的，那么就使用这里的数来进行填充，知道最后完成，并且回溯数组。</li></ul></li></ol><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    void backtrack(vector<vector<int>>& res, vector<int>& output, int first, int len)&#123;        // 所有数都填完了        if (first == len) &#123;            res.emplace_back(output);            return;        &#125;        for (int i = first; i < len; ++i) &#123;            // 动态维护数组            swap(output[i], output[first]);            // 继续递归填下一个数            backtrack(res, output, first + 1, len);            // 撤销操作            swap(output[i], output[first]);        &#125;    &#125;    vector<vector<int>> permute(vector<int>& nums) &#123;        vector<vector<int> > res;        backtrack(res, nums, 0, (int)nums.size());        return res;    &#125;&#125;;</code></pre><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def permute(self, nums: List[int]) -> List[List[int]]:        self.res = []        check = [0 for i in range(len(nums))]        self.backtrack([], nums, check)        return self.res    def backtrack(self, sol, nums, check):        if len(sol) == len(nums):            self.res.append(sol)            return        for i in range(len(nums)):            if check[i] == 1:                continue            check[i] = 1            self.backtrack(sol+[nums[i]], nums, check)            check[i] = 0</code></pre><hr><p><a href="https://leetcode-cn.com/problems/permutations-ii/"><strong>题目链接</strong></a></p><p><strong>题目介绍</strong></p><pre><code>给定一个可包含重复数字的序列，返回所有不重复的全排列。示例:输入: [1,1,2]输出:[  [1,1,2],  [1,2,1],  [2,1,1]]</code></pre><p><strong>思路</strong></p><p>这是上题的加深层次，我们设置一个vis向量来存放该数是否被访问过。并且在上题的思路下，增加一个剪枝的条件。</p><pre class=" language-lang-c++"><code class="language-lang-c++">if (vis[i] || (i > 0 && nums[i] == nums[i - 1] && !vis[i - 1])) &#123;                continue;            &#125;</code></pre><pre class=" language-lang-c++"><code class="language-lang-c++">class Solution &#123;    vector<int> vis;public:    void backtrack(vector<int>& nums, vector<vector<int>>& ans, int idx, vector<int>& perm) &#123;        if (idx == nums.size()) &#123;            ans.emplace_back(perm);            return;        &#125;        for (int i = 0; i < (int)nums.size(); ++i) &#123;            if (vis[i] || (i > 0 && nums[i] == nums[i - 1] && !vis[i - 1])) &#123;                continue;            &#125;            perm.emplace_back(nums[i]);            vis[i] = 1;            backtrack(nums, ans, idx + 1, perm);            vis[i] = 0;            perm.pop_back();        &#125;    &#125;    vector<vector<int>> permuteUnique(vector<int>& nums) &#123;        vector<vector<int>> ans;        vector<int> perm;        vis.resize(nums.size());        sort(nums.begin(), nums.end());        backtrack(nums, ans, 0, perm);        return ans;    &#125;&#125;;</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>模板</strong>：</p><pre><code>递归函数：    if条件成立:        push_back(output)        return;    循环：        剪枝条件        填入数字(swap)        递归函数        撤销(swap)</code></pre><hr><h3 id="Day02"><a href="#Day02" class="headerlink" title="Day02"></a>Day02</h3><h4 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h4><p><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">题目链接</a></p><p>题目描述：</p><pre class=" language-lang-python"><code class="language-lang-python">计算给定二叉树的所有左叶子之和。示例：    3   / \  9  20    /  \   15   7在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</code></pre><p>思路：</p><p>因为是左叶子之和，因此判断该节点是否是左叶子，如果是就存入。</p><pre class=" language-lang-c++"><code class="language-lang-c++">//递归方法class Solution &#123;public:    int sumOfLeftLeaves(TreeNode* root) &#123;        if (root == NULL)&#123;            return 0;        &#125;        int sum = 0;        if(root->left != NULL && root->left->left == NULL && root->left->right == NULL)&#123;//判断节点是否左叶子节点            sum = root->left->val;        &#125;        return sum + sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);    &#125;&#125;;</code></pre><pre class=" language-lang-c++"><code class="language-lang-c++">//非递归方法class Solution &#123;public:    int sumOfLeftLeaves(TreeNode* root) &#123;        stack<TreeNode*> st;        if (root == NULL) return 0;        st.push(root);        int result = 0;        while (!st.empty()) &#123;            TreeNode* node = st.top();            st.pop();            if (node->left != NULL && node->left->left == NULL && node->left->right == NULL) &#123;                result += node->left->val;            &#125;            if (node->right) st.push(node->right);            if (node->left) st.push(node->left);        &#125;        return result;    &#125;&#125;;</code></pre><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>树的四种遍历方法：</p><ul><li><p>前序遍历：根左右</p><pre class=" language-lang-c++"><code class="language-lang-c++">//递归方法void preorder(TreeNode* root, vector<int>& data)&#123;    if(root)&#123;        data.push_back(root->val);        preorder(root->left,data);        preorder(root->right,data);    &#125;&#125;vector<int> preorderTraversal(TreeNode* root) &#123;        vector<int> data;        if(root)&#123;            preoder(root,data);        &#125;        return data;    &#125;//非递归方法 使用栈来储存节点vector<int> preorderTraversal(TreeNode* root)&#123;    vector<int> data;    stack<TreeNode*> st;    while(root || !st.empty())&#123;        while(root)&#123;            data.push_back(root->val);            st.push(root);            root = root->left;        &#125;        root = st.top();        st.pop();        root = root->right;    &#125;    return data;&#125;</code></pre></li><li><p>中序遍历：左根右</p><pre class=" language-lang-C++"><code class="language-lang-C++">//递归方法vector<int> inorderTraversal(TreeNode* root, vector<int>& data;)&#123;    if(root)&#123;        inorderTraversal(root->left, data);        data.push_back(root->val);        inorderTraversal(root->right, data);    &#125;    return data;&#125;//非递归方法 使用栈来存储节点vector<int> inorderTraversal(TreeNode* root)&#123;    stack<TreeNode* > st;    vector<int> data;    while(root || !st.empty())&#123;        while(root)&#123;            st.push_back(root);            root = root->left;        &#125;        root = st.top();        st.pop();        data.push_back(root->val);        root = root->right    &#125;&#125;</code></pre></li><li><p>后序遍历：左右根</p><pre class=" language-lang-C++"><code class="language-lang-C++">//递归方法vector<int> postorderTraversal(TreeNode* root, vector<int>& data)&#123;        if(root)&#123;            posorder(root->left,data);            posorder(root->right,data);            data.push_back(root->val);        &#125;        return data;    &#125;//非递归方法vector<int> postorderTraversal(TreeNode* root)&#123;    stack<TreeNode*> st;    TreeNode* cur = root;    TreeNode* pre = NULL;    while(cur || !st.empty())&#123;        while(cur)&#123;            st.push(cur);            cur = cur->left;        &#125;        cur = st.top();        //判断右子树是否有节点        if(!cur->right || pre == cur->right)&#123;            st.pop();            data.push_back(cur->val);            pre = cur;            cur = NULL;        &#125;else&#123;            cur = cur->right;            pre = NULL;        &#125;    &#125;    return data;&#125;</code></pre></li><li><p>层次遍历：一层层走，BFS</p><pre class=" language-lang-C++"><code class="language-lang-C++">vector<vector<int>> levelOrder(TreeNode* root)&#123;    vector<vector<int>> data;    queue<TreeNode*> q;    if(root == NULL)        return &#123;&#125;;    else        q.push(root);    while(!q.empty())&#123;        vector<int> leveldata;        int count = q.size();        while(count--)&#123;            TreeNode* node = q.front();            q.pop();            leveldata.push_back(node->val);            if(node->left)&#123;                q.push(node->left);            &#125;            if(node->right)&#123;                q.push(node->right);            &#125;        &#125;        data.push_back(leveldata);    &#125;    return data;&#125;</code></pre></li></ul><hr><h3 id="Day03"><a href="#Day03" class="headerlink" title="Day03"></a>Day03</h3><ul><li><h4 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h4><p><a href="https://leetcode-cn.com/problems/subsets/">题目链接</a></p><p>题目描述</p><p>```python<br>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p></li></ul><p>  输入: nums = [1,2,3]<br>  输出:<br>  [<br>    [3],<br>    [1],<br>    [2],<br>    [1,2,3],<br>    [1,3],<br>    [2,3],<br>    [1,2],<br>    []<br>  ]</p><pre><code>  思路：[**转载自代码随想录**](https://leetcode-cn.com/problems/subsets/solution/78-zi-ji-hui-su-sou-suo-fa-jing-dian-ti-mu-xiang-2/)  求子集问题和 求组合组合和分割问题又不一样了， 如何把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是找树的叶子节点，而子集问题是找树的所有节点！  取子集也是，其实也是一种组合位置，因为它的集合是无序的，子集&#123;1,2&#125; 和 子集&#123;2,1&#125;是一样的。 那么既然是无序，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！  那有同学问题，什么时候，for可以从0开始，求排列问题的时候，就要从0开始，因为集合是有序的，&#123;1, 2&#125; 和&#123;2, 1&#125;是两个集合。  来看一下我总结的回溯模板来：      backtracking() &#123;          if (终止条件) &#123;              存放结果;          &#125;          for (选择：选择列表（可以想成树中节点孩子的数量）) &#123;              递归，处理节点;              backtracking();              回溯，撤销处理结果          &#125;      &#125;  首先是终止条件，终止条件，就是startIndex已经大于数组的长度了，就是终止了，代码如下:  ```c++  if (startIndex &gt;= nums.size()) &#123;      return;  &#125;</code></pre><p>  但是，要明确的是，求取子集问题，其实没有必要加终止条件，因为子集就是要遍历整个一棵树，不需要任何剪枝！</p><p>  大家一会看到下面整体代码的时候就知道了。</p><p>  然后就是看如何写for循环，因为求子集也是无序的，所以for循环要从startIndex开始！</p><p>  代码如下：</p><pre class=" language-lang-C++"><code class="language-lang-C++">  for (int i = startIndex; i < nums.size(); i++) &#123;  &#125;</code></pre><p>  接下来就是递归与回溯，定一个vector<int> path，用来收集子集的元素，在回溯的时候还要弹出，backtracking每次调用自己的时候，记着要从i+1 开始，代码如下：</int></p><pre class=" language-lang-C++"><code class="language-lang-C++">  for (int i = startIndex; i < nums.size(); i++) &#123;      path.push_back(nums[i]);      backtracking(nums, i + 1);      path.pop_back();  &#125;</code></pre><p>  重点代码分析完之后，整体代码如下：</p><p>  可以发现我在backtracking里并没有写终止条件，因为本来我们就要遍历整颗树。</p><p>  有的同学可能担心会不会无限递归？ 并不会，因为每次递归的下一层就是从i+1开始的。</p><pre class=" language-lang-c++"><code class="language-lang-c++">  class Solution &#123;  private:      vector<vector<int>> result;      vector<int> path;      void backtracking(vector<int>& nums, int startIndex) &#123;          result.push_back(path);          for (int i = startIndex; i < nums.size(); i++) &#123;              path.push_back(nums[i]);              backtracking(nums, i + 1);              path.pop_back();          &#125;      &#125;  public:      vector<vector<int>> subsets(vector<int>& nums) &#123;          result.clear();          path.clear();          backtracking(nums, 0);          return result;      &#125;  &#125;;</code></pre><hr><p>  <a href="https://leetcode-cn.com/problems/subsets-ii/">题目链接</a></p><p>  题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">  给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。  说明：解集不能包含重复的子集。  示例:  输入: [1,2,2]  输出:  [    [2],    [1],    [1,2,2],    [2,2],    [1,2],    []  ]</code></pre><p>  题目思路：</p><p>  和上一题思路类似，只不过需要一个数组来记录该元素是否是重复元素。</p><pre class=" language-lang-c++"><code class="language-lang-c++">  class Solution &#123;  private:      void backtracking(vector<int>& nums, vector<vector<int>>& result, vector<int>& vec, int startIndex,  vector<bool>& used) &#123;          result.push_back(vec);          for (int i = startIndex; i < nums.size(); i++) &#123;              // used[i - 1] == true，说明同一树支candidates[i - 1]使用过               // used[i - 1] == false，说明同一树层candidates[i - 1]使用过              // 而我们要对同一树层使用过的元素进行跳过              if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) &#123;                   continue;              &#125;              vec.push_back(nums[i]);              used[i] = true;              backtracking(nums, result, vec, i + 1, used);              used[i] = false;              vec.pop_back();          &#125;      &#125;  public:      vector<vector<int>> subsetsWithDup(vector<int>& nums) &#123;          vector<bool> used(nums.size(), false);          vector<vector<int>> result;          vector<int> vec;          sort(nums.begin(), nums.end());          backtracking(nums, result, vec, 0, used);          return result;      &#125;  &#125;;</code></pre><hr><h3 id="Day04"><a href="#Day04" class="headerlink" title="Day04"></a>Day04</h3><h4 id="二叉搜索树转化为累加数"><a href="#二叉搜索树转化为累加数" class="headerlink" title="二叉搜索树转化为累加数"></a>二叉搜索树转化为累加数</h4><p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。例如：输入: 原始二叉搜索树:              5            /   \           2     13输出: 转换为累加树:             18            /   \          20     13</code></pre><p>思路：</p><p>相当于遍历树，只不过遍历的顺序是右根左。</p><pre class=" language-lang-c++"><code class="language-lang-c++">class Solution &#123;public:    //非递归    TreeNode* convertBST(TreeNode* root) &#123;        int sum = 0;        stack<TreeNode*> st;        TreeNode* node = root;//保留root，最后方便返回        while(node || !st.empty())&#123;            while(node)&#123;                t.push(node);                node = node->right;//一直找到最小的数            &#125;              node = st.top();            st.pop();            sum += node->val;            node->val = sum;            //左子树            node = node->left;        &#125;        return root;    &#125;    //递归    TreeNode* convertBST(TreeNod* root)&#123;        int sum = 0;        while(root)&#123;            convertBST(root->right);            sum += root->val;            root->val = sum;            convertBST(root->left);        &#125;        return rootl;    &#125;&#125;;</code></pre><hr><h4 id="从前序和中序遍历构造二叉树"><a href="#从前序和中序遍历构造二叉树" class="headerlink" title="从前序和中序遍历构造二叉树"></a>从前序和中序遍历构造二叉树</h4><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">题目链接</a></p><p>题目描述：</p><pre class=" language-lang-python"><code class="language-lang-python">根据一棵树的前序遍历与中序遍历构造二叉树。注意:你可以假设树中没有重复的元素。例如，给出前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树：    3   / \  9  20    /  \   15   7</code></pre><p>思路：</p><p>前序遍历：根左右[根节点，左子树，右子树]</p><p>中序遍历：左根右[左子树，根节点，右子树]</p><p>从中序遍历中找到根节点，就可以知道左子树和右子树，之后递归构造左右字数，在接到根节点的左右位置。</p><pre class=" language-lang-c++"><code class="language-lang-c++">//递归方法class Solution &#123;public:    TreeNode* creat(vector<int>& preorder, vector<int>& inorder, int preL, int preR, int inL, int inR)&#123;        //判断是否还需要构造        if(preL > preR)&#123;            return NULL;        &#125;        //构建根节点        TreeNode* root = new TreeNode;        root->val = preorder[preL];        int k;//找出中序遍历的根节点位置        for(k = inL; k <= inR; k++)&#123;            if(preorder[preL] == inorder[k])                break;        &#125;        int numLeft = k - inL;//左子树的节点个数        //左子树的先序区间[preL+1, preL+numLeft], 中序区间是[inL, k-1]        //返回左子树的根节点地址，赋值给root的左指针        root->left = creat(preorder, inorder, preL+1, preL+numLeft, inL, k-1);        //右子树的线序区间[preL+numLeft+1, preR], 中序区间[k+1, inR]        //返回右子树的根节点地址，赋值给root的右指针        root->right = creat(preorder, inorder, preL+numLeft+1, preR, k+1, inR);        return root;    &#125;    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) &#123;        int n = preorder.size();        return creat(preorder, inorder, 0, n - 1, 0, n - 1);    &#125;&#125;;</code></pre><hr><h3 id="Day05"><a href="#Day05" class="headerlink" title="Day05"></a>Day05</h3><h4 id="从中序与后续遍历构造二叉树"><a href="#从中序与后续遍历构造二叉树" class="headerlink" title="从中序与后续遍历构造二叉树"></a>从中序与后续遍历构造二叉树</h4><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">根据一棵树的中序遍历与后序遍历构造二叉树。注意:你可以假设树中没有重复的元素。例如，给出中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3]返回如下的二叉树：    3   / \  9  20    /  \   15   7</code></pre><p>思路：</p><p>因为后序遍历是左右根，中序遍历是左根右，因此根据根节点划分左右子树，从而使用递归方法来构造二叉树。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    TreeNode* creat(vector<int>& inorder, vector<int>& postorder, int inL, int inR, int postL, int postR)&#123;        //递归条件        if(postL > postR)&#123;            return NULL;        &#125;        TreeNode* root = new TreeNode;        root->val = postorder[postR];        int k;//找中序遍历的根节点        for(k = inL; k <= inR; k++)&#123;            if(postorder[postR] == inorder[k])&#123;                break;            &#125;        &#125;        int numLeft = k - inL;//左子树个数        //左子树的中序区间[inL, k-1], 后序区间[postL, postL + numLeft - 1]        root->left = creat(inorder, postorder, inL, k-1, postL, postL+numLeft-1);        //右子树的中序区间[k+1, inR], 后序区间[postL+numLeft, postR-1]        root->right = creat(inorder, postorder, k+1, inR, postL+numLeft, postR-1);        return root;    &#125;    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) &#123;        int size = inorder.size();        TreeNode* root = creat(inorder, postorder, 0, size-1, 0, size - 1);        return root;    &#125;&#125;;</code></pre><hr><h4 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title=" 监控二叉树"></a><font color="#660000"> 监控二叉树</font></h4><p><a href="https://leetcode-cn.com/problems/binary-tree-cameras/">题目链接</a></p><p>题目描述</p><pre><code>给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。计算监控树的所有节点所需的最小摄像头数量。示例 1：输入：[0,0,null,0,0]输出：1解释：如图所示，一台摄像头足以监控所有节点。示例 2：输入：[0,0,null,0,null,0,null,null,0]输出：2解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。提示：给定树的节点数的范围是 [1, 1000]。每个节点的值都是 0。</code></pre><p>思路：</p><p>三种状态：0:待覆盖 1:已覆盖 2:已安装相机</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    //0:待覆盖    //1:已覆盖    //2:已安装相机    int res;    int minCameraCover(TreeNode* root) &#123;        res=0;        //如果root仍为覆盖，给root加相机        if(dfs(root)==0)            res++;        return res;    &#125;    int dfs(TreeNode* r)&#123;        if(r==NULL)            return 1;        int left=dfs(r->left);        int right=dfs(r->right);        //下面的节点没有把left或者right覆盖，只能靠r了        if(left==0||right==0)&#123;            res++;            return 2;        &#125;        //left和right都已经被覆盖了，但是没有安装相机，所以r是待覆盖的        else if(left==1&&right==1)&#123;            return 0;        &#125;        //left和right至少有一个安装相机了        else if(left+right>=3)&#123;            return 1;        &#125;        return -1;    &#125;&#125;;</code></pre><hr><h3 id="Day06"><a href="#Day06" class="headerlink" title="Day06"></a>Day06</h3><h4 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h4><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">题目链接</a></p><p>题目描述：</p><pre class=" language-lang-python"><code class="language-lang-python">给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。示例 1:输入:     Tree 1                     Tree 2                            1                         2                                      / \                       / \                                    3   2                     1   3                               /                           \   \                            5                             4   7                  输出: 合并后的树:         3        / \       4   5      / \   \      5   4   7</code></pre><p>思路：</p><p>使用层序遍历法，然后将每个节点合并到新的节点。</p><pre class=" language-lang-C++"><code class="language-lang-C++">//BFSclass Solution&#123;public:    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2)&#123;        if (t1 == nullptr)            return t2;        if (t2 == nullptr)            return t1;        TreeNode* merged = new TreeNode(t1->val + t2->val);        queue<TreeNode*> q;        queue<TreeNode*> q1;        queue<TreeNOde*> q2;        q.push(merged);        q1.push(t1);        q2.push(t2);        while(!q1.empty() && !q2.empty())&#123;            TreeNode* node = q.front();            TreeNode* node1 = q1.front();            TreeNode* node2 = q2.front();            q.pop();            q1.pop();            q2.pop();            auto left1 = node1->left, left2 = node2->left, right1 = node1->right, right2 = node2->right;            if (left1 != nullptr || left2 != nullptr) &#123;                if (left1 != nullptr && left2 != nullptr) &#123;                    TreeNode* left = new TreeNode(left1->val + left2->val);                    node->left = left;                    q.push(left);                    q1.push(left1);                    q2.push(left2);                &#125; else if (left1 != nullptr) &#123;                    node->left = left1;                &#125; else if (left2 != nullptr) &#123;                    node->left = left2;                &#125;            &#125;            if (right1 != nullptr || right2 != nullptr) &#123;                if (right1 != nullptr && right2 != nullptr) &#123;                    TreeNode* right = new TreeNode(right1->val + right2->val);                    node->right = right;                    q.push(right);                    q1.push(right1);                    q2.push(right2);                &#125; else if (right1 != nullptr) &#123;                    node->right = right1;                &#125; else &#123;                    node->right = right2;                &#125;            &#125;        &#125;        return merged;    &#125;&#125;;//递归方法(DFS)class Solution &#123;public:    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123;        if( t1 == NULL) return t2;        if( t2 == NULL) return t1;        t1->val += t2->val;//t2 合并到 t1 上        //分别合并左右子节点        t1->left = mergeTrees(t1->left,t2->left);        t1->right = mergeTrees(t1->right,t2->right);        return t1;    &#125;&#125;;</code></pre><hr><h3 id="Day07"><a href="#Day07" class="headerlink" title="Day07"></a>Day07</h3><h4 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h4><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。示例 1:输入: 1->1->2输出: 1->2示例 2:输入: 1->1->2->3->3输出: 1->2->3</code></pre><p>思路:</p><p>因为是排序链表，因此只需要前后指针的比较，如果相同，那么删除后面的指针。(双指针)</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if(!head || !head->next)&#123;            return head;        &#125;        ListNode* prev = head;        ListNode* curr = head->next;        while(prev && prev->next)&#123;            if(curr->val == prev->val)&#123;                prev->next = curr->next;                curr = curr->next;            &#125;            else&#123;                prev = prev->next;                curr = curr->next;            &#125;        &#125;        return head;    &#125;&#125;;</code></pre><hr><h4 id="删除排序链表中的重复元素II"><a href="#删除排序链表中的重复元素II" class="headerlink" title="删除排序链表中的重复元素II"></a>删除排序链表中的重复元素II</h4><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。示例 1:输入: 1->2->3->3->4->4->5输出: 1->2->5示例 2:输入: 1->1->1->2->3输出: 2->3</code></pre><p>思路：</p><p>通过构造dummyhead来保护头节点，之后遍历链表的节点，每次从curr开始，使用while判断curr节点之后是否重复，之后使用curr的前一节点指向最后curr的后一节点。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if(!head || !head->next)            return head;        ListNode* dummyhead = new ListNode();        dummyhead->next = head;        ListNode* prev = dummyhead;        while(prev && prev->next)&#123;            ListNode* curr = prev->next;            if(!curr->next || curr->next->val != curr->val)                prev = curr;            else&#123;                while(curr->next && curr->val == curr->next->val)                    curr = curr->next;                prev->next = curr->next;            &#125;        &#125;        return dummyhead->next;    &#125;&#125;;</code></pre><hr><h3 id="Day08"><a href="#Day08" class="headerlink" title="Day08"></a>Day08</h3><h4 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h4><p><a href="https://leetcode-cn.com/problems/path-sum/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。说明: 叶子节点是指没有子节点的节点。示例: 给定如下二叉树，以及目标和 sum = 22，              5             / \            4   8           /   / \          11  13  4         /  \      \        7    2      1返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。</code></pre><p>思路:</p><p>关键点：总和等于sum，并且最后一个节点是叶子节点。</p><p>第一种：使用层次遍历的方法，记录每个节点的位置和该节点与节点上面的和，并判断是否满足上面俩个条件。BFS</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    bool hasPathSum(TreeNode* root, int sum)&#123;        if(!root)&#123;            return false;        &#125;        queue<TreeNode*> que_node;        queue<int> que_val;        que_node.push(root);        que_val.push(root->val);        while(!que_node.empty())&#123;            TreeNode* node = que_node.front();            int node_val = que_val.front();            que_node.pop();            que_val.pop();            if(!node->left && !node->right)&#123;                if(node_val == sum)                    return true;                else                    continue;            &#125;            if(node->left)&#123;                que_node.push(node->left);                que_val.push(node->left->val + node_val);            &#125;            if(node->right)&#123;                que_node.push(node->right);                que_val.push(node->right->val + node_val);            &#125;        &#125;        return false;    &#125;&#125;;</code></pre><p>第二种：递归DFS</p><pre class=" language-lang-C++"><code class="language-lang-C++">if(!root)&#123;            return false;        &#125;        if(!root->left && !root->right)&#123;            return sum == root->val;        &#125;        return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);    &#125;</code></pre><hr><h4 id="路径总和II"><a href="#路径总和II" class="headerlink" title="路径总和II"></a>路径总和II</h4><p><a href="https://leetcode-cn.com/problems/path-sum-ii/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。说明: 叶子节点是指没有子节点的节点。示例:给定如下二叉树，以及目标和 sum = 22，              5             / \            4   8           /   / \          11  13  4         /  \    / \        7    2  5   1返回:[   [5,4,11,2],   [5,8,4,5]]</code></pre><p>思路：</p><p>参照上题递归思路，使用vector来进行存储</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    vector<vector<int>> res;    vector<int> path;    void dfs(TreeNode* root, int sum)&#123;        if(!root)            return;        path.emplace_back(root->val);        sum -= root->val;        if(!root->left && !root->right && sum == 0)&#123;            res.emplace_back(path);        &#125;        dfs(root->left, sum);        dfs(root->right, sum);        path.pop_back();    &#125;    vector<vector<int>> pathSum(TreeNode* root, int sum) &#123;        dfs(root, sum);        return res;    &#125;&#125;;</code></pre><p>参照上题的BFS，设置一个hash表格，存储该节点与父节点的关系。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    vector<vector<int>> res;    unordered_map<TreeNode*, TreeNode*> parent;    void getPath(TreeNode* node)&#123;        vector<int> tmp;        while(node)&#123;            tmp.emplace_back(node->val);            node = parent[node];        &#125;        reverse(tmp.begin(), tmp.end());        res.emplace_back(tmp);    &#125;    vector<vector<int>> pathSum(TreeNode* root, int sum)&#123;        if(!root)&#123;            return res;        &#125;        queue<TreeNode* > que_node;        queue<int> que_val;        que_node.push(root);        que_val.push(root->val);        while(!que_node.empty())&#123;            TreeNode* node = que_node.front();            int node_val = que_val.front();            que_node.pop();            que_val.pop();            if(!node->left && !node->right)&#123;                if(node_val == sum)                    getPath(node);            &#125;else&#123;                if(node->left)&#123;                    parent[node->left] = node;                    que_node.push(node->left);                    que_val.push(node_val + node->left->val);                &#125;                if(node->right)&#123;                    parent[node->right] = node;                    que_node.push(node->right);                    que_val.push(node_val + node->right->val);                &#125;            &#125;        &#125;        return res;    &#125;&#125;;</code></pre><hr><h3 id="Day09"><a href="#Day09" class="headerlink" title="Day09"></a>Day09</h3><h4 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h4><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]示例 1:输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。示例 2:输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p>思路:</p><p>用vector来存储每个节点到根节点的路径，所以最后寻找祖先节点，就是俩个vector相同的情况。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    vector<TreeNode*> getPath(TreeNode* root, TreeNode* target)&#123;        vector<TreeNode*> path;        TreeNode* node = root;        while(node != target)&#123;//寻找目标节点            path.push_back(node);//存储父节点            if(target->val < node->val)&#123;                node = node->left;            &#125;else&#123;                node = node->right;            &#125;        &#125;        path.push_back(node);        return path;    &#125;    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        vector<TreeNode*> path_p = getPath(root, p);        vector<TreeNode*> path_q = getPath(root, q);        TreeNode* ancestor;        for(int i = 0; i < path_q.size() && i < path_p.size(); i++)&#123;            if(path_q[i] == path_p[i])&#123;                ancestor = path_q[i];            &#125;else&#123;                break;            &#125;        &#125;        return ancestor;    &#125;&#125;;</code></pre><p>由于是二叉搜素树，因此判断该节点是否是公共节点可以使用如下代码：</p><pre class=" language-lang-C++"><code class="language-lang-C++">if(p->val <= cur->val && cur->val <= q->val)</code></pre><pre class=" language-lang-C++"><code class="language-lang-C++">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)&#123;        if(root->val > p->val && root->val > q->val)&#123;            return lowestCommonAncestor(root->left, p, q);        &#125;else if(root->val < p->val && root->val < q->val)&#123;            return lowestCommonAncestor(root->right, p, q);        &#125;else&#123;            return root;        &#125;    &#125;</code></pre><hr><h3 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h3><h4 id="填充每个节点的下一个右侧节点指针II"><a href="#填充每个节点的下一个右侧节点指针II" class="headerlink" title="填充每个节点的下一个右侧节点指针II"></a>填充每个节点的下一个右侧节点指针II</h4><p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个二叉树struct Node &#123;  int val;  Node *left;  Node *right;  Node *next;&#125;填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。进阶：你只能使用常量级额外空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。示例：输入：root = [1,2,3,4,5,null,7]输出：[1,#,2,3,#,4,5,7,#]解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</code></pre><p>思路：</p><p>使用层次遍历，每次从右节点开始进入，然后将队列中的数移除指向下一个。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    Node* connect(Node* root)&#123;        if(!root)            return NULL;        queue<Node*> q;        q.push(root);        while(!q.empty())&#123;            int n = q.size();            while(n)&#123;                n = n - 1;                Node* f = q.front();                q.pop();                if(f->left)&#123;                    q.push(f->left);                &#125;                if(f->right)&#123;                    q.push(f->right);                &#125;                if(n)&#123;                    f->next = q.front();                &#125;else&#123;                    f->next = NULL;                &#125;            &#125;        &#125;        return root;    &#125;&#125;</code></pre><hr><h4 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h4><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">题目链接</a></p><p>题目描述：</p><pre class=" language-lang-python"><code class="language-lang-python">输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如，给出前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树：    3   / \  9  20    /  \   15   7</code></pre><p>思路:</p><p>具体参考Day04。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    TreeNode* creat(vector<int>& preorder, vector<int>& inorder, int preL, int preR, int inL, int inR)&#123;        //判断是否还需要构造        if(preL > preR)&#123;            return NULL;        &#125;        //构建根节点        TreeNode* root = new TreeNode;        root->val = preorder[preL];        int k;//找出中序遍历的根节点位置        for(k = inL; k <= inR; k++)&#123;            if(preorder[preL] == inorder[k])                break;        &#125;        int numLeft = k - inL;//左子树的节点个数        //左子树的先序区间[preL+1, preL+numLeft], 中序区间是[inL, k-1]        //返回左子树的根节点地址，赋值给root的左指针        root->left = creat(preorder, inorder, preL+1, preL+numLeft, inL, k-1);        //右子树的线序区间[preL+numLeft+1, preR], 中序区间[k+1, inR]        //返回右子树的根节点地址，赋值给root的右指针        root->right = creat(preorder, inorder, preL+numLeft+1, preR, k+1, inR);        return root;    &#125;    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) &#123;        int n = preorder.size();        return creat(preorder, inorder, 0, n - 1, 0, n - 1);    &#125;&#125;;</code></pre><hr><h3 id="Day11"><a href="#Day11" class="headerlink" title="Day11"></a>Day11</h3><h4 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h4><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">题目链接</a></p><p>复习题</p><p>非递归方法，内存消耗比较小</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    vector<int> res;    vector<int> postorderTraversal(TreeNode* root) &#123;        if(!root)&#123;            return &#123;&#125;;        &#125;        stack<TreeNode*> st;        TreeNode* cur = root;        TreeNode* pre = NULL;        while(cur || !st.empty())&#123;            while(cur)&#123;                st.push(cur);                cur = cur->left;            &#125;            cur = st.top();            if( !cur->right || pre == cur->right)&#123;                st.pop();                res.push_back(cur->val);                pre = cur;                cur = NULL;            &#125;else&#123;                cur = cur->right;                pre = NULL;            &#125;        &#125;        return res;    &#125;&#125;;</code></pre><hr><h4 id="验证二叉搜素树"><a href="#验证二叉搜素树" class="headerlink" title="验证二叉搜素树"></a>验证二叉搜素树</h4><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-c++"><code class="language-lang-c++">给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。示例 1:输入:    2   / \  1   3输出: true示例 2:输入:    5   / \  1   4     / \    3   6输出: false解释: 输入为: [5,1,4,null,null,3,6]。     根节点的值为 5 ，但是其右子节点值为 4 。</code></pre><p>思路：</p><p>采用中序遍历的方法，判断下一个节点是否大于前一个节点，如果不是则是错误的。</p><pre class=" language-lang-C++"><code class="language-lang-C++">bool isValidBST(TreeNode* root)&#123;    stack<TreeNode*> st;    long long inorder = (long long)INT_MIN - 1;    while(!st.empty() || root)&#123;        while(root)&#123;            st.push(root);            root = root->left;        &#125;        root = st.top();        st.pop();        if(root->val <= inorder)&#123;            return false;        &#125;        inorder = root->val;        root = root->right;    &#125;&#125;</code></pre><hr><h3 id="Day12"><a href="#Day12" class="headerlink" title="Day12"></a>Day12</h3><h4 id="宝石与石头"><a href="#宝石与石头" class="headerlink" title="宝石与石头"></a>宝石与石头</h4><p><a href="https://leetcode-cn.com/problems/jewels-and-stones/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此"a"和"A"是不同类型的石头。示例 1:输入: J = "aA", S = "aAAbbbb"输出: 3示例 2:输入: J = "z", S = "ZZ"输出: 0注意:S 和 J 最多含有50个字母。 J 中的字符不重复。</code></pre><p>思路：</p><p>设置一个map用来存放宝石类型，然后遍历你拥有的石头，如果有那么就增加。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    int numJewelsInStones(string J, string S)&#123;        unordered_map<char, int> jewels;        int count = 0;        for(int i = 0; i < J.size(); ++i)&#123;            jewels[J[i]] = 1;        &#125;        for(int i = 0; i < S.size(); ++i)&#123;            if(jewels.find(S[i]) != jewels.end())&#123;                count++;            &#125;        &#125;        return count;    &#125;&#125;</code></pre><p>执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</p><p>内存消耗：6.4 MB, 在所有 C++ 提交中击败了24.38%的用户</p><p>典型的用空间换时间，使用了unordered_map之后时间大大的减少，但是却使用了大量的内存空间。</p><p><strong>map与unordered_map区别</strong>：</p><p>map是使用红黑树来实现的，并且map内部所有数据在任何时候都是有序的</p><p>unordered_map是基于hash表，数据插入和查找基本都是常数时间， 但是消耗的内存较多。</p><p><strong>Hash表</strong>：</p><p>Hash Table是根据key-value对应关系而进行直接访问的数据结构。记录的存储位置=f(关键字)</p><hr><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">反转一个单链表。示例:输入: 1->2->3->4->5->NULL输出: 5->4->3->2->1->NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</code></pre><p>思路：</p><p>双指针，一个prev，一个cur，并且使用内存来存储next节点，将cur的next指向prev即可。</p><pre class=" language-lang-C++"><code class="language-lang-C++">//迭代class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode* prev = NULL;        ListNode* cur = head;        while(cur)&#123;            ListNode* next = cur->next;            cur->next = prev;            prev = cur;            cur = next;        &#125;        return prev;    &#125;    ListNode* reverseList(ListNode* head)&#123;        if(head == NULL || head->next == NULL)&#123;            return head;        &#125;        ListNode* p = reverseList(head->next);        head->next->next = head;        head->next = NULL;        return p;    &#125;&#125;;</code></pre><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">递归PPT解释</a></p><hr><h3 id="Day13"><a href="#Day13" class="headerlink" title="Day13"></a>Day13</h3><h4 id="俩数之和"><a href="#俩数之和" class="headerlink" title="俩数之和"></a>俩数之和</h4><p><a href="https://leetcode-cn.com/problems/two-sum/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><p>思路：</p><pre class=" language-lang-C++"><code class="language-lang-C++">//暴力解法class Solution &#123;public:    vector<int> twoSum(vector<int>& nums, int target) &#123;        vector<int> res;        for(int i = 0; i < nums.size(); ++i)&#123;            for(int j = i + 1; j < nums.size(); ++j)&#123;                if(nums[i] + nums[j] == target)&#123;                    res.push_back(i);                    res.push_back(j);                &#125;            &#125;        &#125;        return res;    &#125;&#125;;</code></pre><p>思路简单，但是耗时很长。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    vector<int> twoSum(vector<int>& nums, int target) &#123;        unordered_map<int, int> hashtable;        for (int i = 0; i < nums.size(); ++i) &#123;            auto it = hashtable.find(target - nums[i]);            if (it != hashtable.end()) &#123;                return &#123;it->second, i&#125;;            &#125;            hashtable[nums[i]] = i;        &#125;        return &#123;&#125;;    &#125;&#125;;</code></pre><p>使用hashtable可以大大的减少时间，但是使用空间增加了。</p><hr><h4 id="合并俩个排序的链表"><a href="#合并俩个排序的链表" class="headerlink" title="合并俩个排序的链表"></a>合并俩个排序的链表</h4><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。示例1：输入：1->2->4, 1->3->4输出：1->1->2->3->4->4</code></pre><p>思路：</p><p>迭代方法，构建一个新的节点，用来存放合并后的链表，比较l1与l2的值，将小的值放入新的链表，直到其中一个链表遍历结束，之后将剩余的链表值放入。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        ListNode* dummy = new ListNode;        ListNode* cur = dummy;        while(l1 && l2)&#123;            if(l1->val <= l2->val)&#123;                cur->next = l1;                l1 = l1->next;            &#125;else&#123;                cur->next = l2;                l2 = l2->next;            &#125;            cur = cur->next;        &#125;        if(l1)&#123;            cur->next = l1;        &#125;        if(l2)&#123;            cur->next = l2;        &#125;        return dummy->next;    &#125;&#125;;</code></pre><p>递归方法：</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        if(!l1)            return l2;        if(!l2)            return l1;        if(l1->val <= l2->val)&#123;            l1->next = mergeTwoLists(l1->next, l2);            return l1;        &#125;else&#123;            l2->next = mergeTwoLists(l1, l2->next);            return l2;        &#125;    &#125;&#125;;</code></pre><hr><h3 id="Day14"><a href="#Day14" class="headerlink" title="Day14"></a>Day14</h3><h4 id="俩数相加"><a href="#俩数相加" class="headerlink" title="俩数相加"></a>俩数相加</h4><p><a href="https://leetcode-cn.com/problems/add-two-numbers/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。示例：输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)输出：7 -> 0 -> 8原因：342 + 465 = 807</code></pre><p>思路：</p><p>用一位数来表示位数相加是否大于10</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)&#123;        ListNode* head = new ListNode;        ListNode* h = head;//移动指针        int sum = 0;        bool plus = false;//进位标志        while(l1 || l2)&#123;            sum = 0;            if(l1)&#123;                sum += l1->val;                l1 = l1->next;            &#125;            if(l2)&#123;                sum += l2->val;                l2 = l2->next;            &#125;            if(plus)                sum++;            h->next = new ListNode(sum%10);            h = h->next;            plus = (sum >= 10)? true: false;        &#125;        if(plus)&#123;            h->next = new ListNode(1);        &#125;        return head->next;    &#125;&#125;;</code></pre><hr><h4 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h4><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]示例 1:输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。示例 2:输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p>思路：</p><p>存储每个节点的parent位置，并且存储要访问节点的前一个节点是否被访问过，即使用俩个hash表来进行存储。</p><pre class=" language-lang-C++"><code class="language-lang-C++">//迭代方法class Solution&#123;public:    unordered_map<int, TreeNode* > fa;    unordered_map<int, bool> vis;    void dfs(TreeNode* root)&#123;        if(root->left)&#123;            fa[root->left->val] = root;            dfs(root->left);        &#125;        if(root->right)&#123;            fa[root->right->val] = root;            dfs(root->right);        &#125;    &#125;    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)&#123;        fa[root->val] = nullptr;        dfs(root);        while(p)&#123;            vis[p->val] = true;            p = fa[p->val];        &#125;        while(q)&#123;            if(vis[q->val])                return q;            q = fa[q->val];        &#125;        return nullptr;    &#125;&#125;//递归方法(不懂)class Solution&#123;public:    TreeNode* ans;    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q)&#123;        if(!root)            return false;        bool lson = dfs(root->left, p, q);        bool rson = dfs(root->right, p, q);        if((lson && rson) || ((root->val == p->val || root->val == q->val) && (lson || rson)))&#123;            ans = root;        &#125;        return lson || rson || (root->val == p->val || root->val == q->val);    &#125;    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        dfs(root, p, q);        return ans;    &#125;&#125;</code></pre><hr><h3 id="Day15"><a href="#Day15" class="headerlink" title="Day15"></a>Day15</h3><h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p><a href="https://leetcode-cn.com/problems/3sum/">题目链接</a></p><p>题目描述：</p><pre class=" language-lang-python"><code class="language-lang-python">给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。示例：给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[  [-1, 0, 1],  [-1, -1, 2]]</code></pre><p>思路：</p><p>最容易想到的是暴力解法，即将循环三遍，找出相加为0的数组。但是该时间复杂度比较高是$O(n^3)$,从俩数相加的方法找到思路，我们可以缩短时间复杂度，使用双指针的方法，即将第二个和第三个数放在一起，使用双指针。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    vector<vector<int>> threeSum(vector<int>& nums)&#123;        int n = nums.size();        sort(nums.begin(), nums.end());        vector<vector<int>> ans;        for(int first = 0; first < n; ++first)&#123;            //需要和上次不同            if(first > 0 && nums[first] == nums[first - 1])&#123;                continue;            &#125;            int third = n - 1;            int target = -nums[first];            //枚举第二个数            for(int second = first + 1; second < n; ++ second)&#123;                if(second > first + 1 && nums[second] == nums[second - 1])                    continue;                while(second < third && nums[second] + nums[third] > target)&#123;                    --third;                &#125;                if(second == third)                    break;                if(nums[second] + nums[third] == target)                    ans.push_back(&#123;nums[first], nums[second], nums[third]&#125;);            &#125;        &#125;        return ans;    &#125;&#125;;</code></pre><hr><h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><p><a href="https://leetcode-cn.com/problems/4sum/">题目链接</a></p><p>题目描述:</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意：答案中不可以包含重复的四元组。示例：给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[  [-1,  0, 0, 1],  [-2, -1, 1, 2],  [-2,  0, 0, 2]]</code></pre><p>思路：</p><p>与三数之和类似，使用双指针的解法，只不过多了一层嵌套。其中的一些剪枝条件：</p><p>在确定第一个数之后，如果 $\textit{nums}[i]+\textit{nums}[i+1]+\textit{nums}[i+2]+\textit{nums}[i+3]&gt;\textit{target}$，说明此时剩下的三个数无论取什么值，四数之和一定大于 $\textit{target}$，因此退出第一重循环；<br>在确定第一个数之后，如果 $\textit{nums}[i]+\textit{nums}[n-3]+\textit{nums}[n-2]+\textit{nums}[n-1]&lt;\textit{target}$，说明此时剩下的三个数无论取什么值，四数之和一定小于$ \textit{target}$，因此第一重循环直接进入下一轮，枚举$ \textit{nums}[i+1]$；<br>在确定前两个数之后，如果$ \textit{nums}[i]+\textit{nums}[j]+\textit{nums}[j+1]+\textit{nums}[j+2]&gt;\textit{target}$，说明此时剩下的两个数无论取什么值，四数之和一定大于$\textit{target}$，因此退出第二重循环；<br>在确定前两个数之后，如果 $\textit{nums}[i]+\textit{nums}[j]+\textit{nums}[n-2]+\textit{nums}[n-1]&lt;\textit{target}$，说明此时剩下的两个数无论取什么值，四数之和一定小于$ \textit{target}$，因此第二重循环直接进入下一轮，枚举 $\textit{nums}[j+1]$。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    vector<vector<int>> fourSum(vector<int>& nums, int target)&#123;        vector<vector<int>> res;        if(nums.size() < 4)            return res;        sort(nums.begin(), nums.end());        int length = nums.size();        for(int i = 0; i < length - 3; i++)&#123;            if(i > 0 && nums[i] == nums[i-1])&#123;                continue;            &#125;            if(nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target)&#123;                break;            &#125;            if(nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target)&#123;                continue;            &#125;            for(int j = i + 1; j < length - 2; j++)&#123;                if(j > i + 1 && nums[j] == nums[j - 1])&#123;                    continue;                &#125;                if(nums[i] + nums[j] + nums[j+1] + nums[j+2]>target)                    break                if (nums[i] + nums[j] + nums[length - 2] + nums[length - 1] < target) &#123;                    continue;                &#125;                int left = j + 1, right = length - 1;                while (left < right) &#123;                    int sum = nums[i] + nums[j] + nums[left] + nums[right];                    if (sum == target) &#123;                        res.push_back(&#123;nums[i], nums[j], nums[left], nums[right]&#125;);                        while (left < right && nums[left] == nums[left + 1]) &#123;                            left++;                        &#125;                        left++;                        while (left < right && nums[right] == nums[right - 1]) &#123;                            right--;                        &#125;                        right--;                    &#125; else if (sum < target) &#123;                        left++;                    &#125; else &#123;                        right--;                    &#125;                &#125;            &#125;        &#125;        return res;    &#125;&#125;;</code></pre><hr><h3 id="Day16"><a href="#Day16" class="headerlink" title="Day16"></a>Day16</h3><h4 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h4><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">题目链接</a></p><p>题目描述：</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。示例:输入: [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</code></pre><p>思路:</p><p>使用动态规划的思想来进行求解，动态规划的思路关键是列出状态转移方程，对于该题来说我们说着dp[i]表示以A[i]结尾的最大序列和，状态转移方程则为: dp[i] = max(A[i], dp[i-1]+A[i])</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    int maxSubArray(vector<int>& nums) &#123;        vector<int> dp(nums.size());        dp[0] = nums[0];        for(int i = 1; i < nums.size(); i++)&#123;            dp[i] = max(nums[i], dp[i-1]+nums[i]);        &#125;        int k = 0;        for(int i = 0; i < nums.size(); i++)&#123;            if(dp[i] > dp[k])&#123;                k = i;            &#125;        &#125;        return dp[k];    &#125;&#125;;</code></pre><hr><h4 id="最长上升子序列-LIS"><a href="#最长上升子序列-LIS" class="headerlink" title="最长上升子序列(LIS)"></a>最长上升子序列(LIS)</h4><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个无序的整数数组，找到其中最长上升子序列的长度。示例:输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。说明:可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。你算法的时间复杂度应该为 O(n2)</code></pre><p>思路:</p><p>使用动态规划来进行求解，状态量dp[i]表示的是当前这个数的最长上升长度。状态转移方程为$dp[i] = max(1, dp[j] + 1),(j=1,…,n-1 \&amp; A[j] &lt; A[i])$</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    int lengthOfLIS(vector<int>& nums) &#123;        vector<int> dp(nums.size());        if(nums.empty())&#123;            return 0;        &#125;        int ans = -1;        for(int i = 0; i < nums.size(); i++)&#123;            dp[i] = 1;            for(int j = 0; j < i; j++)&#123;                if(nums[j] < nums[i] && dp[j] + 1 > dp[i])                    dp[i] = dp[j] + 1;            &#125;            ans = max(ans, dp[i]);        &#125;        return ans;    &#125;&#125;;</code></pre><hr><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>DP最重要的是找出状态量，定义是什么意思，并确定状态转移方程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Leetcode—2020-9&quot;&gt;&lt;a href=&quot;#Leetcode—2020-9&quot; class=&quot;headerlink&quot; title=&quot;Leetcode—2020.9&quot;&gt;&lt;/a&gt;Leetcode—2020.9&lt;/h2&gt;&lt;h3 id=&quot;Day01&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="Leetcode" scheme="https://ywj1.github.io/categories/Leetcode/"/>
    
    
    <category term="leetcode" scheme="https://ywj1.github.io/tags/leetcode/"/>
    
    <category term="回溯算法" scheme="https://ywj1.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
    <category term="DFS" scheme="https://ywj1.github.io/tags/DFS/"/>
    
    <category term="链表" scheme="https://ywj1.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="二叉树" scheme="https://ywj1.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>文献阅读方法</title>
    <link href="https://ywj1.github.io/2020/09/16/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95/"/>
    <id>https://ywj1.github.io/2020/09/16/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95/</id>
    <published>2020-09-16T14:02:29.000Z</published>
    <updated>2020-09-25T11:08:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文献阅读方法"><a href="#文献阅读方法" class="headerlink" title="文献阅读方法"></a>文献阅读方法</h1><h4 id="阅读初期"><a href="#阅读初期" class="headerlink" title="阅读初期"></a>阅读初期</h4><ol><li><p><strong>收集关注主题的资源(注意文献整理)</strong></p><ul><li>关键词，主题词检索</li><li>检索某个学者</li><li>参考综述检索</li><li>注意文章参考价值</li></ul></li><li><p><strong>按照完成程度构建一个表格</strong></p></li><li><strong>结构性笔记：用自己的语言总结论文的关键发现，结果和技术</strong></li></ol><h4 id="如何阅读"><a href="#如何阅读" class="headerlink" title="如何阅读"></a>如何阅读</h4><ol><li>第一遍从title，abstract和figures开始阅读</li><li>第二遍阅读introduction，conclusion过一遍figures</li><li>阅读整个论文整个部分，跳过不熟悉的</li></ol><h4 id="阅读后"><a href="#阅读后" class="headerlink" title="阅读后"></a>阅读后</h4><p>必须问自己问题：</p><ol><li>作者目的是什么，实现了什么</li><li>引入了什么新型的方法，新方法的要素是什么</li><li>论文中什么对我比较重要</li><li>有什么参考文献需要跟踪</li></ol><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><strong>提高阅读效率</strong></p><ul><li>集中时间看文献</li><li>做好记录和标记</li><li>注重如何阅读</li></ul><p>阅读文献时候，要总结常用句型和常用短语（以英文为母语者）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文献阅读方法&quot;&gt;&lt;a href=&quot;#文献阅读方法&quot; class=&quot;headerlink&quot; title=&quot;文献阅读方法&quot;&gt;&lt;/a&gt;文献阅读方法&lt;/h1&gt;&lt;h4 id=&quot;阅读初期&quot;&gt;&lt;a href=&quot;#阅读初期&quot; class=&quot;headerlink&quot; title=&quot;阅</summary>
      
    
    
    
    <category term="Method" scheme="https://ywj1.github.io/categories/Method/"/>
    
    
    <category term="Method" scheme="https://ywj1.github.io/tags/Method/"/>
    
    <category term="文献阅读" scheme="https://ywj1.github.io/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
</feed>
