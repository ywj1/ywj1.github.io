<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈奔的博客</title>
  
  
  <link href="https://ywj1.github.io/atom.xml" rel="self"/>
  
  <link href="https://ywj1.github.io/"/>
  <updated>2020-10-26T08:14:36.000Z</updated>
  <id>https://ywj1.github.io/</id>
  
  <author>
    <name>陈奔</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Trident Network</title>
    <link href="https://ywj1.github.io/2020/10/26/Trident-Network/"/>
    <id>https://ywj1.github.io/2020/10/26/Trident-Network/</id>
    <published>2020-10-26T07:30:54.000Z</published>
    <updated>2020-10-26T08:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Scale-Aware-Trident-Networks-for-Object-Detection-用于物体检测的可感知规模的三叉戟网络"><a href="#Scale-Aware-Trident-Networks-for-Object-Detection-用于物体检测的可感知规模的三叉戟网络" class="headerlink" title="Scale-Aware Trident Networks for Object Detection(用于物体检测的可感知规模的三叉戟网络)"></a>Scale-Aware Trident Networks for Object Detection(用于物体检测的可感知规模的三叉戟网络)</h2><h3 id="初步阅读"><a href="#初步阅读" class="headerlink" title="初步阅读"></a>初步阅读</h3><p><strong>作者写作目的</strong></p><p>scale variation在目标检测中是一个十分重要的问题，因此作者提出了Trident block来进行多尺度特征检测。</p><p><strong>作者新颖的方法</strong></p><p>针对之前Feature Fusion中的一些问题，例如特征不连续等，提出了Trident Network，其实这个的关键在于Trident block，对于一个feature map使用三条支路（不同的带孔卷积）。</p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><h4 id="Trident-Networks"><a href="#Trident-Networks" class="headerlink" title="Trident Networks"></a>Trident Networks</h4><p>作者首先说明三个对于目标检测影响的重要因素：1.downsample rate 2. network depth 3. receptive field。对于第三个作者做了实验来说明该影响，对于大的scale物体，使用dilation大的带孔卷积效果会更好。</p><h5 id="Trident-block"><a href="#Trident-block" class="headerlink" title="Trident block"></a>Trident block</h5><p>于是作者在上述实验的基础之上，提出了Trident block，对于同一个模块，使用不同dilation的带孔卷积，从而达到不同scale的训练，并且针对FPN的feature inconsistency，作者的Trident block使用了uniform representational power。</p><p><img src="/2020/10/26/Trident-Network/network.jpg" alt="avatar"></p><p>并且作者提出了三个策略</p><ol><li>weigh sharing among branches，通过带孔卷积间的权重共享，可以减少参数个数，并且使用一个uniform transformation with the same representational power。</li><li>scale-aware training scheme，对于每个branch设置了不同的范围，之后对于不同的RoI使用不同的branch来进行训练。</li><li>使用middle branch来进行inference。加快了速度。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Scale-Aware-Trident-Networks-for-Object-Detection-用于物体检测的可感知规模的三叉戟网络&quot;&gt;&lt;a href=&quot;#Scale-Aware-Trident-Networks-for-Object-Detection-用于</summary>
      
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Object detection" scheme="https://ywj1.github.io/tags/Object-detection/"/>
    
    <category term="multi-scale" scheme="https://ywj1.github.io/tags/multi-scale/"/>
    
  </entry>
  
  <entry>
    <title>AFF</title>
    <link href="https://ywj1.github.io/2020/10/24/AFF/"/>
    <id>https://ywj1.github.io/2020/10/24/AFF/</id>
    <published>2020-10-24T05:56:50.000Z</published>
    <updated>2020-10-24T06:39:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Attention-Feature-Fusion-AFF-注意力机制的特征融合"><a href="#Attention-Feature-Fusion-AFF-注意力机制的特征融合" class="headerlink" title="Attention Feature Fusion(AFF:注意力机制的特征融合)"></a>Attention Feature Fusion(AFF:注意力机制的特征融合)</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><p><strong>作者写作目的</strong></p><p>To better fuse features of inconsistent semantics and scales. 因为之前的feature fusion有三个drawbacks:</p><ol><li>semantic inconsistency(语义不连续，模型通过feature fusion之后会造成语义不连续)</li><li>unsophisticated initial integration(简单的初步整合，对于俩个feature，仅仅通过element-wise summation)</li><li>仅仅对于global feature进行feature fusion，这会造成biased context aggregation scale</li></ol><p><strong>作者新颖之处</strong></p><p>作者基于SENet和SKNet提出了AFF模型，通过结合局部特征和全局特征的attention机制来进行feature fusion。</p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><h4 id="Attention-Feature-Fusion"><a href="#Attention-Feature-Fusion" class="headerlink" title="Attention Feature Fusion"></a>Attention Feature Fusion</h4><h5 id="MS-CAM-model"><a href="#MS-CAM-model" class="headerlink" title="MS_CAM model"></a>MS_CAM model</h5><p>下图是MS_CAM模型：</p><p><img src="/2020/10/24/AFF/MS_CAM.png" alt="avatar"></p><p>MS_CAM采用了bottleneck structure，左边是global feature，右边是local feature，其中左边的global feature与SENet不同之处在于，将SENet的Fully connected layer变为了Point-wise Conv layer，这样的目的是减小了计算量。其中+表示的element-wise summation，✖表示的element-wise multiplication。</p><h5 id="AFF-model"><a href="#AFF-model" class="headerlink" title="AFF model"></a>AFF model</h5><p><img src="/2020/10/24/AFF/AFF.png" alt="avatar"></p><p><img src="/2020/10/24/AFF/function-aff.png" alt="avatar"></p><p>其中Z表示的fused feature，我觉得该feature fusion想法类似于Cross Entropy。（理解起来还挺简单，但是想到是真的难！）对于其中的initial integration仅仅使用了简单的element-wise summation。因此作者在此基础之上又提出了iAFF，其实iAFF就是俩层AFF，对于X,Y在使用一次MS_CAM模型。如图：</p><p><img src="/2020/10/24/AFF/iAFF.png" alt="avatar"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Attention-Feature-Fusion-AFF-注意力机制的特征融合&quot;&gt;&lt;a href=&quot;#Attention-Feature-Fusion-AFF-注意力机制的特征融合&quot; class=&quot;headerlink&quot; title=&quot;Attention Feat</summary>
      
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Feature Fusion" scheme="https://ywj1.github.io/tags/Feature-Fusion/"/>
    
    <category term="Object detection" scheme="https://ywj1.github.io/tags/Object-detection/"/>
    
  </entry>
  
  <entry>
    <title>ConerNet</title>
    <link href="https://ywj1.github.io/2020/10/23/ConerNet/"/>
    <id>https://ywj1.github.io/2020/10/23/ConerNet/</id>
    <published>2020-10-23T01:43:03.000Z</published>
    <updated>2020-10-23T02:33:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CornerNet-Detecting-Objects-as-Paired-Keypoints-ConerNet-以成对的关键点检测目标"><a href="#CornerNet-Detecting-Objects-as-Paired-Keypoints-ConerNet-以成对的关键点检测目标" class="headerlink" title="CornerNet: Detecting Objects as Paired Keypoints(ConerNet:以成对的关键点检测目标)"></a>CornerNet: Detecting Objects as Paired Keypoints(ConerNet:以成对的关键点检测目标)</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><p><strong>作者写作目的？</strong></p><p>在之前的object detector中，由于anchor boxes的存在，会产生一些问题</p><ol><li>需要产生大量的anchor boxes</li><li>需要调整很多的参数，例如aspect ratios，scale等</li></ol><p>因此作者希望使用一个anchor-free detector来实现目标检测。</p><p><strong>新颖之处</strong></p><p>对于检测object，不像之前那样，需要检测center points，而是进行top-left and bottom-right的检测，并且设计了corner pooling来进行localize corner。作者借鉴了人体姿态估计的思想（embedding vector）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CornerNet-Detecting-Objects-as-Paired-Keypoints-ConerNet-以成对的关键点检测目标&quot;&gt;&lt;a href=&quot;#CornerNet-Detecting-Objects-as-Paired-Keypoints-Cone</summary>
      
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Object detection" scheme="https://ywj1.github.io/tags/Object-detection/"/>
    
    <category term="anchor-free" scheme="https://ywj1.github.io/tags/anchor-free/"/>
    
  </entry>
  
  <entry>
    <title>RetinaNet</title>
    <link href="https://ywj1.github.io/2020/10/18/RetinaNet/"/>
    <id>https://ywj1.github.io/2020/10/18/RetinaNet/</id>
    <published>2020-10-18T02:23:59.000Z</published>
    <updated>2020-10-18T06:01:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Focal-Loss-for-Dense-Object-Detection"><a href="#Focal-Loss-for-Dense-Object-Detection" class="headerlink" title="Focal Loss for Dense Object Detection"></a>Focal Loss for Dense Object Detection</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><h4 id="作者写作的目的"><a href="#作者写作的目的" class="headerlink" title="作者写作的目的"></a>作者写作的目的</h4><p>为了能够使one-stage的准确率能够提升到和two-stage差不多类似的精度，在不丧失速度的前提下。作者觉得这是由于one-stage的正负比例不均匀，导致训练之后的准确率不高。</p><h4 id="作者提出的新颖的方法"><a href="#作者提出的新颖的方法" class="headerlink" title="作者提出的新颖的方法"></a>作者提出的新颖的方法</h4><p>作者提出了一个新的损失函数(Focal Loss)，来进行平衡class imbalance。</p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>由于one-stage并没有像two-stage那样，提出region proposal，因此对于one-stage模型，会产生大量的negative samples，这就会造成class imbalance。class imbalance会造成俩个后果，引用原文：</p><ol><li>training is inefficient as most locations are easy negatives that contribute no useful learning signal.</li><li>en masse, the easy negatives can overwhelm training and lead to degenerate models.</li></ol><p>负样本数量过大，并且都是容易分类的样本，因此模型的优化并不是朝着我们希望的方向。因此本文针对类别不平衡，提出了一个新的loss function(Focal Loss function)。</p><h4 id="RetinaNet"><a href="#RetinaNet" class="headerlink" title="RetinaNet"></a>RetinaNet</h4><h5 id="Focal-Loss-Function"><a href="#Focal-Loss-Function" class="headerlink" title="Focal Loss Function"></a>Focal Loss Function</h5><p>在cross entropy和balanced cross entropy基础之上，作者提出了Focal Loss，it is defined as:</p><script type="math/tex; mode=display">\begin{equation}FL(p_t) =\begin{cases}-\alpha(1-p_t)^{\gamma}log(p_t),& y=1 \\(1-\alpha)(p_t)^{\gamma}log(1-p_t), & y = 0\\\end{cases}\end{equation}</script><p>因为balanced cross entropy能平衡正负样本，但是无法控制easy/hard examples，因此作者提出了Focal Loss，focus training on hard negatives。其中$\gamma$为调制系数(modulating factor)。目的是通过减少易分类样本的权重，从而使模型在训练时候更专注难分类的样本。$\alpha$可以控制正负样本权重。</p><p>对于Focal Loss有俩个重要的性质：</p><ol><li><p>当样本被分错之后，$p_t$很小，因此$(1-p_t)^{\gamma}$趋于1，相比于原来的loss没什么区别，当$p_t$趋于1时候(样本分类正确，且是易分类样本)，参数区域0，对于总的loss贡献很小。</p></li><li><p>$\gamma$增加时候，前面的参数也会增加。</p></li></ol><h5 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h5><p><img src="/2020/10/18/RetinaNet/RetinaNet.jpg" alt="avator"></p><p>使用ResNet+FPN为backbone，在每层的feature map中使用class subnet和box subnet。（具体如图所示）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Focal-Loss-for-Dense-Object-Detection&quot;&gt;&lt;a href=&quot;#Focal-Loss-for-Dense-Object-Detection&quot; class=&quot;headerlink&quot; title=&quot;Focal Loss for Den</summary>
      
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Object detection" scheme="https://ywj1.github.io/tags/Object-detection/"/>
    
    <category term="one-stage" scheme="https://ywj1.github.io/tags/one-stage/"/>
    
  </entry>
  
  <entry>
    <title>MobileNetv2</title>
    <link href="https://ywj1.github.io/2020/10/15/MobileNetv2/"/>
    <id>https://ywj1.github.io/2020/10/15/MobileNetv2/</id>
    <published>2020-10-15T12:13:32.000Z</published>
    <updated>2020-10-15T13:18:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MobileNetV2-Inverted-Residuals-and-Linear-Bottlenecks-MobileNetV2：残差和线性瓶颈"><a href="#MobileNetV2-Inverted-Residuals-and-Linear-Bottlenecks-MobileNetV2：残差和线性瓶颈" class="headerlink" title="MobileNetV2: Inverted Residuals and Linear Bottlenecks(MobileNetV2：残差和线性瓶颈)"></a>MobileNetV2: Inverted Residuals and Linear Bottlenecks(MobileNetV2：残差和线性瓶颈)</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><h4 id="作者写作的目的"><a href="#作者写作的目的" class="headerlink" title="作者写作的目的"></a>作者写作的目的</h4><p>保证模型的accuracy的同时降低模操作和内存消耗，使这个模型更能够部署在Mobile application中</p><h4 id="作者创新的方法"><a href="#作者创新的方法" class="headerlink" title="作者创新的方法"></a>作者创新的方法</h4><p>使用一个Inverted Residuals和Linear Bottlenecks来对原有的MobileNetv1进行改进。</p><h3 id="MobileNetV2"><a href="#MobileNetV2" class="headerlink" title="MobileNetV2"></a>MobileNetV2</h3><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p>MobileNetV2使用Inverted Residuals模块来进行构造网络结构。</p><h5 id="Inverted-Residuals"><a href="#Inverted-Residuals" class="headerlink" title="Inverted Residuals"></a>Inverted Residuals</h5><p>其实这个就是类似于Residuals network中的残差块，都是先用$1\times 1$卷积，使用$3\times 3$，再使用$1\times 1$进行操作，最后使用残差连接，其中不同的点在于残差网络中，先对原有的feature map进行降维，之后进行升维，Inverted Residuals对于feature map进行升维之后进行降维。</p><p><img src="/2020/10/15/MobileNetv2/difference-residual.jpg" alt="avatar"></p><h5 id="Body-Architecture"><a href="#Body-Architecture" class="headerlink" title="Body Architecture"></a>Body Architecture</h5><p><img src="/2020/10/15/MobileNetv2/network.png" alt="avatar"></p><p>本文提出了针对非线性激活函数提出了俩个猜想</p><ol><li>If the mainifold of interest remains non-zeros volume after ReLU transformation, it corresponds to a linear transformation.</li><li>ReLU is capable of preserving complete infromation about the input mainifold, but only if the input mainifold lies in a low-dimensional subspace of the input shape.</li></ol><p>第一个理论理解应该使简单因为$ReLU(x) = max(0,x)$，因此对于大于0的情况下，他就是线性的变化。对于猜想中的mainifold of interest理解成$w\times h\times c$的feature map上的一个点的c维特征，文章使用Linear Bottlenecks来进行说明网络的最后一层不使用ReLU非线性激活函数的原因。因为对于ReLU激活函数会造成信息的损失，但是随着输出维度的增加，信息的丢失会减小，因此使用线性层来减少信息的丢失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MobileNetV2-Inverted-Residuals-and-Linear-Bottlenecks-MobileNetV2：残差和线性瓶颈&quot;&gt;&lt;a href=&quot;#MobileNetV2-Inverted-Residuals-and-Linear-Bottl</summary>
      
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="backbone" scheme="https://ywj1.github.io/tags/backbone/"/>
    
    <category term="classfication" scheme="https://ywj1.github.io/tags/classfication/"/>
    
  </entry>
  
  <entry>
    <title>MobileNetv1</title>
    <link href="https://ywj1.github.io/2020/10/15/MobileNetv1/"/>
    <id>https://ywj1.github.io/2020/10/15/MobileNetv1/</id>
    <published>2020-10-15T12:13:26.000Z</published>
    <updated>2020-10-15T12:49:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MobileNets-Efficient-Convolutional-Neural-Networks-for-Mobile-Vision-Applications-MobileNets：用于移动视觉应用的高效卷积神经网络"><a href="#MobileNets-Efficient-Convolutional-Neural-Networks-for-Mobile-Vision-Applications-MobileNets：用于移动视觉应用的高效卷积神经网络" class="headerlink" title="MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications(MobileNets：用于移动视觉应用的高效卷积神经网络)"></a>MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications(MobileNets：用于移动视觉应用的高效卷积神经网络)</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><h4 id="作者写作的目的"><a href="#作者写作的目的" class="headerlink" title="作者写作的目的"></a>作者写作的目的</h4><p>为了能够将深度学习模型应用于移动应用中（例如手机等），因此需要降低模型的复杂度，从而降低对于运算时间和内存的消耗。</p><h4 id="作者的创新点"><a href="#作者的创新点" class="headerlink" title="作者的创新点"></a>作者的创新点</h4><p>使用Depthwise Separable Convolution(深度可分离卷积)和pointwise convolution(逐点卷积)来对传统的卷积操作进行切分，这样子就降低了模型的参数，从而就降低了运算时间和内存消耗。</p><h3 id="MobileNets"><a href="#MobileNets" class="headerlink" title="MobileNets"></a>MobileNets</h3><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p>网络的主要的单元是由Depthwise Separable Convolution和Pointwise Convolution来代替普通卷积来构成的。</p><p><img src="/2020/10/15/MobileNetv1/network.jpg" alt="avatar"></p><p>在每个深度可分离卷积和逐点卷积之后加上BN和ReLU层来进行操作。接下来分别说一说这俩个卷积。</p><h5 id="Depthwise-Separable-Convolution"><a href="#Depthwise-Separable-Convolution" class="headerlink" title="Depthwise Separable Convolution"></a>Depthwise Separable Convolution</h5><p>对于传统的卷积模型，要将$D_K\times D_k\times M$经过卷积成$D_K\times D_K\times N$,要使用(kernel_size = m)的卷积核$m\times m\times M\times N$</p><p>因此对于FLOPs，为$D_K\times D_K\times m\times m\times M\times N$，从理论上来说传统的卷积，是对于一个channel来说有$m\times m\times N$的size的卷积核来与feature map进行卷积操作。</p><p>对于Depthwise Separable Convolution，卷积核的一个channel对应于feature map的一个channel，因此只需要使用$m\times m \times M$ size的卷积核即可进行深度可分离卷积。</p><h5 id="Pointwise-Convolution"><a href="#Pointwise-Convolution" class="headerlink" title="Pointwise Convolution"></a>Pointwise Convolution</h5><p>对于深度可分离卷积操作过后的output我们是没办法改变它的channel的，因此需要逐点卷积来进行channel的改变，因此需要$1\times 1\times M \times N$size的卷积核。</p><p>因此对于上述操作之后，FLOPs为$D_K\times D_K \times m\times m\times M+D_K\times D_K\times M\times N$，因此相对于传统的卷积，FLOPs降低了$m^2$</p><h5 id="Body-Architecture"><a href="#Body-Architecture" class="headerlink" title="Body Architecture"></a>Body Architecture</h5><p>下图是它的模型的整体参数</p><p><img src="/2020/10/15/MobileNetv1/Body Architecture.jpg" alt="avatar"></p><p>对于模型我们引入俩个参数$\alpha$(宽度因子)和$\rho$(分辨率因子)来分别控制输入通道，输出通道的大小和输入图片的size。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MobileNets-Efficient-Convolutional-Neural-Networks-for-Mobile-Vision-Applications-MobileNets：用于移动视觉应用的高效卷积神经网络&quot;&gt;&lt;a href=&quot;#MobileNets</summary>
      
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="backbone" scheme="https://ywj1.github.io/tags/backbone/"/>
    
    <category term="classfication" scheme="https://ywj1.github.io/tags/classfication/"/>
    
  </entry>
  
  <entry>
    <title>EfficientDet</title>
    <link href="https://ywj1.github.io/2020/10/13/EfficientDet/"/>
    <id>https://ywj1.github.io/2020/10/13/EfficientDet/</id>
    <published>2020-10-13T07:35:23.000Z</published>
    <updated>2020-10-22T07:38:48.000Z</updated>
    
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="object detection" scheme="https://ywj1.github.io/tags/object-detection/"/>
    
    <category term="one-stage" scheme="https://ywj1.github.io/tags/one-stage/"/>
    
  </entry>
  
  <entry>
    <title>EfficientNet</title>
    <link href="https://ywj1.github.io/2020/10/13/EfficientNet/"/>
    <id>https://ywj1.github.io/2020/10/13/EfficientNet/</id>
    <published>2020-10-13T07:35:03.000Z</published>
    <updated>2020-10-22T07:38:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EfficientNet-Rethinking-Model-Scaling-for-Convolutional-Neural-Networks-EfficientNet-对卷积神经网络缩放的重新思考"><a href="#EfficientNet-Rethinking-Model-Scaling-for-Convolutional-Neural-Networks-EfficientNet-对卷积神经网络缩放的重新思考" class="headerlink" title="EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks(EfficientNet:对卷积神经网络缩放的重新思考)"></a>EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks(EfficientNet:对卷积神经网络缩放的重新思考)</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><p><strong>作者写作目的?</strong></p><p>作者为了能够量化卷积神经网络的缩放（即深度，宽度和图片的解析率）对accuracy造成的影响，作者设计了compound scaling。同时扩展模型的不同维度来增加模型的效率，并保持accuracy增加。</p><p><strong>作者的新颖之处</strong></p><p>我觉得这篇文章的一个亮点，就是设计了compound scaling，将指标进行了量化，在增长accuracy的同时，提高了模型的efficiency。其中EfficientNet只是一个backbone，基于之前的模型设计出来的。</p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>从Net的名字可以看出，这是一个Efficient work，文章的主题思路，设计了一个compound scaling：</p><script type="math/tex; mode=display">depth:d = \alpha^\phi\\width:w=\beta^\phi\\resolution:r=\gamma^\phi\\s.t. \alpha\times\beta^2\times\gamma^2≈2</script><p>而这个compound scaling是从俩个observation中的得出的：</p><ul><li>Observation 1：对于网络的深度，宽度，分辨率中任何维度进行随访都可以提高精度，但是当模型足够大时候，会达到饱和。</li><li>Observation 2：为了追求更好的精度和效率，在缩放时平衡网络所有维度至关重要。</li></ul><p>为了确定constant参数，首先固定$\phi = 1$，进行一个小范围的搜索，最终确定的值为，$\alpha=1.2,\beta=1.1,\gamma=1.15$，之后的EfficientNetB1-B7都是基于该参数进行缩放的。</p><h4 id="EfficientNet"><a href="#EfficientNet" class="headerlink" title="EfficientNet"></a>EfficientNet</h4><p>EfficientNet基于mobile invered bottlenetc MBConv来进行设计，总体架构如下图所示：</p><p><img src="/2020/10/13/EfficientNet/Network.jpg" alt="avatar"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;EfficientNet-Rethinking-Model-Scaling-for-Convolutional-Neural-Networks-EfficientNet-对卷积神经网络缩放的重新思考&quot;&gt;&lt;a href=&quot;#EfficientNet-Rethinki</summary>
      
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="backbone" scheme="https://ywj1.github.io/tags/backbone/"/>
    
    <category term="classification" scheme="https://ywj1.github.io/tags/classification/"/>
    
  </entry>
  
  <entry>
    <title>SSD</title>
    <link href="https://ywj1.github.io/2020/10/09/SSD/"/>
    <id>https://ywj1.github.io/2020/10/09/SSD/</id>
    <published>2020-10-09T05:47:08.000Z</published>
    <updated>2020-10-14T12:42:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSD-Single-Shot-MultiBox-Detector"><a href="#SSD-Single-Shot-MultiBox-Detector" class="headerlink" title="SSD: Single Shot MultiBox Detector"></a>SSD: Single Shot MultiBox Detector</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><p><strong>作者写作目的？</strong></p><p>加快检测速度，并提高准确率</p><p><strong>新颖的方法？</strong></p><p>SSD提取了不同尺度的特征图来进行预测。</p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>从名字可以读出SSD是一个多框预测算法，并且在准确度和速度上都比YOLO算法要好，SSD相对于YOLO算法有俩个很重要的改变：1. 提取了不同尺度的特征图来进行检测，使用大尺度来检测小物体，小尺度来进行检测大物体。2. 使用Default boxes(anchor boxes)来进行多框预测，并且不同于YOLO算法使用Fully connected，SSD使用$3\times 3$filter来进行结果预测。</p><h4 id="SSD模型"><a href="#SSD模型" class="headerlink" title="SSD模型"></a>SSD模型</h4><p>使用VGG模型(改造过)进行特征提取，在VGG提取之后，继续使用卷积核来继续进行特征图提取，并且对于不同的feature map使用$3\times 3$ filter来进行边界框预测和分类，最后使用NMS算法，删除多余的候选框，最后得到预测的边界框。(如下图)</p><p><img src="/2020/10/09/SSD/model.jpg" alt="avatar"></p><h5 id="SSD模型的改进之处"><a href="#SSD模型的改进之处" class="headerlink" title="SSD模型的改进之处"></a>SSD模型的改进之处</h5><p><strong>用于目标检测的多尺度特征图</strong></p><p>在改造过后的VGGNet使用卷积层继续提取feature map，使用后续的feature map来进行object detection。从而达到了多尺度的效果。(因为使用同一张图的不同feature map可以提高语义分割的质量，这类似于使用不同尺度的相同种类图片)</p><p><strong>使用卷积核来进行目标预测</strong></p><p>如上图所示，不同于YOLO算法在backbone之后使用fully connected layer，SSD使用convolutional layer来进行目标的预测。</p><p><strong>默认框和高宽比</strong></p><p>即使用了anchor boxes在每个特征图中。</p><h5 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h5><p><strong>匹配策略</strong></p><p>对于default boxes和ground truth，使用IoU大于0.5的当作正样本。</p><p><strong>目标函数</strong></p><script type="math/tex; mode=display">L(x,c,l,g) = \frac{1}{N}(L_{conf}(x,c)+\alpha L_{loc}(x,l,g))</script><p>$L_{conf}$表示的分类损失函数，使用softmax loss函数来进行计算</p><script type="math/tex; mode=display">L_{conf}(x,c) = -\sum^N_{i\in Pos(T)}x_{ij}^plog(\hat{c}_i^p)-\sum_{i\in Neg(F)}log(\hat{c}_0^i)</script><script type="math/tex; mode=display">\hat{c}_i^p = \frac{exp(c_i^p)}{\sum_jexp(c_i^j)}​</script><p>$L_{loc}$表示的是回归损失函数，使用Smooth L1函数来进行计算，其中回归表示的边界框损失回归。(详见Faster R-CNN)</p><p><strong>为default boxes选不同的scales和aspect ratios</strong></p><p>scale of default boxes is defined as:</p><script type="math/tex; mode=display">s_k = s_{min} + \frac{s_{max} - s_{min}}{m-1}(k-1), k\in[1,m]</script><p>论文中设置$s_{min} = 0.2, s_{max} = 0.9，m = 6$，并且设置$aspect  ratios\in \{1,2,3,1/2,1/3\} $，对于ration为1的default boxes，继续设置scale为$\sqrt{s_ks_{k+1}}$，对于每个default boxes我们设置中心点为</p><script type="math/tex; mode=display">(\frac{i+0.5}{|f_k|},\frac{j+0.5}{|f_k|})</script><p>$|f_k|$表示的是第k个feature map的面积。</p><p>并且对于VGG中的feature map和最后一层feature map只设置4个default boxes，不设置3，1/3这俩个高宽比。</p><p><strong>设置训练样本</strong></p><p>按照default boxes产生的负样本会有很多，因此会产生正负样本比例失调，从而导致了欠拟合，因此我们将负样本按照IoU从大到小排序，并选取3：1的正负样本比例。</p><p><strong>VGGNet的改进</strong></p><p>将VGG16的全连接层fc6和fc7换成$3\times 3$的卷积层和$1\times 1$的卷积层，并将前一层的池化层使用Atrous Algorithm(带孔卷积\\扩展卷积)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SSD-Single-Shot-MultiBox-Detector&quot;&gt;&lt;a href=&quot;#SSD-Single-Shot-MultiBox-Detector&quot; class=&quot;headerlink&quot; title=&quot;SSD: Single Shot MultiBox </summary>
      
    
    
    
    <category term="论文笔记" scheme="https://ywj1.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Object detection" scheme="https://ywj1.github.io/tags/Object-detection/"/>
    
    <category term="one-stage" scheme="https://ywj1.github.io/tags/one-stage/"/>
    
  </entry>
  
  <entry>
    <title>AI在医学应用</title>
    <link href="https://ywj1.github.io/2020/10/08/AI%E5%9C%A8%E5%8C%BB%E5%AD%A6%E5%BA%94%E7%94%A8/"/>
    <id>https://ywj1.github.io/2020/10/08/AI%E5%9C%A8%E5%8C%BB%E5%AD%A6%E5%BA%94%E7%94%A8/</id>
    <published>2020-10-08T06:36:33.000Z</published>
    <updated>2020-10-08T06:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h4><p>two-stage相对于one-stage具有更高的精度，因此使用two-stage来进行检测</p><p>医学图像的正负样本不均衡，使用data augmentation来进行样本扩充。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;注意的点&quot;&gt;&lt;a href=&quot;#注意的点&quot; class=&quot;headerlink&quot; title=&quot;注意的点&quot;&gt;&lt;/a&gt;注意的点&lt;/h4&gt;&lt;p&gt;two-stage相对于one-stage具有更高的精度，因此使用two-stage来进行检测&lt;/p&gt;
&lt;p&gt;医学图像的正负</summary>
      
    
    
    
    
    <category term="Object detection" scheme="https://ywj1.github.io/tags/Object-detection/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Day17</title>
    <link href="https://ywj1.github.io/2020/10/08/Leetcode-Day17/"/>
    <id>https://ywj1.github.io/2020/10/08/Leetcode-Day17/</id>
    <published>2020-10-08T04:29:03.000Z</published>
    <updated>2020-10-08T04:29:04.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>YOLO9000</title>
    <link href="https://ywj1.github.io/2020/10/07/YOLO9000/"/>
    <id>https://ywj1.github.io/2020/10/07/YOLO9000/</id>
    <published>2020-10-07T06:19:40.000Z</published>
    <updated>2020-10-07T06:19:42.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode Day16</title>
    <link href="https://ywj1.github.io/2020/10/06/Leetcode-Day16/"/>
    <id>https://ywj1.github.io/2020/10/06/Leetcode-Day16/</id>
    <published>2020-10-06T01:15:46.000Z</published>
    <updated>2020-10-06T02:36:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-Day16"><a href="#Leetcode-Day16" class="headerlink" title="Leetcode Day16"></a>Leetcode Day16</h2><h4 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h4><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">题目链接</a></p><p>题目描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p>思路:</p><p>使用动态规划的思想来进行求解，动态规划的思路关键是列出状态转移方程，对于该题来说我们说着dp[i]表示以A[i]结尾的最大序列和，状态转移方程则为: dp[i] = max(A[i], dp[i-1]+A[i])</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(nums[i], dp[i<span class="number">-1</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; dp[k])&#123;</span><br><span class="line">                k = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="最长上升子序列-LIS"><a href="#最长上升子序列-LIS" class="headerlink" title="最长上升子序列(LIS)"></a>最长上升子序列(LIS)</h4><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">题目链接</a></p><p>题目描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个无序的整数数组，找到其中最长上升子序列的长度。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</span><br><span class="line">你算法的时间复杂度应该为 O(n2) </span><br></pre></td></tr></table></figure><p>思路:</p><p>使用动态规划来进行求解，状态量dp[i]表示的是当前这个数的最长上升长度。状态转移方程为$dp[i] = max(1, dp[j] + 1),(j=1,…,n-1 \&amp; A[j] &lt; A[i])$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i] &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i])</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>DP最重要的是找出状态量，定义是什么意思，并确定状态转移方程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Leetcode-Day16&quot;&gt;&lt;a href=&quot;#Leetcode-Day16&quot; class=&quot;headerlink&quot; title=&quot;Leetcode Day16&quot;&gt;&lt;/a&gt;Leetcode Day16&lt;/h2&gt;&lt;h4 id=&quot;最大子序和&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Leetcode" scheme="https://ywj1.github.io/categories/Leetcode/"/>
    
    
    <category term="leetcode" scheme="https://ywj1.github.io/tags/leetcode/"/>
    
    <category term="DP" scheme="https://ywj1.github.io/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Day15</title>
    <link href="https://ywj1.github.io/2020/10/05/Leetcode-Day15/"/>
    <id>https://ywj1.github.io/2020/10/05/Leetcode-Day15/</id>
    <published>2020-10-05T01:35:26.000Z</published>
    <updated>2020-10-05T02:55:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-Day15"><a href="#Leetcode-Day15" class="headerlink" title="Leetcode Day15"></a>Leetcode Day15</h2><h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p><a href="https://leetcode-cn.com/problems/3sum/">题目链接</a></p><p>题目描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</span><br><span class="line"></span><br><span class="line">注意：答案中不可以包含重复的三元组。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>思路：</p><p>最容易想到的是暴力解法，即将循环三遍，找出相加为0的数组。但是该时间复杂度比较高是$O(n^3)$,从俩数相加的方法找到思路，我们可以缩短时间复杂度，使用双指针的方法，即将第二个和第三个数放在一起，使用双指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)&#123;</span><br><span class="line"><span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> first = <span class="number">0</span>; first &lt; n; ++first)&#123;</span><br><span class="line"><span class="comment">//需要和上次不同</span></span><br><span class="line"><span class="keyword">if</span>(first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> third = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> target = -nums[first];</span><br><span class="line"><span class="comment">//枚举第二个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> second = first + <span class="number">1</span>; second &lt; n; ++ second)&#123;</span><br><span class="line"><span class="keyword">if</span>(second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target)&#123;</span><br><span class="line">--third;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(second == third)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[second] + nums[third] == target)</span><br><span class="line">ans.<span class="built_in">push_back</span>(&#123;nums[first], nums[second], nums[third]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><p><a href="https://leetcode-cn.com/problems/4sum/">题目链接</a></p><p>题目描述:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">答案中不可以包含重复的四元组。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>思路：</p><p>与三数之和类似，使用双指针的解法，只不过多了一层嵌套。其中的一些剪枝条件：</p><p>在确定第一个数之后，如果 $\textit{nums}[i]+\textit{nums}[i+1]+\textit{nums}[i+2]+\textit{nums}[i+3]&gt;\textit{target}$，说明此时剩下的三个数无论取什么值，四数之和一定大于 $\textit{target}$，因此退出第一重循环；<br>在确定第一个数之后，如果 $\textit{nums}[i]+\textit{nums}[n-3]+\textit{nums}[n-2]+\textit{nums}[n-1]&lt;\textit{target}$，说明此时剩下的三个数无论取什么值，四数之和一定小于$ \textit{target}$，因此第一重循环直接进入下一轮，枚举$ \textit{nums}[i+1]$；<br>在确定前两个数之后，如果$ \textit{nums}[i]+\textit{nums}[j]+\textit{nums}[j+1]+\textit{nums}[j+2]&gt;\textit{target}$，说明此时剩下的两个数无论取什么值，四数之和一定大于$\textit{target}$，因此退出第二重循环；<br>在确定前两个数之后，如果 $\textit{nums}[i]+\textit{nums}[j]+\textit{nums}[n-2]+\textit{nums}[n-1]&lt;\textit{target}$，说明此时剩下的两个数无论取什么值，四数之和一定小于$ \textit{target}$，因此第二重循环直接进入下一轮，枚举 $\textit{nums}[j+1]$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">4</span>)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">3</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(nums[i] + nums[length - <span class="number">3</span>] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length - <span class="number">2</span>; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nums[i] + nums[j] + nums[j+<span class="number">1</span>] + nums[j+<span class="number">2</span>]&gt;target)</span><br><span class="line"><span class="function"><span class="keyword">break</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(nums[i] + nums[j] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = j + <span class="number">1</span>, right = length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        left++;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Leetcode-Day15&quot;&gt;&lt;a href=&quot;#Leetcode-Day15&quot; class=&quot;headerlink&quot; title=&quot;Leetcode Day15&quot;&gt;&lt;/a&gt;Leetcode Day15&lt;/h2&gt;&lt;h4 id=&quot;三数之和&quot;&gt;&lt;a href=&quot;#三</summary>
      
    
    
    
    <category term="Leetcode" scheme="https://ywj1.github.io/categories/Leetcode/"/>
    
    
    <category term="leetcode" scheme="https://ywj1.github.io/tags/leetcode/"/>
    
    <category term="双指针" scheme="https://ywj1.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Day14</title>
    <link href="https://ywj1.github.io/2020/10/04/Leetcode-Day14/"/>
    <id>https://ywj1.github.io/2020/10/04/Leetcode-Day14/</id>
    <published>2020-10-04T02:27:06.000Z</published>
    <updated>2020-10-04T03:45:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-Day14"><a href="#Leetcode-Day14" class="headerlink" title="Leetcode Day14"></a>Leetcode Day14</h2><h4 id="俩数相加"><a href="#俩数相加" class="headerlink" title="俩数相加"></a>俩数相加</h4><p><a href="https://leetcode-cn.com/problems/add-two-numbers/">题目链接</a></p><p>题目描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</span><br><span class="line"></span><br><span class="line">如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</span><br><span class="line"></span><br><span class="line">您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>思路：</p><p>用一位数来表示位数相加是否大于10</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">ListNode* head = <span class="keyword">new</span> ListNode;</span><br><span class="line">ListNode* h = head;<span class="comment">//移动指针</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> plus = <span class="literal">false</span>;<span class="comment">//进位标志</span></span><br><span class="line"><span class="keyword">while</span>(l1 || l2)&#123;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l1)&#123;</span><br><span class="line">sum += l1-&gt;val;</span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(l2)&#123;</span><br><span class="line">sum += l2-&gt;val;</span><br><span class="line">l2 = l2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(plus)</span><br><span class="line">sum++;</span><br><span class="line">h-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">h = h-&gt;next;</span><br><span class="line">plus = (sum &gt;= <span class="number">10</span>)? <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(plus)&#123;</span><br><span class="line">h-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h4><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">题目链接</a></p><p>题目描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="line"></span><br><span class="line">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span><br><span class="line"></span><br><span class="line">例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p>思路：</p><p>存储每个节点的parent位置，并且存储要访问节点的前一个节点是否被访问过，即使用俩个hash表来进行存储。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, TreeNode* &gt; fa;</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            fa[root-&gt;left-&gt;val] = root;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            fa[root-&gt;right-&gt;val] = root;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        fa[root-&gt;val] = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            vis[p-&gt;val] = <span class="literal">true</span>;</span><br><span class="line">            p = fa[p-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(q)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[q-&gt;val])</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            q = fa[q-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归方法(不懂)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> lson = <span class="built_in">dfs</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">bool</span> rson = <span class="built_in">dfs</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span>((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson)))&#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Leetcode-Day14&quot;&gt;&lt;a href=&quot;#Leetcode-Day14&quot; class=&quot;headerlink&quot; title=&quot;Leetcode Day14&quot;&gt;&lt;/a&gt;Leetcode Day14&lt;/h2&gt;&lt;h4 id=&quot;俩数相加&quot;&gt;&lt;a href=&quot;#俩</summary>
      
    
    
    
    <category term="Leetcode" scheme="https://ywj1.github.io/categories/Leetcode/"/>
    
    
    <category term="leetcode" scheme="https://ywj1.github.io/tags/leetcode/"/>
    
    <category term="链表" scheme="https://ywj1.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="公共祖先" scheme="https://ywj1.github.io/tags/%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Day13</title>
    <link href="https://ywj1.github.io/2020/10/03/Leetcode-Day13/"/>
    <id>https://ywj1.github.io/2020/10/03/Leetcode-Day13/</id>
    <published>2020-10-03T01:34:17.000Z</published>
    <updated>2020-10-03T02:20:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-Day13"><a href="#Leetcode-Day13" class="headerlink" title="Leetcode Day13"></a>Leetcode Day13</h2><h4 id="俩数之和"><a href="#俩数之和" class="headerlink" title="俩数之和"></a>俩数之和</h4><p><a href="https://leetcode-cn.com/problems/two-sum/">题目链接</a></p><p>题目描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</span><br><span class="line"></span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>思路：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路简单，但是耗时很长。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != hashtable.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用hashtable可以大大的减少时间，但是使用空间增加了。</p><hr><h4 id="合并俩个排序的链表"><a href="#合并俩个排序的链表" class="headerlink" title="合并俩个排序的链表"></a>合并俩个排序的链表</h4><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">题目链接</a></p><p>题目描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</span><br><span class="line"></span><br><span class="line">示例1：</span><br><span class="line"></span><br><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p>思路：</p><p>迭代方法，构建一个新的节点，用来存放合并后的链表，比较l1与l2的值，将小的值放入新的链表，直到其中一个链表遍历结束，之后将剩余的链表值放入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode* cur = dummy;</span><br><span class="line">    <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;</span><br><span class="line">    cur-&gt;next = l1;</span><br><span class="line">    l1 = l1-&gt;next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    cur-&gt;next = l2;</span><br><span class="line">    l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">    cur-&gt;next = l1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l2)&#123;</span><br><span class="line">    cur-&gt;next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!l1)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(!l2)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;</span><br><span class="line">            l1-&gt;next = <span class="built_in">mergeTwoLists</span>(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l2-&gt;next = <span class="built_in">mergeTwoLists</span>(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Leetcode-Day13&quot;&gt;&lt;a href=&quot;#Leetcode-Day13&quot; class=&quot;headerlink&quot; title=&quot;Leetcode Day13&quot;&gt;&lt;/a&gt;Leetcode Day13&lt;/h2&gt;&lt;h4 id=&quot;俩数之和&quot;&gt;&lt;a href=&quot;#俩</summary>
      
    
    
    
    <category term="Leetcode" scheme="https://ywj1.github.io/categories/Leetcode/"/>
    
    
    <category term="leetcode" scheme="https://ywj1.github.io/tags/leetcode/"/>
    
    <category term="链表" scheme="https://ywj1.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Day12</title>
    <link href="https://ywj1.github.io/2020/10/02/Leetcode-Day12/"/>
    <id>https://ywj1.github.io/2020/10/02/Leetcode-Day12/</id>
    <published>2020-10-02T04:52:54.000Z</published>
    <updated>2020-10-03T01:41:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-Day12"><a href="#Leetcode-Day12" class="headerlink" title="Leetcode Day12"></a>Leetcode Day12</h2><h4 id="宝石与石头"><a href="#宝石与石头" class="headerlink" title="宝石与石头"></a>宝石与石头</h4><p><a href="https://leetcode-cn.com/problems/jewels-and-stones/">题目链接</a></p><p>题目描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</span><br><span class="line"></span><br><span class="line">J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此&quot;a&quot;和&quot;A&quot;是不同类型的石头。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: J = &quot;z&quot;, S = &quot;ZZ&quot;</span><br><span class="line">输出: 0</span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">S 和 J 最多含有50个字母。</span><br><span class="line"> J 中的字符不重复。</span><br></pre></td></tr></table></figure><p>思路：</p><p>设置一个map用来存放宝石类型，然后遍历你拥有的石头，如果有那么就增加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(string J, string S)</span></span>&#123;</span><br><span class="line">unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; jewels;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; J.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">jewels[J[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(jewels.<span class="built_in">find</span>(S[i]) != jewels.<span class="built_in">end</span>())&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</p><p>内存消耗：6.4 MB, 在所有 C++ 提交中击败了24.38%的用户</p><p>典型的用空间换时间，使用了unordered_map之后时间大大的减少，但是却使用了大量的内存空间。</p><p><strong>map与unordered_map区别</strong>：</p><p>map是使用红黑树来实现的，并且map内部所有数据在任何时候都是有序的</p><p>unordered_map是基于hash表，数据插入和查找基本都是常数时间， 但是消耗的内存较多。</p><p><strong>Hash表</strong>：</p><p>Hash Table是根据key-value对应关系而进行直接访问的数据结构。记录的存储位置=f(关键字)</p><hr><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">题目链接</a></p><p>题目描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">反转一个单链表。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br><span class="line">进阶:</span><br><span class="line">你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</span><br></pre></td></tr></table></figure><p>思路：</p><p>双指针，一个prev，一个cur，并且使用内存来存储next节点，将cur的next指向prev即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* p = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">递归PPT解释</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Leetcode-Day12&quot;&gt;&lt;a href=&quot;#Leetcode-Day12&quot; class=&quot;headerlink&quot; title=&quot;Leetcode Day12&quot;&gt;&lt;/a&gt;Leetcode Day12&lt;/h2&gt;&lt;h4 id=&quot;宝石与石头&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Leetcode" scheme="https://ywj1.github.io/categories/Leetcode/"/>
    
    
    <category term="leetcode" scheme="https://ywj1.github.io/tags/leetcode/"/>
    
    <category term="链表" scheme="https://ywj1.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>论文常用单词与句子</title>
    <link href="https://ywj1.github.io/2020/09/29/%E8%AE%BA%E6%96%87%E5%B8%B8%E7%94%A8%E5%8D%95%E8%AF%8D%E4%B8%8E%E5%8F%A5%E5%AD%90/"/>
    <id>https://ywj1.github.io/2020/09/29/%E8%AE%BA%E6%96%87%E5%B8%B8%E7%94%A8%E5%8D%95%E8%AF%8D%E4%B8%8E%E5%8F%A5%E5%AD%90/</id>
    <published>2020-09-29T09:53:25.000Z</published>
    <updated>2020-09-29T10:11:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="论文常用单词与句子"><a href="#论文常用单词与句子" class="headerlink" title="论文常用单词与句子"></a>论文常用单词与句子</h2><h4 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h4><p>via    conj. 通过</p><p>low-resolution    n. 低分辨率</p><p>semantically strong feature    特征语义强</p><p>infeasible    adj.不可行的</p><p>spatial    adj.空间的</p><p>practical solution    实际的解决方案</p><p>frame……as……    视作，将这框为</p><p>refreshingly    adv.令人耳目一新地,及其</p><p>lag behind    落后</p><p>pretrain    预训练</p><p>resolution    分辨率(图片的尺寸)</p><p>invariant    不变的</p><p>design defect    设计缺陷</p><p>remarkable    卓越的</p><p>deep convolutional networks(ConvNets)</p><p>without bells and whistles    没有任何技巧</p><p>outperform    超过</p><p>tackle the problem    解决问题</p><p>methodology    方法</p><h4 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h4><p>The goal of this paper is to ……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;论文常用单词与句子&quot;&gt;&lt;a href=&quot;#论文常用单词与句子&quot; class=&quot;headerlink&quot; title=&quot;论文常用单词与句子&quot;&gt;&lt;/a&gt;论文常用单词与句子&lt;/h2&gt;&lt;h4 id=&quot;单词&quot;&gt;&lt;a href=&quot;#单词&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="笔记" scheme="https://ywj1.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://ywj1.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Day11</title>
    <link href="https://ywj1.github.io/2020/09/29/Leetcode-Day11/"/>
    <id>https://ywj1.github.io/2020/09/29/Leetcode-Day11/</id>
    <published>2020-09-29T05:59:24.000Z</published>
    <updated>2020-09-29T06:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-Day11"><a href="#Leetcode-Day11" class="headerlink" title="Leetcode Day11"></a>Leetcode Day11</h2><h4 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h4><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">题目链接</a></p><p>复习题</p><p>非递归方法，内存消耗比较小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur || !st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>( !cur-&gt;right || pre == cur-&gt;right)&#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                pre = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="验证二叉搜素树"><a href="#验证二叉搜素树" class="headerlink" title="验证二叉搜素树"></a>验证二叉搜素树</h4><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">题目链接</a></p><p>题目描述</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，判断其是否是一个有效的二叉搜索树。</span><br><span class="line"></span><br><span class="line">假设一个二叉搜索树具有如下特征：</span><br><span class="line"></span><br><span class="line">节点的左子树只包含小于当前节点的数。</span><br><span class="line">节点的右子树只包含大于当前节点的数。</span><br><span class="line">所有左子树和右子树自身必须也是二叉搜索树。</span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 输入为: [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,null,null,<span class="number">3</span>,<span class="number">6</span>]。</span><br><span class="line">     根节点的值为 <span class="number">5</span> ，但是其右子节点值为 <span class="number">4</span> 。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>思路：</p><p>采用中序遍历的方法，判断下一个节点是否大于前一个节点，如果不是则是错误的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> inorder = (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MIN - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() || root)&#123;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            st.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt;= inorder)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        inorder = root-&gt;val;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Leetcode-Day11&quot;&gt;&lt;a href=&quot;#Leetcode-Day11&quot; class=&quot;headerlink&quot; title=&quot;Leetcode Day11&quot;&gt;&lt;/a&gt;Leetcode Day11&lt;/h2&gt;&lt;h4 id=&quot;二叉树的后序遍历&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="Leetcode" scheme="https://ywj1.github.io/categories/Leetcode/"/>
    
    
    <category term="leetcode" scheme="https://ywj1.github.io/tags/leetcode/"/>
    
    <category term="二叉树" scheme="https://ywj1.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="链表" scheme="https://ywj1.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Day10</title>
    <link href="https://ywj1.github.io/2020/09/28/Leetcode-Day10/"/>
    <id>https://ywj1.github.io/2020/09/28/Leetcode-Day10/</id>
    <published>2020-09-28T01:14:13.000Z</published>
    <updated>2020-09-28T02:33:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-Day10"><a href="#Leetcode-Day10" class="headerlink" title="Leetcode Day10"></a>Leetcode Day10</h2><h4 id="填充每个节点的下一个右侧节点指针II"><a href="#填充每个节点的下一个右侧节点指针II" class="headerlink" title="填充每个节点的下一个右侧节点指针II"></a>填充每个节点的下一个右侧节点指针II</h4><p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">题目链接</a></p><p>题目描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br><span class="line">填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</span><br><span class="line"></span><br><span class="line">初始状态下，所有 next 指针都被设置为 NULL。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line"></span><br><span class="line">你只能使用常量级额外空间。</span><br><span class="line">使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：root = [1,2,3,4,5,null,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</span><br></pre></td></tr></table></figure><p>思路：</p><p>使用层次遍历，每次从右节点开始进入，然后将队列中的数移除指向下一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">queue&lt;Node*&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="keyword">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line">n = n - <span class="number">1</span>;</span><br><span class="line">Node* f = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(f-&gt;left)&#123;</span><br><span class="line">q.<span class="built_in">push</span>(f-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f-&gt;right)&#123;</span><br><span class="line">q.<span class="built_in">push</span>(f-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n)&#123;</span><br><span class="line">f-&gt;next = q.<span class="built_in">front</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">f-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h4><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">题目链接</a></p><p>题目描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">例如，给出</span><br><span class="line"></span><br><span class="line">前序遍历 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>思路:</p><p>具体参考Day04。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">creat</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断是否还需要构造</span></span><br><span class="line">    <span class="keyword">if</span>(preL &gt; preR)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建根节点</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    root-&gt;val = preorder[preL];</span><br><span class="line">    <span class="keyword">int</span> k;<span class="comment">//找出中序遍历的根节点位置</span></span><br><span class="line">    <span class="keyword">for</span>(k = inL; k &lt;= inR; k++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder[preL] == inorder[k])</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> numLeft = k - inL;<span class="comment">//左子树的节点个数</span></span><br><span class="line">    <span class="comment">//左子树的先序区间[preL+1, preL+numLeft], 中序区间是[inL, k-1]</span></span><br><span class="line">    <span class="comment">//返回左子树的根节点地址，赋值给root的左指针</span></span><br><span class="line">    root-&gt;left = <span class="built_in">creat</span>(preorder, inorder, preL+<span class="number">1</span>, preL+numLeft, inL, k<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//右子树的线序区间[preL+numLeft+1, preR], 中序区间[k+1, inR]</span></span><br><span class="line">    <span class="comment">//返回右子树的根节点地址，赋值给root的右指针</span></span><br><span class="line">    root-&gt;right = <span class="built_in">creat</span>(preorder, inorder, preL+numLeft+<span class="number">1</span>, preR, k+<span class="number">1</span>, inR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">creat</span>(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Leetcode-Day10&quot;&gt;&lt;a href=&quot;#Leetcode-Day10&quot; class=&quot;headerlink&quot; title=&quot;Leetcode Day10&quot;&gt;&lt;/a&gt;Leetcode Day10&lt;/h2&gt;&lt;h4 id=&quot;填充每个节点的下一个右侧节点指针I</summary>
      
    
    
    
    <category term="Leetcode" scheme="https://ywj1.github.io/categories/Leetcode/"/>
    
    
    <category term="leetcode" scheme="https://ywj1.github.io/tags/leetcode/"/>
    
    <category term="二叉树" scheme="https://ywj1.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="🗡指offer" scheme="https://ywj1.github.io/tags/%F0%9F%97%A1%E6%8C%87offer/"/>
    
  </entry>
  
</feed>
