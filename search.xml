<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Summary of Transformer used in CV</title>
      <link href="2021/06/02/Summary-of-Transformer-in-CV/"/>
      <url>2021/06/02/Summary-of-Transformer-in-CV/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Transformer In Object Detection</title>
      <link href="2021/05/27/Transformer-In-Object-Detection/"/>
      <url>2021/05/27/Transformer-In-Object-Detection/</url>
      
        <content type="html"><![CDATA[<h1 id="Transformer-in-Object-Detection"><a href="#Transformer-in-Object-Detection" class="headerlink" title="Transformer in Object Detection"></a>Transformer in Object Detection</h1><p>Transformer在NLP中应用很广泛，但是在CV中确实十分少见，究其原因，主要是因为CV中使用的是图像，都是2维的数据，而NLP中是以1维数据为主。因此在ViT之前，CV领域主要是将其思想，self-Attention借用在CNN网络中，即提出了通道注意力等各种各样的注意力（代表性网络是：[SeNet][<a href="https://arxiv.org/abs/1709.01507]等）。随着ViT的出现，Transformer在CV领域如喷泉搬涌出，Transformer在CV中的应用越来越多。这次主要介绍Transformer在目标检测（Object">https://arxiv.org/abs/1709.01507]等）。随着ViT的出现，Transformer在CV领域如喷泉搬涌出，Transformer在CV中的应用越来越多。这次主要介绍Transformer在目标检测（Object</a> Detection）中的应用。主要分为三个部分，首先介绍最基础的<a href="&quot;Transformer&quot;">Transfomer</a>，随后介绍<a href="&quot;DETR&quot;">DETR</a>，最后在DETR中改进的<a href="&quot;Deformable DETR&quot;">Deformable DETR</a>。</p><h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><p>Transformer结构首先在<a href="https://arxiv.org/pdf/1706.03762.pdf">Attention is All You Need</a>中提出，文中主要提出了Transformer模型，构建里序列模型的全局关系，不像RNN一样，需要一个个进行预测，而是可以实现并行化运行。对于直接从事或者学习CV方向的来说，首先我们了解一下什么叫做Embedding（有过NLP方向可以略过此部分）。</p><h3 id="Embedding"><a href="#Embedding" class="headerlink" title="Embedding"></a>Embedding</h3><p><strong>数学角度</strong>：</p><p>​    Embedding实际上是一个映射（mapping），<code>f:x-&gt;y</code>，其中f是一个函数，实现x到y的映射，并且f具有俩个特征：injective（单射性：不同的x映射到不同的y）2.structure-preserving（结构保存，或者说特征保存：如果<code>x1&gt;x2</code>通过f得到的y1,y2满足<code>y1&gt;y2</code>）。因此从数学角度来说，Embedding即找到一个函数，实现<code>x-&gt;y</code>的映射，并且这个函数具有如上所述俩个特征。</p><p><strong>神经网络</strong>：</p><p>​    将离散变量—&gt;连续的变量，减少离散变量的维数，并且在转换之后也可以有意义的表示该变量。Embedding主要有三个目的：</p><ol><li>在embedding空间中查找最领近，在用户推荐系统中这可以根据用户的兴趣进行推荐（后续通过与One-hot进行对比可以理解的更为清楚）</li><li>最为监督性学习任务的输入</li><li>用于可视化不同离散变量之间的关系（这里有一个很好玩的网络，可以用于可视化Embedding，是Tensorflow开发的<a href="https://projector.tensorflow.org/">projector</a>，是一个在线应用程序）</li></ol><p><strong>One-Hot Encoding与Embedding之间的对比</strong>：<br>例如在NLP学习中，有如下的几组词，首先通过One-hot encoding：</p><pre class=" language-lang-C++"><code class="language-lang-C++">words = ['I', 'have', 'an', 'apple']One_hot_words = [[1, 0, 0, 0],                [0, 1, 0, 0],                [0, 0, 1, 0],                [0, 0, 0, 1]]</code></pre><p>从上述的One-hot encoding可以看出每个变量是没有关系的，并且随着words的数量越来越多，One-hot向量的维数也会越来越大，这显然不是我们所希望的。</p><p>因此提出了Embedding，通过压缩向量的维数，使用Embedding neural network和supervised learning（即简易的神经网络）来进行学习，来找到最适合的表述以及挖掘内在联系。如下面的例子（PS：随便举的）</p><pre class=" language-lang-python"><code class="language-lang-python">words = ['I', 'have', 'an', 'apple']Embedding = [[0.84, 0.48],            [0.32, 0.57],            [0.23, -0.43],            [-0.87, -0.94]]//通过计算向量的内积，可以得出不同单词之间的相关度。</code></pre><p>引用：</p><ul><li><a href="https://towardsdatascience.com/neural-network-embeddings-explained-4d028e6f0526">https://towardsdatascience.com/neural-network-embeddings-explained-4d028e6f0526</a></li><li><a href="https://zhuanlan.zhihu.com/p/46016518">https://zhuanlan.zhihu.com/p/46016518</a></li></ul><h3 id="Attention-Is-All-You-Need"><a href="#Attention-Is-All-You-Need" class="headerlink" title="Attention Is All You Need"></a>Attention Is All You Need</h3><h4 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h4><p>如下图可见Transformer的整体架构：</p><p><img src="/2021/05/27/Transformer-In-Object-Detection/Transformer.png" alt="Transformer" style="zoom:80%;"></p><p>模型主要由左边的Encoder和右边的Decoder组成，最终输出预测的序列模型的概率。</p><p>对于早期，处理序列模型，最先想到的是RNN，他的输入是一串Vector Sequence，输出也是另外一串Vector Sequence，但是对于RNN来说是很不好并行化的，因为需要通过前一个字符来预测下一个字符，这个过程是很难并行化的。因此这篇文章提出了self-Attention，使用self-Attention来取代RNN所做的事情。（self-Attention部分会在Encoder部分重点讲述）</p><p><img src="/2021/05/27/Transformer-In-Object-Detection/RNN.png" alt="RNN" style="zoom:80%;"></p><p>接下来根据上述模型顺序进行讲解：（后面会补上代码讲述！）</p><ul><li>Input Embedding</li><li>Encoder</li><li>Decoder</li></ul><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p><img src="/2021/05/27/Transformer-In-Object-Detection/Input-Embedding.png" alt="输入结构"></p><p>由图中可以看到<code>The Sequence input to Encoder = Input Embedding + Positional Encoding</code>，关于Embedding在上面的Embedding中已经讲述了，接下来主要讲解Positional Encoding。</p><h5 id="Positional-Encoding"><a href="#Positional-Encoding" class="headerlink" title="Positional Encoding"></a>Positional Encoding</h5><p><strong>为什么要使用Positional Encoding？</strong></p><p>由于在RNN中，序列处理是有顺序的，因此不需要通过位置编码来确定每个位置的信息，但是在Transformer中，由于使用的并行化，因此一个单词向量对于不同位置的单词向量的效果是相同的（如：在序列”我打了你”中，由于没有位置信息，其中并不能明确主宾关系，无法准确翻译我和你，<font color="red">这只是我的理解，毕竟我对于NLP不太懂</font>，总而言之，就是无法确定不同距离单词向量之间的关系，因为self-Attention关系，每个单词之间效果是相同的）</p><p><strong>Positional Encoding</strong></p><p><em>固定的位置编码（Absolute positional Encoding)</em>：</p><script type="math/tex; mode=display">\left\{\begin{aligned}PE(pos, 2i) = sin(\frac{pos}{10000^{\frac{2i}{d_{model}}}}) \\PE(pos, 2i+1) = cos(\frac{pos}{10000^{\frac{2i}{d_{model}}}}) \\\end{aligned}\right.</script><p>其中i的取值范围是$[0,…,d_{model}/2)$，设计这个公式的优点在于：</p><ul><li>每个位置都有唯一的Positional encoding</li><li>PE能够适应比训练集中更长的数据</li><li>对于不同单词向量的相对位置更好计算</li></ul><p><em>不固定的位置编码（Relative Positional Encoding）</em>：</p><p>即通过训练学习得到Positional Encoding。</p><p>在Transformer这篇文章中，这俩种方法没有很大的区别，因此选用了不固定的Positional Encoding。但是在目标检测中，俩种方法相差还是有的(<a href="https://arxiv.org/pdf/2104.13840.pdf">Twins-SVT</a>)。</p><p><strong>为什么使用element-wise summation 而不是concatenate？</strong></p><h4 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h4><p><img src="/2021/05/27/Transformer-In-Object-Detection/Encoder.png" alt="Encoder"></p><p>如图所示Transformer结构中，主要包括三个部分：</p><ul><li>Multi-Head Attention</li><li>Add&amp;Norm层</li><li>Feed Forward层</li></ul><h5 id="Multi-Head-Attention"><a href="#Multi-Head-Attention" class="headerlink" title="Multi-Head Attention"></a>Multi-Head Attention</h5><p>在介绍Multi-Head Attention之前，首先我们应该知道什么叫做Head Attention。可以看到图中有Q,K,V三个向量，这三个向量是分别通过$XW^q,XW^k,XW^v$来得到的三个向量</p><ul><li>Q：query（to match others）</li><li>K：Key（to be matched）</li><li>V：value（information to be extracted）</li></ul><p>关于self-Attention：</p><ol><li><p>计算Attention: 即使用每个query取对每个key做attention（表示的俩个向量之间有多接近，即通过内积：scaled inner product的方式来进行）$\alpha_{i,j}=q_i*k_j/\sqrt{d}$（d表示的是向量的维度，起到归一化的作用）</p></li><li><p>Softmax: $\alpha_{i,j}=exp(\alpha_{i,j}/\sum_k{\alpha_{i,k}})$表示的当前计算Attention进行softmax取值</p><p><img src="/2021/05/27/Transformer-In-Object-Detection/self-Attention.png" alt="Softmax" style="zoom:50%;"></p></li><li><p>获得该点于全局的关系：$b_i=\sum_k{\alpha_{i,k}*v_k}$</p><p><img src="/2021/05/27/Transformer-In-Object-Detection/self-Attention-Sum.png" alt="Long-Range Dependency" style="zoom:50%;"></p></li></ol><p>使用向量表示：$Attention(Q,K,V) = softmax(\frac{Q·K^T}{\sqrt{d}}V)$,其中$Q∈R^{n×d_k},K∈R^{m×d_k},V∈R^{m×d_v}$，即一个Attention层，将$n×d_k$的序列编码成了一个新的$n×d_v$的序列。</p><p>在此基础之上，文章中提出了Multi-Head Attention：</p><p><img src="/2021/05/27/Transformer-In-Object-Detection/Multi-Head Attention.png" alt="Multi-Head Attention" style="zoom:50%;"></p><script type="math/tex; mode=display">MultiHead(Q,K,V)=Concat(head_1,head_2,...,head_n) \\head_i=Attetnion(Q_i,K_i,V_i)</script><p>对于MultiHead的理解，可以是：对于一个token不同的子空间（一个head），它的注意力机制是不同的，比如拿词义来说，在head1中，表示的是指代关系，在head2中表示的是主谓宾关系。</p><p><font color="blue">那么在图像中，Multihead表示的对于一个图像切片的token，在不同的子空间对于其他切片token的关系不同，比如拿目标检测来说，在head1中表示，token之间是否存在有存在目标，在head2中表示token之间的关系</font>（理解待商榷）</p><h4 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h4><h2 id="DETR"><a href="#DETR" class="headerlink" title="DETR"></a>DETR</h2><h2 id="Deformable-DETR"><a href="#Deformable-DETR" class="headerlink" title="Deformable DETR"></a>Deformable DETR</h2>]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object detection </tag>
            
            <tag> Transformer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trident Network</title>
      <link href="2020/10/26/Trident-Network/"/>
      <url>2020/10/26/Trident-Network/</url>
      
        <content type="html"><![CDATA[<h2 id="Scale-Aware-Trident-Networks-for-Object-Detection-用于物体检测的可感知规模的三叉戟网络"><a href="#Scale-Aware-Trident-Networks-for-Object-Detection-用于物体检测的可感知规模的三叉戟网络" class="headerlink" title="Scale-Aware Trident Networks for Object Detection(用于物体检测的可感知规模的三叉戟网络)"></a>Scale-Aware Trident Networks for Object Detection(用于物体检测的可感知规模的三叉戟网络)</h2><h3 id="初步阅读"><a href="#初步阅读" class="headerlink" title="初步阅读"></a>初步阅读</h3><p><strong>作者写作目的</strong></p><p>scale variation在目标检测中是一个十分重要的问题，因此作者提出了Trident block来进行多尺度特征检测。</p><p><strong>作者新颖的方法</strong></p><p>针对之前Feature Fusion中的一些问题，例如特征不连续等，提出了Trident Network，其实这个的关键在于Trident block，对于一个feature map使用三条支路（不同的带孔卷积）。</p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><h4 id="Trident-Networks"><a href="#Trident-Networks" class="headerlink" title="Trident Networks"></a>Trident Networks</h4><p>作者首先说明三个对于目标检测影响的重要因素：1.downsample rate 2. network depth 3. receptive field。对于第三个作者做了实验来说明该影响，对于大的scale物体，使用dilation大的带孔卷积效果会更好。</p><h5 id="Trident-block"><a href="#Trident-block" class="headerlink" title="Trident block"></a>Trident block</h5><p>于是作者在上述实验的基础之上，提出了Trident block，对于同一个模块，使用不同dilation的带孔卷积，从而达到不同scale的训练，并且针对FPN的feature inconsistency，作者的Trident block使用了uniform representational power。</p><p><img src="/2020/10/26/Trident-Network/network.jpg" alt="avatar"></p><p>并且作者提出了三个策略</p><ol><li>weigh sharing among branches，通过带孔卷积间的权重共享，可以减少参数个数，并且使用一个uniform transformation with the same representational power。</li><li>scale-aware training scheme，对于每个branch设置了不同的范围，之后对于不同的RoI使用不同的branch来进行训练。</li><li>使用middle branch来进行inference。加快了速度。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object detection </tag>
            
            <tag> multi-scale </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFF</title>
      <link href="2020/10/24/AFF/"/>
      <url>2020/10/24/AFF/</url>
      
        <content type="html"><![CDATA[<h2 id="Attention-Feature-Fusion-AFF-注意力机制的特征融合"><a href="#Attention-Feature-Fusion-AFF-注意力机制的特征融合" class="headerlink" title="Attention Feature Fusion(AFF:注意力机制的特征融合)"></a>Attention Feature Fusion(AFF:注意力机制的特征融合)</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><p><strong>作者写作目的</strong></p><p>To better fuse features of inconsistent semantics and scales. 因为之前的feature fusion有三个drawbacks:</p><ol><li>semantic inconsistency(语义不连续，模型通过feature fusion之后会造成语义不连续)</li><li>unsophisticated initial integration(简单的初步整合，对于俩个feature，仅仅通过element-wise summation)</li><li>仅仅对于global feature进行feature fusion，这会造成biased context aggregation scale</li></ol><p><strong>作者新颖之处</strong></p><p>作者基于SENet和SKNet提出了AFF模型，通过结合局部特征和全局特征的attention机制来进行feature fusion。</p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><h4 id="Attention-Feature-Fusion"><a href="#Attention-Feature-Fusion" class="headerlink" title="Attention Feature Fusion"></a>Attention Feature Fusion</h4><h5 id="MS-CAM-model"><a href="#MS-CAM-model" class="headerlink" title="MS_CAM model"></a>MS_CAM model</h5><p>下图是MS_CAM模型：</p><p><img src="/2020/10/24/AFF/MS_CAM.png" alt="avatar"></p><p>MS_CAM采用了bottleneck structure，左边是global feature，右边是local feature，其中左边的global feature与SENet不同之处在于，将SENet的Fully connected layer变为了Point-wise Conv layer，这样的目的是减小了计算量。其中+表示的element-wise summation，✖表示的element-wise multiplication。</p><h5 id="AFF-model"><a href="#AFF-model" class="headerlink" title="AFF model"></a>AFF model</h5><p><img src="/2020/10/24/AFF/AFF.png" alt="avatar"></p><p><img src="/2020/10/24/AFF/function-aff.png" alt="avatar"></p><p>其中Z表示的fused feature，我觉得该feature fusion想法类似于Cross Entropy。（理解起来还挺简单，但是想到是真的难！）对于其中的initial integration仅仅使用了简单的element-wise summation。因此作者在此基础之上又提出了iAFF，其实iAFF就是俩层AFF，对于X,Y在使用一次MS_CAM模型。如图：</p><p><img src="/2020/10/24/AFF/iAFF.png" alt="avatar"></p>]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object detection </tag>
            
            <tag> Feature Fusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConerNet</title>
      <link href="2020/10/23/ConerNet/"/>
      <url>2020/10/23/ConerNet/</url>
      
        <content type="html"><![CDATA[<h2 id="CornerNet-Detecting-Objects-as-Paired-Keypoints-ConerNet-以成对的关键点检测目标"><a href="#CornerNet-Detecting-Objects-as-Paired-Keypoints-ConerNet-以成对的关键点检测目标" class="headerlink" title="CornerNet: Detecting Objects as Paired Keypoints(ConerNet:以成对的关键点检测目标)"></a>CornerNet: Detecting Objects as Paired Keypoints(ConerNet:以成对的关键点检测目标)</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><p><strong>作者写作目的？</strong></p><p>在之前的object detector中，由于anchor boxes的存在，会产生一些问题</p><ol><li>需要产生大量的anchor boxes</li><li>需要调整很多的参数，例如aspect ratios，scale等</li></ol><p>因此作者希望使用一个anchor-free detector来实现目标检测。</p><p><strong>新颖之处</strong></p><p>对于检测object，不像之前那样，需要检测center points，而是进行top-left and bottom-right的检测，并且设计了corner pooling来进行localize corner。作者借鉴了人体姿态估计的思想（embedding vector）。</p>]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object detection </tag>
            
            <tag> anchor-free </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RetinaNet</title>
      <link href="2020/10/18/RetinaNet/"/>
      <url>2020/10/18/RetinaNet/</url>
      
        <content type="html"><![CDATA[<h2 id="Focal-Loss-for-Dense-Object-Detection"><a href="#Focal-Loss-for-Dense-Object-Detection" class="headerlink" title="Focal Loss for Dense Object Detection"></a>Focal Loss for Dense Object Detection</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><h4 id="作者写作的目的"><a href="#作者写作的目的" class="headerlink" title="作者写作的目的"></a>作者写作的目的</h4><p>为了能够使one-stage的准确率能够提升到和two-stage差不多类似的精度，在不丧失速度的前提下。作者觉得这是由于one-stage的正负比例不均匀，导致训练之后的准确率不高。</p><h4 id="作者提出的新颖的方法"><a href="#作者提出的新颖的方法" class="headerlink" title="作者提出的新颖的方法"></a>作者提出的新颖的方法</h4><p>作者提出了一个新的损失函数(Focal Loss)，来进行平衡class imbalance。</p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>由于one-stage并没有像two-stage那样，提出region proposal，因此对于one-stage模型，会产生大量的negative samples，这就会造成class imbalance。class imbalance会造成俩个后果，引用原文：</p><ol><li>training is inefficient as most locations are easy negatives that contribute no useful learning signal.</li><li>en masse, the easy negatives can overwhelm training and lead to degenerate models.</li></ol><p>负样本数量过大，并且都是容易分类的样本，因此模型的优化并不是朝着我们希望的方向。因此本文针对类别不平衡，提出了一个新的loss function(Focal Loss function)。</p><h4 id="RetinaNet"><a href="#RetinaNet" class="headerlink" title="RetinaNet"></a>RetinaNet</h4><h5 id="Focal-Loss-Function"><a href="#Focal-Loss-Function" class="headerlink" title="Focal Loss Function"></a>Focal Loss Function</h5><p>在cross entropy和balanced cross entropy基础之上，作者提出了Focal Loss，it is defined as:</p><script type="math/tex; mode=display">\begin{equation}FL(p_t) =\begin{cases}-\alpha(1-p_t)^{\gamma}log(p_t),& y=1 \\(1-\alpha)(p_t)^{\gamma}log(1-p_t), & y = 0\\\end{cases}\end{equation}</script><p>因为balanced cross entropy能平衡正负样本，但是无法控制easy/hard examples，因此作者提出了Focal Loss，focus training on hard negatives。其中$\gamma$为调制系数(modulating factor)。目的是通过减少易分类样本的权重，从而使模型在训练时候更专注难分类的样本。$\alpha$可以控制正负样本权重。</p><p>对于Focal Loss有俩个重要的性质：</p><ol><li><p>当样本被分错之后，$p_t$很小，因此$(1-p_t)^{\gamma}$趋于1，相比于原来的loss没什么区别，当$p_t$趋于1时候(样本分类正确，且是易分类样本)，参数区域0，对于总的loss贡献很小。</p></li><li><p>$\gamma$增加时候，前面的参数也会增加。</p></li></ol><h5 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h5><p><img src="/2020/10/18/RetinaNet/RetinaNet.jpg" alt="avator"></p><p>使用ResNet+FPN为backbone，在每层的feature map中使用class subnet和box subnet。（具体如图所示）</p>]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object detection </tag>
            
            <tag> one-stage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MobileNetv2</title>
      <link href="2020/10/15/MobileNetv2/"/>
      <url>2020/10/15/MobileNetv2/</url>
      
        <content type="html"><![CDATA[<h2 id="MobileNetV2-Inverted-Residuals-and-Linear-Bottlenecks-MobileNetV2：残差和线性瓶颈"><a href="#MobileNetV2-Inverted-Residuals-and-Linear-Bottlenecks-MobileNetV2：残差和线性瓶颈" class="headerlink" title="MobileNetV2: Inverted Residuals and Linear Bottlenecks(MobileNetV2：残差和线性瓶颈)"></a>MobileNetV2: Inverted Residuals and Linear Bottlenecks(MobileNetV2：残差和线性瓶颈)</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><h4 id="作者写作的目的"><a href="#作者写作的目的" class="headerlink" title="作者写作的目的"></a>作者写作的目的</h4><p>保证模型的accuracy的同时降低模操作和内存消耗，使这个模型更能够部署在Mobile application中</p><h4 id="作者创新的方法"><a href="#作者创新的方法" class="headerlink" title="作者创新的方法"></a>作者创新的方法</h4><p>使用一个Inverted Residuals和Linear Bottlenecks来对原有的MobileNetv1进行改进。</p><h3 id="MobileNetV2"><a href="#MobileNetV2" class="headerlink" title="MobileNetV2"></a>MobileNetV2</h3><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p>MobileNetV2使用Inverted Residuals模块来进行构造网络结构。</p><h5 id="Inverted-Residuals"><a href="#Inverted-Residuals" class="headerlink" title="Inverted Residuals"></a>Inverted Residuals</h5><p>其实这个就是类似于Residuals network中的残差块，都是先用$1\times 1$卷积，使用$3\times 3$，再使用$1\times 1$进行操作，最后使用残差连接，其中不同的点在于残差网络中，先对原有的feature map进行降维，之后进行升维，Inverted Residuals对于feature map进行升维之后进行降维。</p><p><img src="/2020/10/15/MobileNetv2/difference-residual.jpg" alt="avatar"></p><h5 id="Body-Architecture"><a href="#Body-Architecture" class="headerlink" title="Body Architecture"></a>Body Architecture</h5><p><img src="/2020/10/15/MobileNetv2/network.png" alt="avatar"></p><p>本文提出了针对非线性激活函数提出了俩个猜想</p><ol><li>If the mainifold of interest remains non-zeros volume after ReLU transformation, it corresponds to a linear transformation.</li><li>ReLU is capable of preserving complete infromation about the input mainifold, but only if the input mainifold lies in a low-dimensional subspace of the input shape.</li></ol><p>第一个理论理解应该使简单因为$ReLU(x) = max(0,x)$，因此对于大于0的情况下，他就是线性的变化。对于猜想中的mainifold of interest理解成$w\times h\times c$的feature map上的一个点的c维特征，文章使用Linear Bottlenecks来进行说明网络的最后一层不使用ReLU非线性激活函数的原因。因为对于ReLU激活函数会造成信息的损失，但是随着输出维度的增加，信息的丢失会减小，因此使用线性层来减少信息的丢失。</p>]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backbone </tag>
            
            <tag> classfication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MobileNetv1</title>
      <link href="2020/10/15/MobileNetv1/"/>
      <url>2020/10/15/MobileNetv1/</url>
      
        <content type="html"><![CDATA[<h2 id="MobileNets-Efficient-Convolutional-Neural-Networks-for-Mobile-Vision-Applications-MobileNets：用于移动视觉应用的高效卷积神经网络"><a href="#MobileNets-Efficient-Convolutional-Neural-Networks-for-Mobile-Vision-Applications-MobileNets：用于移动视觉应用的高效卷积神经网络" class="headerlink" title="MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications(MobileNets：用于移动视觉应用的高效卷积神经网络)"></a>MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications(MobileNets：用于移动视觉应用的高效卷积神经网络)</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><h4 id="作者写作的目的"><a href="#作者写作的目的" class="headerlink" title="作者写作的目的"></a>作者写作的目的</h4><p>为了能够将深度学习模型应用于移动应用中（例如手机等），因此需要降低模型的复杂度，从而降低对于运算时间和内存的消耗。</p><h4 id="作者的创新点"><a href="#作者的创新点" class="headerlink" title="作者的创新点"></a>作者的创新点</h4><p>使用Depthwise Separable Convolution(深度可分离卷积)和pointwise convolution(逐点卷积)来对传统的卷积操作进行切分，这样子就降低了模型的参数，从而就降低了运算时间和内存消耗。</p><h3 id="MobileNets"><a href="#MobileNets" class="headerlink" title="MobileNets"></a>MobileNets</h3><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p>网络的主要的单元是由Depthwise Separable Convolution和Pointwise Convolution来代替普通卷积来构成的。</p><p><img src="/2020/10/15/MobileNetv1/network.jpg" alt="avatar"></p><p>在每个深度可分离卷积和逐点卷积之后加上BN和ReLU层来进行操作。接下来分别说一说这俩个卷积。</p><h5 id="Depthwise-Separable-Convolution"><a href="#Depthwise-Separable-Convolution" class="headerlink" title="Depthwise Separable Convolution"></a>Depthwise Separable Convolution</h5><p>对于传统的卷积模型，要将$D_K\times D_k\times M$经过卷积成$D_K\times D_K\times N$,要使用(kernel_size = m)的卷积核$m\times m\times M\times N$</p><p>因此对于FLOPs，为$D_K\times D_K\times m\times m\times M\times N$，从理论上来说传统的卷积，是对于一个channel来说有$m\times m\times N$的size的卷积核来与feature map进行卷积操作。</p><p>对于Depthwise Separable Convolution，卷积核的一个channel对应于feature map的一个channel，因此只需要使用$m\times m \times M$ size的卷积核即可进行深度可分离卷积。</p><h5 id="Pointwise-Convolution"><a href="#Pointwise-Convolution" class="headerlink" title="Pointwise Convolution"></a>Pointwise Convolution</h5><p>对于深度可分离卷积操作过后的output我们是没办法改变它的channel的，因此需要逐点卷积来进行channel的改变，因此需要$1\times 1\times M \times N$size的卷积核。</p><p>因此对于上述操作之后，FLOPs为$D_K\times D_K \times m\times m\times M+D_K\times D_K\times M\times N$，因此相对于传统的卷积，FLOPs降低了$m^2$</p><h5 id="Body-Architecture"><a href="#Body-Architecture" class="headerlink" title="Body Architecture"></a>Body Architecture</h5><p>下图是它的模型的整体参数</p><p><img src="/2020/10/15/MobileNetv1/Body Architecture.jpg" alt="avatar"></p><p>对于模型我们引入俩个参数$\alpha$(宽度因子)和$\rho$(分辨率因子)来分别控制输入通道，输出通道的大小和输入图片的size。</p>]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backbone </tag>
            
            <tag> classfication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EfficientDet</title>
      <link href="2020/10/13/EfficientDet/"/>
      <url>2020/10/13/EfficientDet/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> object detection </tag>
            
            <tag> one-stage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EfficientNet</title>
      <link href="2020/10/13/EfficientNet/"/>
      <url>2020/10/13/EfficientNet/</url>
      
        <content type="html"><![CDATA[<h2 id="EfficientNet-Rethinking-Model-Scaling-for-Convolutional-Neural-Networks-EfficientNet-对卷积神经网络缩放的重新思考"><a href="#EfficientNet-Rethinking-Model-Scaling-for-Convolutional-Neural-Networks-EfficientNet-对卷积神经网络缩放的重新思考" class="headerlink" title="EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks(EfficientNet:对卷积神经网络缩放的重新思考)"></a>EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks(EfficientNet:对卷积神经网络缩放的重新思考)</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><p><strong>作者写作目的?</strong></p><p>作者为了能够量化卷积神经网络的缩放（即深度，宽度和图片的解析率）对accuracy造成的影响，作者设计了compound scaling。同时扩展模型的不同维度来增加模型的效率，并保持accuracy增加。</p><p><strong>作者的新颖之处</strong></p><p>我觉得这篇文章的一个亮点，就是设计了compound scaling，将指标进行了量化，在增长accuracy的同时，提高了模型的efficiency。其中EfficientNet只是一个backbone，基于之前的模型设计出来的。</p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>从Net的名字可以看出，这是一个Efficient work，文章的主题思路，设计了一个compound scaling：</p><script type="math/tex; mode=display">depth:d = \alpha^\phi\\width:w=\beta^\phi\\resolution:r=\gamma^\phi\\s.t. \alpha\times\beta^2\times\gamma^2≈2</script><p>而这个compound scaling是从俩个observation中的得出的：</p><ul><li>Observation 1：对于网络的深度，宽度，分辨率中任何维度进行随访都可以提高精度，但是当模型足够大时候，会达到饱和。</li><li>Observation 2：为了追求更好的精度和效率，在缩放时平衡网络所有维度至关重要。</li></ul><p>为了确定constant参数，首先固定$\phi = 1$，进行一个小范围的搜索，最终确定的值为，$\alpha=1.2,\beta=1.1,\gamma=1.15$，之后的EfficientNetB1-B7都是基于该参数进行缩放的。</p><h4 id="EfficientNet"><a href="#EfficientNet" class="headerlink" title="EfficientNet"></a>EfficientNet</h4><p>EfficientNet基于mobile invered bottlenetc MBConv来进行设计，总体架构如下图所示：</p><p><img src="/2020/10/13/EfficientNet/Network.jpg" alt="avatar"></p>]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backbone </tag>
            
            <tag> classification </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSD</title>
      <link href="2020/10/09/SSD/"/>
      <url>2020/10/09/SSD/</url>
      
        <content type="html"><![CDATA[<h2 id="SSD-Single-Shot-MultiBox-Detector"><a href="#SSD-Single-Shot-MultiBox-Detector" class="headerlink" title="SSD: Single Shot MultiBox Detector"></a>SSD: Single Shot MultiBox Detector</h2><h3 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h3><p><strong>作者写作目的？</strong></p><p>加快检测速度，并提高准确率</p><p><strong>新颖的方法？</strong></p><p>SSD提取了不同尺度的特征图来进行预测。</p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>从名字可以读出SSD是一个多框预测算法，并且在准确度和速度上都比YOLO算法要好，SSD相对于YOLO算法有俩个很重要的改变：1. 提取了不同尺度的特征图来进行检测，使用大尺度来检测小物体，小尺度来进行检测大物体。2. 使用Default boxes(anchor boxes)来进行多框预测，并且不同于YOLO算法使用Fully connected，SSD使用$3\times 3$filter来进行结果预测。</p><h4 id="SSD模型"><a href="#SSD模型" class="headerlink" title="SSD模型"></a>SSD模型</h4><p>使用VGG模型(改造过)进行特征提取，在VGG提取之后，继续使用卷积核来继续进行特征图提取，并且对于不同的feature map使用$3\times 3$ filter来进行边界框预测和分类，最后使用NMS算法，删除多余的候选框，最后得到预测的边界框。(如下图)</p><p><img src="/2020/10/09/SSD/model.jpg" alt="avatar"></p><h5 id="SSD模型的改进之处"><a href="#SSD模型的改进之处" class="headerlink" title="SSD模型的改进之处"></a>SSD模型的改进之处</h5><p><strong>用于目标检测的多尺度特征图</strong></p><p>在改造过后的VGGNet使用卷积层继续提取feature map，使用后续的feature map来进行object detection。从而达到了多尺度的效果。(因为使用同一张图的不同feature map可以提高语义分割的质量，这类似于使用不同尺度的相同种类图片)</p><p><strong>使用卷积核来进行目标预测</strong></p><p>如上图所示，不同于YOLO算法在backbone之后使用fully connected layer，SSD使用convolutional layer来进行目标的预测。</p><p><strong>默认框和高宽比</strong></p><p>即使用了anchor boxes在每个特征图中。</p><h5 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h5><p><strong>匹配策略</strong></p><p>对于default boxes和ground truth，使用IoU大于0.5的当作正样本。</p><p><strong>目标函数</strong></p><script type="math/tex; mode=display">L(x,c,l,g) = \frac{1}{N}(L_{conf}(x,c)+\alpha L_{loc}(x,l,g))</script><p>$L_{conf}$表示的分类损失函数，使用softmax loss函数来进行计算</p><script type="math/tex; mode=display">L_{conf}(x,c) = -\sum^N_{i\in Pos(T)}x_{ij}^plog(\hat{c}_i^p)-\sum_{i\in Neg(F)}log(\hat{c}_0^i)</script><script type="math/tex; mode=display">\hat{c}_i^p = \frac{exp(c_i^p)}{\sum_jexp(c_i^j)}​</script><p>$L_{loc}$表示的是回归损失函数，使用Smooth L1函数来进行计算，其中回归表示的边界框损失回归。(详见Faster R-CNN)</p><p><strong>为default boxes选不同的scales和aspect ratios</strong></p><p>scale of default boxes is defined as:</p><script type="math/tex; mode=display">s_k = s_{min} + \frac{s_{max} - s_{min}}{m-1}(k-1), k\in[1,m]</script><p>论文中设置$s_{min} = 0.2, s_{max} = 0.9，m = 6$，并且设置$aspect  ratios\in \{1,2,3,1/2,1/3\} $，对于ration为1的default boxes，继续设置scale为$\sqrt{s_ks_{k+1}}$，对于每个default boxes我们设置中心点为</p><script type="math/tex; mode=display">(\frac{i+0.5}{|f_k|},\frac{j+0.5}{|f_k|})</script><p>$|f_k|$表示的是第k个feature map的面积。</p><p>并且对于VGG中的feature map和最后一层feature map只设置4个default boxes，不设置3，1/3这俩个高宽比。</p><p><strong>设置训练样本</strong></p><p>按照default boxes产生的负样本会有很多，因此会产生正负样本比例失调，从而导致了欠拟合，因此我们将负样本按照IoU从大到小排序，并选取3：1的正负样本比例。</p><p><strong>VGGNet的改进</strong></p><p>将VGG16的全连接层fc6和fc7换成$3\times 3$的卷积层和$1\times 1$的卷积层，并将前一层的池化层使用Atrous Algorithm(带孔卷积\\扩展卷积)。</p>]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object detection </tag>
            
            <tag> one-stage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI在医学应用</title>
      <link href="2020/10/08/AI%E5%9C%A8%E5%8C%BB%E5%AD%A6%E5%BA%94%E7%94%A8/"/>
      <url>2020/10/08/AI%E5%9C%A8%E5%8C%BB%E5%AD%A6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h4><p>two-stage相对于one-stage具有更高的精度，因此使用two-stage来进行检测</p><p>医学图像的正负样本不均衡，使用data augmentation来进行样本扩充。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Object detection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLO9000</title>
      <link href="2020/10/07/YOLO9000/"/>
      <url>2020/10/07/YOLO9000/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>论文常用单词与句子</title>
      <link href="2020/09/29/%E8%AE%BA%E6%96%87%E5%B8%B8%E7%94%A8%E5%8D%95%E8%AF%8D%E4%B8%8E%E5%8F%A5%E5%AD%90/"/>
      <url>2020/09/29/%E8%AE%BA%E6%96%87%E5%B8%B8%E7%94%A8%E5%8D%95%E8%AF%8D%E4%B8%8E%E5%8F%A5%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h2 id="论文常用单词与句子"><a href="#论文常用单词与句子" class="headerlink" title="论文常用单词与句子"></a>论文常用单词与句子</h2><h4 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h4><p>via    conj. 通过</p><p>low-resolution    n. 低分辨率</p><p>semantically strong feature    特征语义强</p><p>infeasible    adj.不可行的</p><p>spatial    adj.空间的</p><p>practical solution    实际的解决方案</p><p>frame……as……    视作，将这框为</p><p>refreshingly    adv.令人耳目一新地,及其</p><p>lag behind    落后</p><p>pretrain    预训练</p><p>resolution    分辨率(图片的尺寸)</p><p>invariant    不变的</p><p>design defect    设计缺陷</p><p>remarkable    卓越的</p><p>deep convolutional networks(ConvNets)</p><p>without bells and whistles    没有任何技巧</p><p>outperform    超过</p><p>tackle the problem    解决问题</p><p>methodology    方法</p><h4 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h4><p>The goal of this paper is to ……</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AugFPN</title>
      <link href="2020/09/27/AugFPN/"/>
      <url>2020/09/27/AugFPN/</url>
      
        <content type="html"><![CDATA[<h2 id="AugFPN-Improving-Multi-scale-Feature-Learning-for-Object-Detection-改进用于目标检测的多尺度特征学习"><a href="#AugFPN-Improving-Multi-scale-Feature-Learning-for-Object-Detection-改进用于目标检测的多尺度特征学习" class="headerlink" title="AugFPN: Improving Multi-scale Feature Learning for Object Detection(改进用于目标检测的多尺度特征学习)"></a>AugFPN: Improving Multi-scale Feature Learning for Object Detection(改进用于目标检测的多尺度特征学习)</h2><h3 id="初步阅读（10-20-）"><a href="#初步阅读（10-20-）" class="headerlink" title="初步阅读（10%-20%）"></a>初步阅读（10%-20%）</h3><p><strong>作者的写作目的？</strong></p><p>为了提高FPN网络的性能，在FPN网络基础之上，对FPN网络进行改进。首先分析FPN网络各个模块的问题（<font color="red">3个问题</font>)(待解决)，之后提出了AugFPN，AugFPN分为三个模块（待解决）</p><p><strong>作者用的方法？</strong></p><p>提出AugFPN网络，AugFPN网络分为三个类别：Consistant Supervision，Residual Feature Augmentation，Soft ROI Selection</p><p><strong>FPN存在的三个问题</strong></p><ol><li>before feature fusion: 对于原图像使用$1\times1$卷积减少通道时候，会减弱图像的多尺度特征表达（水平方向）</li><li>top-down feature fusion: 在特征融合过程中，顶层由于减少了通道，会造成最高层特征图的信息减少（垂直方向）</li><li>after feature fusion: <font color="red">FPN中每个候选区域(ROI)的特征都是根据proposal的尺度来决定相应的特征图从哪一层选择，然而\那些忽略的层也是包含着丰富信息的，它们对最终的分类和回归结果也有着影响。直接忽略了其它层的特征势必会影响到最终的检测结果。</font></li></ol><p><strong>AugFPN三个策略解决问题</strong></p><ol><li>Consistent Supervision</li><li>Residual Feature Augmentation</li><li>Soft RoI Selection</li></ol><hr><h3 id="进一步阅读-20-60"><a href="#进一步阅读-20-60" class="headerlink" title="进一步阅读(20%-60%)"></a>进一步阅读(20%-60%)</h3><h4 id="design-defects"><a href="#design-defects" class="headerlink" title="design defects"></a>design defects</h4><p>文章根据FPN的三个不同阶段的三个缺陷提出了不同的解决方法，最后将这三个方法整合在一起，形成了AugFPN。</p><p>这三个不同阶段分别是特征融合(feature fusion)前，特征融合中，特征融合后</p><p>特征融合前：由于在特征融合之前，对于backbone生成的不同feature map要使用$1\times 1$卷积，将会降低多尺度特征表达(??)，因为没有考虑semantic gap。(？？)使用存在语义差异的特征进行融合，可能会导致次优解。</p><p>特征融合中：对于top-down pathway的feature map和backbone的feature map进行element-wise相加，可能会损失空间解析率和空间细节，因为可能有多个物体存在一个照片中。</p><p>特征融合后：每个目标的proposal都是基于从一个特征层次上汇聚的特征网格进行细化的，这些特征网格是根据proposals的尺度启发式地选择的。但是，来自其他级别的被忽略的特性可能对对象分类或回归有益。考虑到这个问题，PANet集合了所有金字塔层的RoIs特征，并将它们以max操作方式融合，然后将它们与独立的全连接层融合。然而，max融合会忽略响应较小的特性，而这些特性可能也很有帮助，并且仍然不能充分利用其他级别的特性。同时，额外的全连通层显著增加了模型参数（不太懂，只是翻译）</p><h4 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h4><p><img src="/2020/09/27/AugFPN/architecture.jpg" alt="avatar"></p><h5 id="Consistent-Supervision"><a href="#Consistent-Supervision" class="headerlink" title="Consistent Supervision"></a>Consistent Supervision</h5><p>对融合后的特征图M2~M5进行监督，具体方法使对RPN网络得到的每一个候选区域分别映射到M2~M5上的到相应的feature map，对feature map进行分类和回归，这样得到一个损失函数，将这个损失函数和网络本身的损失进行一个加权求和。</p><h5 id="Residual-Feature-Augmentation"><a href="#Residual-Feature-Augmentation" class="headerlink" title="Residual Feature Augmentation"></a>Residual Feature Augmentation</h5><p>在融合之前使用$1\times 1$的卷积进行特征降维，会造成信息损失，因为C5的信息使没有损失的，因此将C5的特征融合到M5中，减少了信息损失。</p><h5 id="Soft-RoI-Selection"><a href="#Soft-RoI-Selection" class="headerlink" title="Soft RoI Selection"></a>Soft RoI Selection</h5>]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object detection </tag>
            
            <tag> Feature Fusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPN</title>
      <link href="2020/09/26/FPN/"/>
      <url>2020/09/26/FPN/</url>
      
        <content type="html"><![CDATA[<h2 id="Feature-Pyramid-Networks-for-Object-Detection-用于目标检测的特征金字塔网络"><a href="#Feature-Pyramid-Networks-for-Object-Detection-用于目标检测的特征金字塔网络" class="headerlink" title="Feature Pyramid Networks for Object Detection(用于目标检测的特征金字塔网络)"></a>Feature Pyramid Networks for Object Detection(用于目标检测的特征金字塔网络)</h2><h3 id="初步阅读-10-40"><a href="#初步阅读-10-40" class="headerlink" title="初步阅读(10%-40%)"></a>初步阅读(10%-40%)</h3><p><strong>作者的写作目的是什么？</strong></p><p>为了解决目标检测算法在处理多尺度变化问题时候的不足，因为Faster R-CNN, Fast R-CNN都是基于单个高层特征（即通过CNN提取后的特征图）来进行目标检测的，这种方法对于小物体不是特别友好（因为提取之后的特征图语义特征比较强，分辨率比较低）因此对于小物体定位并不是很好，因此设计出来特征金字塔来进行特征的提取，使不同尺度的特征具有较强的语义信息。</p><p><strong>作者提出的方法？</strong></p><p>作者提出了FPN(Feature Pyramid Network)来构建特征金字塔，由于现有的特征金字塔网络回答来极大的计算量和内存需求。</p><p>FPN网络有俩个层次构成，一个是自下而上的过程，另一个是自顶向下(top-down architecture)和侧向连接(lateral connections)</p><p><img src="/2020/09/26/FPN/Network.jpg" alt="avatar"></p><hr><h3 id="进一步阅读-40-80"><a href="#进一步阅读-40-80" class="headerlink" title="进一步阅读(40%-80%)"></a>进一步阅读(40%-80%)</h3><p>特征金字塔是CV中常用的技巧，主要目的是能够让网络识别不同尺度中的目标，使网络具有尺度不变性(scale-invariant)。但是随着DL的应用，feature pyramid使用的比较少。</p><ul><li>首先因为CNN就具有较强的robust再尺度改变的情况下</li><li>在DL中使用特征金字塔，会产生很大的内存开销和更长的运算时间，在实践中基本只会在测试中使用，这就会造成train/test不连续。</li></ul><h4 id="CNN提取图像特征的性质"><a href="#CNN提取图像特征的性质" class="headerlink" title="CNN提取图像特征的性质"></a>CNN提取图像特征的性质</h4><p>我们知道CNN使用Conv/Pooling来操作图像，不同深度的layer会产生不同的feature map和spatial dimension，深层的feature map具有更高的语义特征（semantically strong features）和低分辨率（low-resoltion），底层的feature map则相反。因此该文章的目的使通过结合不同的feature map形成一个在不同尺度下有强语义特征的图像。</p><p>对比不同的Feature Pyramid:</p><p><img src="/2020/09/26/FPN/Pyramid-feature.png" alt="avatar"></p><p>(a): 将图像做成金字塔，分别使用一个NN来进行预测，计算量很大(HOG)</p><p>(b): 只在最后一层的feature map来进行预测，只在single scale(faster R-CNN等)</p><p>(c): 将各个layer的输出feature map堪称feature pyramid来进行(SSD)</p><p>(d): 本文的做法，对于不同层级的feature map进行merge，使每个level的语义信息比较强。</p><h4 id="FPN具体实现"><a href="#FPN具体实现" class="headerlink" title="FPN具体实现"></a>FPN具体实现</h4><p><strong>Bottom-up pathway</strong>: 就是一个前向传播，相当于一个backbone，进行特征的提取。</p><p><strong>Top-down pathway and lateral connection</strong>：将上层的feature map进行upsamling（高层的feature map有更强的语义特征，通过upsampling变成有更高分辨率），并且与bottom-up获</p><p>得feature map（使用$1\times 1$卷积改变通道）进行lateral connection进行增强。如下图所示：</p><p><img src="/2020/09/26/FPN/lateral-connection.png" alt="avatar"></p><p>高层的feature map经过upsampling和横向的bottom-up的feature map进行element-wise的相加。</p><p>并且为了减少上采样的混叠效果(reduce the aliasing effect of upsampling)，对于每个merged map使用一个$3\times 3$卷积来进行处理。</p><p>下面使tensorflow实现：</p><pre class=" language-lang-python"><code class="language-lang-python">import  tensorflow as tffrom    tensorflow.keras import layersclass FPN(tf.keras.Model):    def __init__(self, out_channels=256, **kwargs):        '''        Feature Pyramid Networks        Attributes        ---            out_channels: int. the channels of pyramid feature maps.        '''        super(FPN, self).__init__(**kwargs)        self.out_channels = out_channels        #lateral connection        self.fpn_c2p2 = layers.Conv2D(out_channels, (1, 1),                                       kernel_initializer='he_normal', name='fpn_c2p2')        self.fpn_c3p3 = layers.Conv2D(out_channels, (1, 1),                                       kernel_initializer='he_normal', name='fpn_c3p3')        self.fpn_c4p4 = layers.Conv2D(out_channels, (1, 1),                                       kernel_initializer='he_normal', name='fpn_c4p4')        self.fpn_c5p5 = layers.Conv2D(out_channels, (1, 1),                                       kernel_initializer='he_normal', name='fpn_c5p5')        #top-down pathway        self.fpn_p3upsampled = layers.UpSampling2D(size=(2, 2), name='fpn_p3upsampled')        self.fpn_p4upsampled = layers.UpSampling2D(size=(2, 2), name='fpn_p4upsampled')        self.fpn_p5upsampled = layers.UpSampling2D(size=(2, 2), name='fpn_p5upsampled')        #减少upsampling的混叠效果        self.fpn_p2 = layers.Conv2D(out_channels, (3, 3), padding='SAME',                                     kernel_initializer='he_normal', name='fpn_p2')        self.fpn_p3 = layers.Conv2D(out_channels, (3, 3), padding='SAME',                                     kernel_initializer='he_normal', name='fpn_p3')        self.fpn_p4 = layers.Conv2D(out_channels, (3, 3), padding='SAME',                                     kernel_initializer='he_normal', name='fpn_p4')        self.fpn_p5 = layers.Conv2D(out_channels, (3, 3), padding='SAME',                                     kernel_initializer='he_normal', name='fpn_p5')        self.fpn_p6 = layers.MaxPooling2D(pool_size=(1, 1), strides=2, name='fpn_p6')    def call(self, inputs, training=True):        C2, C3, C4, C5 = inputs        P5 = self.fpn_c5p5(C5)        P4 = self.fpn_c4p4(C4) + self.fpn_p5upsampled(P5)        P3 = self.fpn_c3p3(C3) + self.fpn_p4upsampled(P4)        P2 = self.fpn_c2p2(C2) + self.fpn_p3upsampled(P3)        # Attach 3x3 conv to all P layers to get the final feature maps.        P2 = self.fpn_p2(P2)        P3 = self.fpn_p3(P3)        P4 = self.fpn_p4(P4)        P5 = self.fpn_p5(P5)        # subsampling from P5 with stride of 2.        P6 = self.fpn_p6(P5)        return [P2, P3, P4, P5, P6]    def compute_output_shape(self, input_shape):        C2_shape, C3_shape, C4_shape, C5_shape = input_shape        C2_shape, C3_shape, C4_shape, C5_shape = \            C2_shape.as_list(), C3_shape.as_list(), C4_shape.as_list(), C5_shape.as_list()        C6_shape = [C5_shape[0], (C5_shape[1] + 1) // 2, (C5_shape[2] + 1) // 2, self.out_channels]        C2_shape[-1] = self.out_channels        C3_shape[-1] = self.out_channels        C4_shape[-1] = self.out_channels        C5_shape[-1] = self.out_channels        return [tf.TensorShape(C2_shape),                tf.TensorShape(C3_shape),                tf.TensorShape(C4_shape),                tf.TensorShape(C5_shape),                tf.TensorShape(C6_shape)]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object detection </tag>
            
            <tag> Feature Fusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLOv1</title>
      <link href="2020/09/22/YOLOv1/"/>
      <url>2020/09/22/YOLOv1/</url>
      
        <content type="html"><![CDATA[<h2 id="You-Only-Look-Once-Unified-Real-Time-Object-Detection-统一，实时的目标检测"><a href="#You-Only-Look-Once-Unified-Real-Time-Object-Detection-统一，实时的目标检测" class="headerlink" title="You Only Look Once: Unified, Real-Time Object Detection(统一，实时的目标检测)"></a>You Only Look Once: Unified, Real-Time Object Detection(统一，实时的目标检测)</h2><h4 id="初步阅读-10-20"><a href="#初步阅读-10-20" class="headerlink" title="初步阅读(10%-20%)"></a>初步阅读(10%-20%)</h4><p><strong>作者写作目的？</strong></p><p>因为two-stage的目标检测耗时长，并且难训练（因为每个部分是独立的），无法做到实时的检测，因此作者提出了one-stage的算法Yolo。</p><p><strong>作者提出新的方法？</strong></p><p>作者将目标检测视为回归问题，使用一个整合的网络，来进行目标检测的训练，最后输出位置，类别等信息。</p><h4 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h4><p><strong>YOLO算法的优势</strong></p><ol><li>faster</li><li>reason globally about the image：在预测图片时候，可以分析全局的图像，不像two-stage那样，只分析region proposal</li><li>learn the generalizable representations of object：学习概述的特征，可以用于艺术的识别</li></ol><p><strong>YOLO模型的框架</strong></p><p><img src="/2020/09/22/YOLOv1/YOLOv1.png" alt="The architecture"></p><p>输入resize: $448\times 448\times 3$</p><p>输出: $7\times 7\times 30$</p><p>其中输出为$7\times 7$表示的是将图像分为$7\times 7$的网格，最后30分为20和10，10为俩个bounding box(坐标和confidence: 表示是否是物体)，20为一个20个类别。</p><p>bounding box: 四个坐标(x,y,w,h), confidence表示该边界框是否包含目标，$confidence = Pr(object)*IOU_{pred}^{truth}$</p><p>激活函数使用Leaky relu函数来进行</p><p><img src="/2020/09/22/YOLOv1/loss_function.png" alt="loss function"></p><p>其中$\lambda_{coord} = 5, \lambda_{noobj} = 0.5$</p><p><strong>YOLO的缺点</strong></p><p>对于小物体效果不好，并且一个网格中只能预测了俩个框，并且只属于一类。</p>]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object detection </tag>
            
            <tag> one-stage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何写学术论文</title>
      <link href="2020/09/21/%E5%A6%82%E4%BD%95%E5%86%99%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"/>
      <url>2020/09/21/%E5%A6%82%E4%BD%95%E5%86%99%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="如何书写学术论文（学术论文-70-思考-计划-30-写作-修改）"><a href="#如何书写学术论文（学术论文-70-思考-计划-30-写作-修改）" class="headerlink" title="如何书写学术论文（学术论文 = 70%思考/计划+30%写作/修改）"></a>如何书写学术论文（学术论文 = 70%思考/计划+30%写作/修改）</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>首先有个好的idea（标题很重要）<ul><li>寻找idea的几种思路（全新的发现，新的方法，新理论或者新模型，新应用，改进原有的方法获得更好的性能）后俩者比较容易</li><li>多读文献多思考（必须多看，才有想法，才会对这一块了解）</li></ul></li><li>想好文章的核心观点</li><li>构思论文的大框架</li><li>提前整理好数据</li><li>论文写作和修改<ul><li>多英文文献时候（作者是老外），记录好的句型和好的词汇（修饰词和专业术语）</li><li>Grammy插件</li></ul></li><li>投稿</li></ol><h3 id="如何思考"><a href="#如何思考" class="headerlink" title="如何思考"></a>如何思考</h3><p><strong>画出你的研究（Picturing your research）</strong>：</p><ol><li><p>what？ </p><ul><li>main research question文章主要讲的是什么</li><li>Disciplines 研究问题涵盖的所有领域或者学科</li></ul></li><li><p>why？</p><ul><li>Reasons 为什么做这个研究（创新点是什么）Most important</li></ul></li><li>how？<ul><li>Methods 如何去解决这个问题</li></ul></li></ol><h3 id="书写方法"><a href="#书写方法" class="headerlink" title="书写方法"></a>书写方法</h3><h5 id="引言部分"><a href="#引言部分" class="headerlink" title="引言部分"></a>引言部分</h5><p>找十篇相关文献，研究写作思路，之后构思自己的研究思路，在进行模仿写作。</p><ul><li>第一段介绍课题背景或者起源</li><li>第二段介绍前辈的研究动态，引用大量文献（这个一定要自我整理）</li><li>总结自己的研究，主要解决的是什么问题，在哪些方面做出贡献等</li></ul><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p>标题：有一个简明扼要并且具有吸引力的标题</p><hr><h2 id="如何写好论文和评审（笔记）"><a href="#如何写好论文和评审（笔记）" class="headerlink" title="如何写好论文和评审（笔记）"></a>如何写好论文和评审（笔记）</h2><h3 id="如何写好Paper"><a href="#如何写好Paper" class="headerlink" title="如何写好Paper"></a>如何写好Paper</h3><ol><li>首先确定自己的主题</li><li>简单介绍其他方法，为什么不够好</li><li>介绍你的方法，与其他方法比较，优势在哪里</li><li>最后，介绍相关工作</li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文书写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建博客</title>
      <link href="2020/09/21/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>2020/09/21/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>当hexo g -d发生以下错误时候</p><p><img src="/2020/09/21/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/error.png" alt="avatar"></p><p>使用以下命令可以解决</p><pre><code>git config --global user.email &quot;you@example.com&quot; git config --global user.name &quot;Your Name&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文进度</title>
      <link href="2020/09/19/%E8%AE%BA%E6%96%87%E8%BF%9B%E5%BA%A6/"/>
      <url>2020/09/19/%E8%AE%BA%E6%96%87%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h3><p>PS：</p><ul><li>10%-20%: abstract, figure and conclusion(问自己作者的目的，新颖的方法是什么)</li><li>20%-40%：新颖的方法是什么大概的步骤</li><li>40%-60%：文章使用方法的具体步骤</li><li>60%-80%：开代码+写blog 理清文章</li><li>80%-100%：文章实验看看</li></ul><div class="table-container"><table><thead><tr><th>Source</th><th>10%-20%</th><th>20%-40%</th><th>40%-60%</th><th>60%-80%</th><th>80%-100%</th></tr></thead><tbody><tr><td>Feature Pyramid Networks for Object Detection</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td><td></td></tr><tr><td>AugFPN: Improving Multi-scale Feature Learning for Object Detection</td><td>✔</td><td>✔</td><td></td><td></td><td></td></tr><tr><td>Bridging the Gap Between Anchor-based and Anchor-free Detection via Adaptive Training Sample Selection</td><td>✔</td><td></td><td></td><td></td><td></td></tr><tr><td>CentripetalNet: Pursuing High-quality Key-point Pairs for Object Detection</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Few-Shot Object Detection with Attention-RPN and Multi-Relation Detector</td><td>✔</td><td></td><td></td><td></td><td></td></tr><tr><td>Multi-task Collaborative Network for Joint Referring Expression Comprehension and Segmentation</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Hit-Detector: Hierarchical Trinity Architecture Search for Object Detection</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>SSD: Single Shot MultiBox Detector</td><td>✔</td><td>✔</td><td>✔</td><td></td><td></td></tr><tr><td>You Only Look Once:Unified, Real-Time Object Detection</td><td>✔</td><td></td><td></td><td></td><td></td></tr><tr><td>YOLO9000: Better, Faster, Stronger</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>YOLOv3: An Incremental Improvement</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications</td><td>✔</td><td>✔</td><td>✔</td><td></td><td></td></tr><tr><td>MobileNetV2 Inverted Residuals and Linear Bottlenecks</td><td>✔</td><td>✔</td><td>✔</td><td></td><td></td></tr><tr><td>Focal Loss for Dense Object Detection</td><td>✔</td><td>✔</td><td></td><td></td><td></td></tr><tr><td>EfficientDet Scalable and Efficient Object Detection</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CenterNet: Keypoint Triplets for Object Detection</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Scale-Aware Trident Networks for Object Detection</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Objects as Points</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CornerNet Detecting Objects as Paired Keypoints</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><h3 id="医学论文"><a href="#医学论文" class="headerlink" title="医学论文"></a>医学论文</h3><div class="table-container"><table><thead><tr><th>Source</th><th>10%-20%</th><th>20%-40%</th><th>40%-60%</th><th>60%-80%</th><th>80%-100%</th></tr></thead><tbody><tr><td>Artificial Intelligence (AI) Assisted MRI Image Fusion Technique in Preoperative Evaluation of a Pelvic Bone Osteosarcoma</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>MSFCN-multiple supervised fully convolutional networks for the osteosarcoma segmentation of CT images</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Multiple supervised residual network for osteosarcoma segmentation in CT images</td><td>✔</td><td>✔</td><td>✔</td><td></td><td></td></tr><tr><td>Deep Learning-Based Multi-Omics</td><td></td><td></td><td></td><td></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Plan </tag>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode--2020.9</title>
      <link href="2020/09/18/Leetcode-2020-9/"/>
      <url>2020/09/18/Leetcode-2020-9/</url>
      
        <content type="html"><![CDATA[<h2 id="Leetcode—2020-9"><a href="#Leetcode—2020-9" class="headerlink" title="Leetcode—2020.9"></a>Leetcode—2020.9</h2><h3 id="Day01"><a href="#Day01" class="headerlink" title="Day01"></a>Day01</h3><p><a href="https://leetcode-cn.com/problems/permutations/"><strong>题目链接</strong></a></p><p><strong>题目介绍</strong></p><pre class=" language-lang-python"><code class="language-lang-python">给定一个 没有重复 数字的序列，返回其所有可能的全排列。示例:输入: [1,2,3]输出:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre><p><strong>题目思路</strong>：</p><p>首先这是一个树，每个位置可填入的不同的数字就构成了一个树，然后采用深度遍历方法就可以实现这个算法。</p><ol><li>定义递归函数back(first, output)，从左到右来填到first这个位置，并且当前排列是output</li><li>数组长度是n，如果first == n即最后一个位置，那么就输出当前排列，如果first &lt; n，那么就要在first这里填入需要填的数，然后使用递归函数back(first+1, output)。<ul><li>在first &lt; n的时候，在first处填入这个数，我们可以使用交换法来进行，这样子就节省了一部分数据空间，通过对于输入的数组nums[]，其中nums[0,first-1]是已经填过的，nums[first, n-1]是没有的，那么就使用这里的数来进行填充，知道最后完成，并且回溯数组。</li></ul></li></ol><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    void backtrack(vector<vector<int>>& res, vector<int>& output, int first, int len)&#123;        // 所有数都填完了        if (first == len) &#123;            res.emplace_back(output);            return;        &#125;        for (int i = first; i < len; ++i) &#123;            // 动态维护数组            swap(output[i], output[first]);            // 继续递归填下一个数            backtrack(res, output, first + 1, len);            // 撤销操作            swap(output[i], output[first]);        &#125;    &#125;    vector<vector<int>> permute(vector<int>& nums) &#123;        vector<vector<int> > res;        backtrack(res, nums, 0, (int)nums.size());        return res;    &#125;&#125;;</code></pre><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def permute(self, nums: List[int]) -> List[List[int]]:        self.res = []        check = [0 for i in range(len(nums))]        self.backtrack([], nums, check)        return self.res    def backtrack(self, sol, nums, check):        if len(sol) == len(nums):            self.res.append(sol)            return        for i in range(len(nums)):            if check[i] == 1:                continue            check[i] = 1            self.backtrack(sol+[nums[i]], nums, check)            check[i] = 0</code></pre><hr><p><a href="https://leetcode-cn.com/problems/permutations-ii/"><strong>题目链接</strong></a></p><p><strong>题目介绍</strong></p><pre><code>给定一个可包含重复数字的序列，返回所有不重复的全排列。示例:输入: [1,1,2]输出:[  [1,1,2],  [1,2,1],  [2,1,1]]</code></pre><p><strong>思路</strong></p><p>这是上题的加深层次，我们设置一个vis向量来存放该数是否被访问过。并且在上题的思路下，增加一个剪枝的条件。</p><pre class=" language-lang-c++"><code class="language-lang-c++">if (vis[i] || (i > 0 && nums[i] == nums[i - 1] && !vis[i - 1])) &#123;                continue;            &#125;</code></pre><pre class=" language-lang-c++"><code class="language-lang-c++">class Solution &#123;    vector<int> vis;public:    void backtrack(vector<int>& nums, vector<vector<int>>& ans, int idx, vector<int>& perm) &#123;        if (idx == nums.size()) &#123;            ans.emplace_back(perm);            return;        &#125;        for (int i = 0; i < (int)nums.size(); ++i) &#123;            if (vis[i] || (i > 0 && nums[i] == nums[i - 1] && !vis[i - 1])) &#123;                continue;            &#125;            perm.emplace_back(nums[i]);            vis[i] = 1;            backtrack(nums, ans, idx + 1, perm);            vis[i] = 0;            perm.pop_back();        &#125;    &#125;    vector<vector<int>> permuteUnique(vector<int>& nums) &#123;        vector<vector<int>> ans;        vector<int> perm;        vis.resize(nums.size());        sort(nums.begin(), nums.end());        backtrack(nums, ans, 0, perm);        return ans;    &#125;&#125;;</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>模板</strong>：</p><pre><code>递归函数：    if条件成立:        push_back(output)        return;    循环：        剪枝条件        填入数字(swap)        递归函数        撤销(swap)</code></pre><hr><h3 id="Day02"><a href="#Day02" class="headerlink" title="Day02"></a>Day02</h3><h4 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h4><p><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">题目链接</a></p><p>题目描述：</p><pre class=" language-lang-python"><code class="language-lang-python">计算给定二叉树的所有左叶子之和。示例：    3   / \  9  20    /  \   15   7在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</code></pre><p>思路：</p><p>因为是左叶子之和，因此判断该节点是否是左叶子，如果是就存入。</p><pre class=" language-lang-c++"><code class="language-lang-c++">//递归方法class Solution &#123;public:    int sumOfLeftLeaves(TreeNode* root) &#123;        if (root == NULL)&#123;            return 0;        &#125;        int sum = 0;        if(root->left != NULL && root->left->left == NULL && root->left->right == NULL)&#123;//判断节点是否左叶子节点            sum = root->left->val;        &#125;        return sum + sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);    &#125;&#125;;</code></pre><pre class=" language-lang-c++"><code class="language-lang-c++">//非递归方法class Solution &#123;public:    int sumOfLeftLeaves(TreeNode* root) &#123;        stack<TreeNode*> st;        if (root == NULL) return 0;        st.push(root);        int result = 0;        while (!st.empty()) &#123;            TreeNode* node = st.top();            st.pop();            if (node->left != NULL && node->left->left == NULL && node->left->right == NULL) &#123;                result += node->left->val;            &#125;            if (node->right) st.push(node->right);            if (node->left) st.push(node->left);        &#125;        return result;    &#125;&#125;;</code></pre><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>树的四种遍历方法：</p><ul><li><p>前序遍历：根左右</p><pre class=" language-lang-c++"><code class="language-lang-c++">//递归方法void preorder(TreeNode* root, vector<int>& data)&#123;    if(root)&#123;        data.push_back(root->val);        preorder(root->left,data);        preorder(root->right,data);    &#125;&#125;vector<int> preorderTraversal(TreeNode* root) &#123;        vector<int> data;        if(root)&#123;            preoder(root,data);        &#125;        return data;    &#125;//非递归方法 使用栈来储存节点vector<int> preorderTraversal(TreeNode* root)&#123;    vector<int> data;    stack<TreeNode*> st;    while(root || !st.empty())&#123;        while(root)&#123;            data.push_back(root->val);            st.push(root);            root = root->left;        &#125;        root = st.top();        st.pop();        root = root->right;    &#125;    return data;&#125;</code></pre></li><li><p>中序遍历：左根右</p><pre class=" language-lang-C++"><code class="language-lang-C++">//递归方法vector<int> inorderTraversal(TreeNode* root, vector<int>& data;)&#123;    if(root)&#123;        inorderTraversal(root->left, data);        data.push_back(root->val);        inorderTraversal(root->right, data);    &#125;    return data;&#125;//非递归方法 使用栈来存储节点vector<int> inorderTraversal(TreeNode* root)&#123;    stack<TreeNode* > st;    vector<int> data;    while(root || !st.empty())&#123;        while(root)&#123;            st.push_back(root);            root = root->left;        &#125;        root = st.top();        st.pop();        data.push_back(root->val);        root = root->right    &#125;&#125;</code></pre></li><li><p>后序遍历：左右根</p><pre class=" language-lang-C++"><code class="language-lang-C++">//递归方法vector<int> postorderTraversal(TreeNode* root, vector<int>& data)&#123;        if(root)&#123;            posorder(root->left,data);            posorder(root->right,data);            data.push_back(root->val);        &#125;        return data;    &#125;//非递归方法vector<int> postorderTraversal(TreeNode* root)&#123;    stack<TreeNode*> st;    TreeNode* cur = root;    TreeNode* pre = NULL;    while(cur || !st.empty())&#123;        while(cur)&#123;            st.push(cur);            cur = cur->left;        &#125;        cur = st.top();        //判断右子树是否有节点        if(!cur->right || pre == cur->right)&#123;            st.pop();            data.push_back(cur->val);            pre = cur;            cur = NULL;        &#125;else&#123;            cur = cur->right;            pre = NULL;        &#125;    &#125;    return data;&#125;</code></pre></li><li><p>层次遍历：一层层走，BFS</p><pre class=" language-lang-C++"><code class="language-lang-C++">vector<vector<int>> levelOrder(TreeNode* root)&#123;    vector<vector<int>> data;    queue<TreeNode*> q;    if(root == NULL)        return &#123;&#125;;    else        q.push(root);    while(!q.empty())&#123;        vector<int> leveldata;        int count = q.size();        while(count--)&#123;            TreeNode* node = q.front();            q.pop();            leveldata.push_back(node->val);            if(node->left)&#123;                q.push(node->left);            &#125;            if(node->right)&#123;                q.push(node->right);            &#125;        &#125;        data.push_back(leveldata);    &#125;    return data;&#125;</code></pre></li></ul><hr><h3 id="Day03"><a href="#Day03" class="headerlink" title="Day03"></a>Day03</h3><ul><li><h4 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h4><p><a href="https://leetcode-cn.com/problems/subsets/">题目链接</a></p><p>题目描述</p><p>```python<br>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p></li></ul><p>  输入: nums = [1,2,3]<br>  输出:<br>  [<br>    [3],<br>    [1],<br>    [2],<br>    [1,2,3],<br>    [1,3],<br>    [2,3],<br>    [1,2],<br>    []<br>  ]</p><pre><code>  思路：[**转载自代码随想录**](https://leetcode-cn.com/problems/subsets/solution/78-zi-ji-hui-su-sou-suo-fa-jing-dian-ti-mu-xiang-2/)  求子集问题和 求组合组合和分割问题又不一样了， 如何把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是找树的叶子节点，而子集问题是找树的所有节点！  取子集也是，其实也是一种组合位置，因为它的集合是无序的，子集&#123;1,2&#125; 和 子集&#123;2,1&#125;是一样的。 那么既然是无序，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！  那有同学问题，什么时候，for可以从0开始，求排列问题的时候，就要从0开始，因为集合是有序的，&#123;1, 2&#125; 和&#123;2, 1&#125;是两个集合。  来看一下我总结的回溯模板来：      backtracking() &#123;          if (终止条件) &#123;              存放结果;          &#125;          for (选择：选择列表（可以想成树中节点孩子的数量）) &#123;              递归，处理节点;              backtracking();              回溯，撤销处理结果          &#125;      &#125;  首先是终止条件，终止条件，就是startIndex已经大于数组的长度了，就是终止了，代码如下:  ```c++  if (startIndex &gt;= nums.size()) &#123;      return;  &#125;</code></pre><p>  但是，要明确的是，求取子集问题，其实没有必要加终止条件，因为子集就是要遍历整个一棵树，不需要任何剪枝！</p><p>  大家一会看到下面整体代码的时候就知道了。</p><p>  然后就是看如何写for循环，因为求子集也是无序的，所以for循环要从startIndex开始！</p><p>  代码如下：</p><pre class=" language-lang-C++"><code class="language-lang-C++">  for (int i = startIndex; i < nums.size(); i++) &#123;  &#125;</code></pre><p>  接下来就是递归与回溯，定一个vector<int> path，用来收集子集的元素，在回溯的时候还要弹出，backtracking每次调用自己的时候，记着要从i+1 开始，代码如下：</int></p><pre class=" language-lang-C++"><code class="language-lang-C++">  for (int i = startIndex; i < nums.size(); i++) &#123;      path.push_back(nums[i]);      backtracking(nums, i + 1);      path.pop_back();  &#125;</code></pre><p>  重点代码分析完之后，整体代码如下：</p><p>  可以发现我在backtracking里并没有写终止条件，因为本来我们就要遍历整颗树。</p><p>  有的同学可能担心会不会无限递归？ 并不会，因为每次递归的下一层就是从i+1开始的。</p><pre class=" language-lang-c++"><code class="language-lang-c++">  class Solution &#123;  private:      vector<vector<int>> result;      vector<int> path;      void backtracking(vector<int>& nums, int startIndex) &#123;          result.push_back(path);          for (int i = startIndex; i < nums.size(); i++) &#123;              path.push_back(nums[i]);              backtracking(nums, i + 1);              path.pop_back();          &#125;      &#125;  public:      vector<vector<int>> subsets(vector<int>& nums) &#123;          result.clear();          path.clear();          backtracking(nums, 0);          return result;      &#125;  &#125;;</code></pre><hr><p>  <a href="https://leetcode-cn.com/problems/subsets-ii/">题目链接</a></p><p>  题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">  给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。  说明：解集不能包含重复的子集。  示例:  输入: [1,2,2]  输出:  [    [2],    [1],    [1,2,2],    [2,2],    [1,2],    []  ]</code></pre><p>  题目思路：</p><p>  和上一题思路类似，只不过需要一个数组来记录该元素是否是重复元素。</p><pre class=" language-lang-c++"><code class="language-lang-c++">  class Solution &#123;  private:      void backtracking(vector<int>& nums, vector<vector<int>>& result, vector<int>& vec, int startIndex,  vector<bool>& used) &#123;          result.push_back(vec);          for (int i = startIndex; i < nums.size(); i++) &#123;              // used[i - 1] == true，说明同一树支candidates[i - 1]使用过               // used[i - 1] == false，说明同一树层candidates[i - 1]使用过              // 而我们要对同一树层使用过的元素进行跳过              if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) &#123;                   continue;              &#125;              vec.push_back(nums[i]);              used[i] = true;              backtracking(nums, result, vec, i + 1, used);              used[i] = false;              vec.pop_back();          &#125;      &#125;  public:      vector<vector<int>> subsetsWithDup(vector<int>& nums) &#123;          vector<bool> used(nums.size(), false);          vector<vector<int>> result;          vector<int> vec;          sort(nums.begin(), nums.end());          backtracking(nums, result, vec, 0, used);          return result;      &#125;  &#125;;</code></pre><hr><h3 id="Day04"><a href="#Day04" class="headerlink" title="Day04"></a>Day04</h3><h4 id="二叉搜索树转化为累加数"><a href="#二叉搜索树转化为累加数" class="headerlink" title="二叉搜索树转化为累加数"></a>二叉搜索树转化为累加数</h4><p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。例如：输入: 原始二叉搜索树:              5            /   \           2     13输出: 转换为累加树:             18            /   \          20     13</code></pre><p>思路：</p><p>相当于遍历树，只不过遍历的顺序是右根左。</p><pre class=" language-lang-c++"><code class="language-lang-c++">class Solution &#123;public:    //非递归    TreeNode* convertBST(TreeNode* root) &#123;        int sum = 0;        stack<TreeNode*> st;        TreeNode* node = root;//保留root，最后方便返回        while(node || !st.empty())&#123;            while(node)&#123;                t.push(node);                node = node->right;//一直找到最小的数            &#125;              node = st.top();            st.pop();            sum += node->val;            node->val = sum;            //左子树            node = node->left;        &#125;        return root;    &#125;    //递归    TreeNode* convertBST(TreeNod* root)&#123;        int sum = 0;        while(root)&#123;            convertBST(root->right);            sum += root->val;            root->val = sum;            convertBST(root->left);        &#125;        return rootl;    &#125;&#125;;</code></pre><hr><h4 id="从前序和中序遍历构造二叉树"><a href="#从前序和中序遍历构造二叉树" class="headerlink" title="从前序和中序遍历构造二叉树"></a>从前序和中序遍历构造二叉树</h4><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">题目链接</a></p><p>题目描述：</p><pre class=" language-lang-python"><code class="language-lang-python">根据一棵树的前序遍历与中序遍历构造二叉树。注意:你可以假设树中没有重复的元素。例如，给出前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树：    3   / \  9  20    /  \   15   7</code></pre><p>思路：</p><p>前序遍历：根左右[根节点，左子树，右子树]</p><p>中序遍历：左根右[左子树，根节点，右子树]</p><p>从中序遍历中找到根节点，就可以知道左子树和右子树，之后递归构造左右字数，在接到根节点的左右位置。</p><pre class=" language-lang-c++"><code class="language-lang-c++">//递归方法class Solution &#123;public:    TreeNode* creat(vector<int>& preorder, vector<int>& inorder, int preL, int preR, int inL, int inR)&#123;        //判断是否还需要构造        if(preL > preR)&#123;            return NULL;        &#125;        //构建根节点        TreeNode* root = new TreeNode;        root->val = preorder[preL];        int k;//找出中序遍历的根节点位置        for(k = inL; k <= inR; k++)&#123;            if(preorder[preL] == inorder[k])                break;        &#125;        int numLeft = k - inL;//左子树的节点个数        //左子树的先序区间[preL+1, preL+numLeft], 中序区间是[inL, k-1]        //返回左子树的根节点地址，赋值给root的左指针        root->left = creat(preorder, inorder, preL+1, preL+numLeft, inL, k-1);        //右子树的线序区间[preL+numLeft+1, preR], 中序区间[k+1, inR]        //返回右子树的根节点地址，赋值给root的右指针        root->right = creat(preorder, inorder, preL+numLeft+1, preR, k+1, inR);        return root;    &#125;    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) &#123;        int n = preorder.size();        return creat(preorder, inorder, 0, n - 1, 0, n - 1);    &#125;&#125;;</code></pre><hr><h3 id="Day05"><a href="#Day05" class="headerlink" title="Day05"></a>Day05</h3><h4 id="从中序与后续遍历构造二叉树"><a href="#从中序与后续遍历构造二叉树" class="headerlink" title="从中序与后续遍历构造二叉树"></a>从中序与后续遍历构造二叉树</h4><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">根据一棵树的中序遍历与后序遍历构造二叉树。注意:你可以假设树中没有重复的元素。例如，给出中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3]返回如下的二叉树：    3   / \  9  20    /  \   15   7</code></pre><p>思路：</p><p>因为后序遍历是左右根，中序遍历是左根右，因此根据根节点划分左右子树，从而使用递归方法来构造二叉树。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    TreeNode* creat(vector<int>& inorder, vector<int>& postorder, int inL, int inR, int postL, int postR)&#123;        //递归条件        if(postL > postR)&#123;            return NULL;        &#125;        TreeNode* root = new TreeNode;        root->val = postorder[postR];        int k;//找中序遍历的根节点        for(k = inL; k <= inR; k++)&#123;            if(postorder[postR] == inorder[k])&#123;                break;            &#125;        &#125;        int numLeft = k - inL;//左子树个数        //左子树的中序区间[inL, k-1], 后序区间[postL, postL + numLeft - 1]        root->left = creat(inorder, postorder, inL, k-1, postL, postL+numLeft-1);        //右子树的中序区间[k+1, inR], 后序区间[postL+numLeft, postR-1]        root->right = creat(inorder, postorder, k+1, inR, postL+numLeft, postR-1);        return root;    &#125;    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) &#123;        int size = inorder.size();        TreeNode* root = creat(inorder, postorder, 0, size-1, 0, size - 1);        return root;    &#125;&#125;;</code></pre><hr><h4 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title=" 监控二叉树"></a><font color="#660000"> 监控二叉树</font></h4><p><a href="https://leetcode-cn.com/problems/binary-tree-cameras/">题目链接</a></p><p>题目描述</p><pre><code>给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。计算监控树的所有节点所需的最小摄像头数量。示例 1：输入：[0,0,null,0,0]输出：1解释：如图所示，一台摄像头足以监控所有节点。示例 2：输入：[0,0,null,0,null,0,null,null,0]输出：2解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。提示：给定树的节点数的范围是 [1, 1000]。每个节点的值都是 0。</code></pre><p>思路：</p><p>三种状态：0:待覆盖 1:已覆盖 2:已安装相机</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    //0:待覆盖    //1:已覆盖    //2:已安装相机    int res;    int minCameraCover(TreeNode* root) &#123;        res=0;        //如果root仍为覆盖，给root加相机        if(dfs(root)==0)            res++;        return res;    &#125;    int dfs(TreeNode* r)&#123;        if(r==NULL)            return 1;        int left=dfs(r->left);        int right=dfs(r->right);        //下面的节点没有把left或者right覆盖，只能靠r了        if(left==0||right==0)&#123;            res++;            return 2;        &#125;        //left和right都已经被覆盖了，但是没有安装相机，所以r是待覆盖的        else if(left==1&&right==1)&#123;            return 0;        &#125;        //left和right至少有一个安装相机了        else if(left+right>=3)&#123;            return 1;        &#125;        return -1;    &#125;&#125;;</code></pre><hr><h3 id="Day06"><a href="#Day06" class="headerlink" title="Day06"></a>Day06</h3><h4 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h4><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">题目链接</a></p><p>题目描述：</p><pre class=" language-lang-python"><code class="language-lang-python">给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。示例 1:输入:     Tree 1                     Tree 2                            1                         2                                      / \                       / \                                    3   2                     1   3                               /                           \   \                            5                             4   7                  输出: 合并后的树:         3        / \       4   5      / \   \      5   4   7</code></pre><p>思路：</p><p>使用层序遍历法，然后将每个节点合并到新的节点。</p><pre class=" language-lang-C++"><code class="language-lang-C++">//BFSclass Solution&#123;public:    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2)&#123;        if (t1 == nullptr)            return t2;        if (t2 == nullptr)            return t1;        TreeNode* merged = new TreeNode(t1->val + t2->val);        queue<TreeNode*> q;        queue<TreeNode*> q1;        queue<TreeNOde*> q2;        q.push(merged);        q1.push(t1);        q2.push(t2);        while(!q1.empty() && !q2.empty())&#123;            TreeNode* node = q.front();            TreeNode* node1 = q1.front();            TreeNode* node2 = q2.front();            q.pop();            q1.pop();            q2.pop();            auto left1 = node1->left, left2 = node2->left, right1 = node1->right, right2 = node2->right;            if (left1 != nullptr || left2 != nullptr) &#123;                if (left1 != nullptr && left2 != nullptr) &#123;                    TreeNode* left = new TreeNode(left1->val + left2->val);                    node->left = left;                    q.push(left);                    q1.push(left1);                    q2.push(left2);                &#125; else if (left1 != nullptr) &#123;                    node->left = left1;                &#125; else if (left2 != nullptr) &#123;                    node->left = left2;                &#125;            &#125;            if (right1 != nullptr || right2 != nullptr) &#123;                if (right1 != nullptr && right2 != nullptr) &#123;                    TreeNode* right = new TreeNode(right1->val + right2->val);                    node->right = right;                    q.push(right);                    q1.push(right1);                    q2.push(right2);                &#125; else if (right1 != nullptr) &#123;                    node->right = right1;                &#125; else &#123;                    node->right = right2;                &#125;            &#125;        &#125;        return merged;    &#125;&#125;;//递归方法(DFS)class Solution &#123;public:    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123;        if( t1 == NULL) return t2;        if( t2 == NULL) return t1;        t1->val += t2->val;//t2 合并到 t1 上        //分别合并左右子节点        t1->left = mergeTrees(t1->left,t2->left);        t1->right = mergeTrees(t1->right,t2->right);        return t1;    &#125;&#125;;</code></pre><hr><h3 id="Day07"><a href="#Day07" class="headerlink" title="Day07"></a>Day07</h3><h4 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h4><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。示例 1:输入: 1->1->2输出: 1->2示例 2:输入: 1->1->2->3->3输出: 1->2->3</code></pre><p>思路:</p><p>因为是排序链表，因此只需要前后指针的比较，如果相同，那么删除后面的指针。(双指针)</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if(!head || !head->next)&#123;            return head;        &#125;        ListNode* prev = head;        ListNode* curr = head->next;        while(prev && prev->next)&#123;            if(curr->val == prev->val)&#123;                prev->next = curr->next;                curr = curr->next;            &#125;            else&#123;                prev = prev->next;                curr = curr->next;            &#125;        &#125;        return head;    &#125;&#125;;</code></pre><hr><h4 id="删除排序链表中的重复元素II"><a href="#删除排序链表中的重复元素II" class="headerlink" title="删除排序链表中的重复元素II"></a>删除排序链表中的重复元素II</h4><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。示例 1:输入: 1->2->3->3->4->4->5输出: 1->2->5示例 2:输入: 1->1->1->2->3输出: 2->3</code></pre><p>思路：</p><p>通过构造dummyhead来保护头节点，之后遍历链表的节点，每次从curr开始，使用while判断curr节点之后是否重复，之后使用curr的前一节点指向最后curr的后一节点。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if(!head || !head->next)            return head;        ListNode* dummyhead = new ListNode();        dummyhead->next = head;        ListNode* prev = dummyhead;        while(prev && prev->next)&#123;            ListNode* curr = prev->next;            if(!curr->next || curr->next->val != curr->val)                prev = curr;            else&#123;                while(curr->next && curr->val == curr->next->val)                    curr = curr->next;                prev->next = curr->next;            &#125;        &#125;        return dummyhead->next;    &#125;&#125;;</code></pre><hr><h3 id="Day08"><a href="#Day08" class="headerlink" title="Day08"></a>Day08</h3><h4 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h4><p><a href="https://leetcode-cn.com/problems/path-sum/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。说明: 叶子节点是指没有子节点的节点。示例: 给定如下二叉树，以及目标和 sum = 22，              5             / \            4   8           /   / \          11  13  4         /  \      \        7    2      1返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。</code></pre><p>思路:</p><p>关键点：总和等于sum，并且最后一个节点是叶子节点。</p><p>第一种：使用层次遍历的方法，记录每个节点的位置和该节点与节点上面的和，并判断是否满足上面俩个条件。BFS</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    bool hasPathSum(TreeNode* root, int sum)&#123;        if(!root)&#123;            return false;        &#125;        queue<TreeNode*> que_node;        queue<int> que_val;        que_node.push(root);        que_val.push(root->val);        while(!que_node.empty())&#123;            TreeNode* node = que_node.front();            int node_val = que_val.front();            que_node.pop();            que_val.pop();            if(!node->left && !node->right)&#123;                if(node_val == sum)                    return true;                else                    continue;            &#125;            if(node->left)&#123;                que_node.push(node->left);                que_val.push(node->left->val + node_val);            &#125;            if(node->right)&#123;                que_node.push(node->right);                que_val.push(node->right->val + node_val);            &#125;        &#125;        return false;    &#125;&#125;;</code></pre><p>第二种：递归DFS</p><pre class=" language-lang-C++"><code class="language-lang-C++">if(!root)&#123;            return false;        &#125;        if(!root->left && !root->right)&#123;            return sum == root->val;        &#125;        return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);    &#125;</code></pre><hr><h4 id="路径总和II"><a href="#路径总和II" class="headerlink" title="路径总和II"></a>路径总和II</h4><p><a href="https://leetcode-cn.com/problems/path-sum-ii/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。说明: 叶子节点是指没有子节点的节点。示例:给定如下二叉树，以及目标和 sum = 22，              5             / \            4   8           /   / \          11  13  4         /  \    / \        7    2  5   1返回:[   [5,4,11,2],   [5,8,4,5]]</code></pre><p>思路：</p><p>参照上题递归思路，使用vector来进行存储</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    vector<vector<int>> res;    vector<int> path;    void dfs(TreeNode* root, int sum)&#123;        if(!root)            return;        path.emplace_back(root->val);        sum -= root->val;        if(!root->left && !root->right && sum == 0)&#123;            res.emplace_back(path);        &#125;        dfs(root->left, sum);        dfs(root->right, sum);        path.pop_back();    &#125;    vector<vector<int>> pathSum(TreeNode* root, int sum) &#123;        dfs(root, sum);        return res;    &#125;&#125;;</code></pre><p>参照上题的BFS，设置一个hash表格，存储该节点与父节点的关系。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    vector<vector<int>> res;    unordered_map<TreeNode*, TreeNode*> parent;    void getPath(TreeNode* node)&#123;        vector<int> tmp;        while(node)&#123;            tmp.emplace_back(node->val);            node = parent[node];        &#125;        reverse(tmp.begin(), tmp.end());        res.emplace_back(tmp);    &#125;    vector<vector<int>> pathSum(TreeNode* root, int sum)&#123;        if(!root)&#123;            return res;        &#125;        queue<TreeNode* > que_node;        queue<int> que_val;        que_node.push(root);        que_val.push(root->val);        while(!que_node.empty())&#123;            TreeNode* node = que_node.front();            int node_val = que_val.front();            que_node.pop();            que_val.pop();            if(!node->left && !node->right)&#123;                if(node_val == sum)                    getPath(node);            &#125;else&#123;                if(node->left)&#123;                    parent[node->left] = node;                    que_node.push(node->left);                    que_val.push(node_val + node->left->val);                &#125;                if(node->right)&#123;                    parent[node->right] = node;                    que_node.push(node->right);                    que_val.push(node_val + node->right->val);                &#125;            &#125;        &#125;        return res;    &#125;&#125;;</code></pre><hr><h3 id="Day09"><a href="#Day09" class="headerlink" title="Day09"></a>Day09</h3><h4 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h4><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]示例 1:输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。示例 2:输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p>思路:</p><p>用vector来存储每个节点到根节点的路径，所以最后寻找祖先节点，就是俩个vector相同的情况。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    vector<TreeNode*> getPath(TreeNode* root, TreeNode* target)&#123;        vector<TreeNode*> path;        TreeNode* node = root;        while(node != target)&#123;//寻找目标节点            path.push_back(node);//存储父节点            if(target->val < node->val)&#123;                node = node->left;            &#125;else&#123;                node = node->right;            &#125;        &#125;        path.push_back(node);        return path;    &#125;    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        vector<TreeNode*> path_p = getPath(root, p);        vector<TreeNode*> path_q = getPath(root, q);        TreeNode* ancestor;        for(int i = 0; i < path_q.size() && i < path_p.size(); i++)&#123;            if(path_q[i] == path_p[i])&#123;                ancestor = path_q[i];            &#125;else&#123;                break;            &#125;        &#125;        return ancestor;    &#125;&#125;;</code></pre><p>由于是二叉搜素树，因此判断该节点是否是公共节点可以使用如下代码：</p><pre class=" language-lang-C++"><code class="language-lang-C++">if(p->val <= cur->val && cur->val <= q->val)</code></pre><pre class=" language-lang-C++"><code class="language-lang-C++">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)&#123;        if(root->val > p->val && root->val > q->val)&#123;            return lowestCommonAncestor(root->left, p, q);        &#125;else if(root->val < p->val && root->val < q->val)&#123;            return lowestCommonAncestor(root->right, p, q);        &#125;else&#123;            return root;        &#125;    &#125;</code></pre><hr><h3 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h3><h4 id="填充每个节点的下一个右侧节点指针II"><a href="#填充每个节点的下一个右侧节点指针II" class="headerlink" title="填充每个节点的下一个右侧节点指针II"></a>填充每个节点的下一个右侧节点指针II</h4><p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个二叉树struct Node &#123;  int val;  Node *left;  Node *right;  Node *next;&#125;填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。进阶：你只能使用常量级额外空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。示例：输入：root = [1,2,3,4,5,null,7]输出：[1,#,2,3,#,4,5,7,#]解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</code></pre><p>思路：</p><p>使用层次遍历，每次从右节点开始进入，然后将队列中的数移除指向下一个。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    Node* connect(Node* root)&#123;        if(!root)            return NULL;        queue<Node*> q;        q.push(root);        while(!q.empty())&#123;            int n = q.size();            while(n)&#123;                n = n - 1;                Node* f = q.front();                q.pop();                if(f->left)&#123;                    q.push(f->left);                &#125;                if(f->right)&#123;                    q.push(f->right);                &#125;                if(n)&#123;                    f->next = q.front();                &#125;else&#123;                    f->next = NULL;                &#125;            &#125;        &#125;        return root;    &#125;&#125;</code></pre><hr><h4 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h4><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">题目链接</a></p><p>题目描述：</p><pre class=" language-lang-python"><code class="language-lang-python">输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如，给出前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树：    3   / \  9  20    /  \   15   7</code></pre><p>思路:</p><p>具体参考Day04。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    TreeNode* creat(vector<int>& preorder, vector<int>& inorder, int preL, int preR, int inL, int inR)&#123;        //判断是否还需要构造        if(preL > preR)&#123;            return NULL;        &#125;        //构建根节点        TreeNode* root = new TreeNode;        root->val = preorder[preL];        int k;//找出中序遍历的根节点位置        for(k = inL; k <= inR; k++)&#123;            if(preorder[preL] == inorder[k])                break;        &#125;        int numLeft = k - inL;//左子树的节点个数        //左子树的先序区间[preL+1, preL+numLeft], 中序区间是[inL, k-1]        //返回左子树的根节点地址，赋值给root的左指针        root->left = creat(preorder, inorder, preL+1, preL+numLeft, inL, k-1);        //右子树的线序区间[preL+numLeft+1, preR], 中序区间[k+1, inR]        //返回右子树的根节点地址，赋值给root的右指针        root->right = creat(preorder, inorder, preL+numLeft+1, preR, k+1, inR);        return root;    &#125;    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) &#123;        int n = preorder.size();        return creat(preorder, inorder, 0, n - 1, 0, n - 1);    &#125;&#125;;</code></pre><hr><h3 id="Day11"><a href="#Day11" class="headerlink" title="Day11"></a>Day11</h3><h4 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h4><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">题目链接</a></p><p>复习题</p><p>非递归方法，内存消耗比较小</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    vector<int> res;    vector<int> postorderTraversal(TreeNode* root) &#123;        if(!root)&#123;            return &#123;&#125;;        &#125;        stack<TreeNode*> st;        TreeNode* cur = root;        TreeNode* pre = NULL;        while(cur || !st.empty())&#123;            while(cur)&#123;                st.push(cur);                cur = cur->left;            &#125;            cur = st.top();            if( !cur->right || pre == cur->right)&#123;                st.pop();                res.push_back(cur->val);                pre = cur;                cur = NULL;            &#125;else&#123;                cur = cur->right;                pre = NULL;            &#125;        &#125;        return res;    &#125;&#125;;</code></pre><hr><h4 id="验证二叉搜素树"><a href="#验证二叉搜素树" class="headerlink" title="验证二叉搜素树"></a>验证二叉搜素树</h4><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-c++"><code class="language-lang-c++">给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。示例 1:输入:    2   / \  1   3输出: true示例 2:输入:    5   / \  1   4     / \    3   6输出: false解释: 输入为: [5,1,4,null,null,3,6]。     根节点的值为 5 ，但是其右子节点值为 4 。</code></pre><p>思路：</p><p>采用中序遍历的方法，判断下一个节点是否大于前一个节点，如果不是则是错误的。</p><pre class=" language-lang-C++"><code class="language-lang-C++">bool isValidBST(TreeNode* root)&#123;    stack<TreeNode*> st;    long long inorder = (long long)INT_MIN - 1;    while(!st.empty() || root)&#123;        while(root)&#123;            st.push(root);            root = root->left;        &#125;        root = st.top();        st.pop();        if(root->val <= inorder)&#123;            return false;        &#125;        inorder = root->val;        root = root->right;    &#125;&#125;</code></pre><hr><h3 id="Day12"><a href="#Day12" class="headerlink" title="Day12"></a>Day12</h3><h4 id="宝石与石头"><a href="#宝石与石头" class="headerlink" title="宝石与石头"></a>宝石与石头</h4><p><a href="https://leetcode-cn.com/problems/jewels-and-stones/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此"a"和"A"是不同类型的石头。示例 1:输入: J = "aA", S = "aAAbbbb"输出: 3示例 2:输入: J = "z", S = "ZZ"输出: 0注意:S 和 J 最多含有50个字母。 J 中的字符不重复。</code></pre><p>思路：</p><p>设置一个map用来存放宝石类型，然后遍历你拥有的石头，如果有那么就增加。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    int numJewelsInStones(string J, string S)&#123;        unordered_map<char, int> jewels;        int count = 0;        for(int i = 0; i < J.size(); ++i)&#123;            jewels[J[i]] = 1;        &#125;        for(int i = 0; i < S.size(); ++i)&#123;            if(jewels.find(S[i]) != jewels.end())&#123;                count++;            &#125;        &#125;        return count;    &#125;&#125;</code></pre><p>执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</p><p>内存消耗：6.4 MB, 在所有 C++ 提交中击败了24.38%的用户</p><p>典型的用空间换时间，使用了unordered_map之后时间大大的减少，但是却使用了大量的内存空间。</p><p><strong>map与unordered_map区别</strong>：</p><p>map是使用红黑树来实现的，并且map内部所有数据在任何时候都是有序的</p><p>unordered_map是基于hash表，数据插入和查找基本都是常数时间， 但是消耗的内存较多。</p><p><strong>Hash表</strong>：</p><p>Hash Table是根据key-value对应关系而进行直接访问的数据结构。记录的存储位置=f(关键字)</p><hr><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">反转一个单链表。示例:输入: 1->2->3->4->5->NULL输出: 5->4->3->2->1->NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</code></pre><p>思路：</p><p>双指针，一个prev，一个cur，并且使用内存来存储next节点，将cur的next指向prev即可。</p><pre class=" language-lang-C++"><code class="language-lang-C++">//迭代class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode* prev = NULL;        ListNode* cur = head;        while(cur)&#123;            ListNode* next = cur->next;            cur->next = prev;            prev = cur;            cur = next;        &#125;        return prev;    &#125;    ListNode* reverseList(ListNode* head)&#123;        if(head == NULL || head->next == NULL)&#123;            return head;        &#125;        ListNode* p = reverseList(head->next);        head->next->next = head;        head->next = NULL;        return p;    &#125;&#125;;</code></pre><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">递归PPT解释</a></p><hr><h3 id="Day13"><a href="#Day13" class="headerlink" title="Day13"></a>Day13</h3><h4 id="俩数之和"><a href="#俩数之和" class="headerlink" title="俩数之和"></a>俩数之和</h4><p><a href="https://leetcode-cn.com/problems/two-sum/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><p>思路：</p><pre class=" language-lang-C++"><code class="language-lang-C++">//暴力解法class Solution &#123;public:    vector<int> twoSum(vector<int>& nums, int target) &#123;        vector<int> res;        for(int i = 0; i < nums.size(); ++i)&#123;            for(int j = i + 1; j < nums.size(); ++j)&#123;                if(nums[i] + nums[j] == target)&#123;                    res.push_back(i);                    res.push_back(j);                &#125;            &#125;        &#125;        return res;    &#125;&#125;;</code></pre><p>思路简单，但是耗时很长。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    vector<int> twoSum(vector<int>& nums, int target) &#123;        unordered_map<int, int> hashtable;        for (int i = 0; i < nums.size(); ++i) &#123;            auto it = hashtable.find(target - nums[i]);            if (it != hashtable.end()) &#123;                return &#123;it->second, i&#125;;            &#125;            hashtable[nums[i]] = i;        &#125;        return &#123;&#125;;    &#125;&#125;;</code></pre><p>使用hashtable可以大大的减少时间，但是使用空间增加了。</p><hr><h4 id="合并俩个排序的链表"><a href="#合并俩个排序的链表" class="headerlink" title="合并俩个排序的链表"></a>合并俩个排序的链表</h4><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。示例1：输入：1->2->4, 1->3->4输出：1->1->2->3->4->4</code></pre><p>思路：</p><p>迭代方法，构建一个新的节点，用来存放合并后的链表，比较l1与l2的值，将小的值放入新的链表，直到其中一个链表遍历结束，之后将剩余的链表值放入。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        ListNode* dummy = new ListNode;        ListNode* cur = dummy;        while(l1 && l2)&#123;            if(l1->val <= l2->val)&#123;                cur->next = l1;                l1 = l1->next;            &#125;else&#123;                cur->next = l2;                l2 = l2->next;            &#125;            cur = cur->next;        &#125;        if(l1)&#123;            cur->next = l1;        &#125;        if(l2)&#123;            cur->next = l2;        &#125;        return dummy->next;    &#125;&#125;;</code></pre><p>递归方法：</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        if(!l1)            return l2;        if(!l2)            return l1;        if(l1->val <= l2->val)&#123;            l1->next = mergeTwoLists(l1->next, l2);            return l1;        &#125;else&#123;            l2->next = mergeTwoLists(l1, l2->next);            return l2;        &#125;    &#125;&#125;;</code></pre><hr><h3 id="Day14"><a href="#Day14" class="headerlink" title="Day14"></a>Day14</h3><h4 id="俩数相加"><a href="#俩数相加" class="headerlink" title="俩数相加"></a>俩数相加</h4><p><a href="https://leetcode-cn.com/problems/add-two-numbers/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。示例：输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)输出：7 -> 0 -> 8原因：342 + 465 = 807</code></pre><p>思路：</p><p>用一位数来表示位数相加是否大于10</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)&#123;        ListNode* head = new ListNode;        ListNode* h = head;//移动指针        int sum = 0;        bool plus = false;//进位标志        while(l1 || l2)&#123;            sum = 0;            if(l1)&#123;                sum += l1->val;                l1 = l1->next;            &#125;            if(l2)&#123;                sum += l2->val;                l2 = l2->next;            &#125;            if(plus)                sum++;            h->next = new ListNode(sum%10);            h = h->next;            plus = (sum >= 10)? true: false;        &#125;        if(plus)&#123;            h->next = new ListNode(1);        &#125;        return head->next;    &#125;&#125;;</code></pre><hr><h4 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h4><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]示例 1:输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。示例 2:输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p>思路：</p><p>存储每个节点的parent位置，并且存储要访问节点的前一个节点是否被访问过，即使用俩个hash表来进行存储。</p><pre class=" language-lang-C++"><code class="language-lang-C++">//迭代方法class Solution&#123;public:    unordered_map<int, TreeNode* > fa;    unordered_map<int, bool> vis;    void dfs(TreeNode* root)&#123;        if(root->left)&#123;            fa[root->left->val] = root;            dfs(root->left);        &#125;        if(root->right)&#123;            fa[root->right->val] = root;            dfs(root->right);        &#125;    &#125;    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)&#123;        fa[root->val] = nullptr;        dfs(root);        while(p)&#123;            vis[p->val] = true;            p = fa[p->val];        &#125;        while(q)&#123;            if(vis[q->val])                return q;            q = fa[q->val];        &#125;        return nullptr;    &#125;&#125;//递归方法(不懂)class Solution&#123;public:    TreeNode* ans;    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q)&#123;        if(!root)            return false;        bool lson = dfs(root->left, p, q);        bool rson = dfs(root->right, p, q);        if((lson && rson) || ((root->val == p->val || root->val == q->val) && (lson || rson)))&#123;            ans = root;        &#125;        return lson || rson || (root->val == p->val || root->val == q->val);    &#125;    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        dfs(root, p, q);        return ans;    &#125;&#125;</code></pre><hr><h3 id="Day15"><a href="#Day15" class="headerlink" title="Day15"></a>Day15</h3><h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p><a href="https://leetcode-cn.com/problems/3sum/">题目链接</a></p><p>题目描述：</p><pre class=" language-lang-python"><code class="language-lang-python">给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。示例：给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[  [-1, 0, 1],  [-1, -1, 2]]</code></pre><p>思路：</p><p>最容易想到的是暴力解法，即将循环三遍，找出相加为0的数组。但是该时间复杂度比较高是$O(n^3)$,从俩数相加的方法找到思路，我们可以缩短时间复杂度，使用双指针的方法，即将第二个和第三个数放在一起，使用双指针。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    vector<vector<int>> threeSum(vector<int>& nums)&#123;        int n = nums.size();        sort(nums.begin(), nums.end());        vector<vector<int>> ans;        for(int first = 0; first < n; ++first)&#123;            //需要和上次不同            if(first > 0 && nums[first] == nums[first - 1])&#123;                continue;            &#125;            int third = n - 1;            int target = -nums[first];            //枚举第二个数            for(int second = first + 1; second < n; ++ second)&#123;                if(second > first + 1 && nums[second] == nums[second - 1])                    continue;                while(second < third && nums[second] + nums[third] > target)&#123;                    --third;                &#125;                if(second == third)                    break;                if(nums[second] + nums[third] == target)                    ans.push_back(&#123;nums[first], nums[second], nums[third]&#125;);            &#125;        &#125;        return ans;    &#125;&#125;;</code></pre><hr><h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><p><a href="https://leetcode-cn.com/problems/4sum/">题目链接</a></p><p>题目描述:</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意：答案中不可以包含重复的四元组。示例：给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[  [-1,  0, 0, 1],  [-2, -1, 1, 2],  [-2,  0, 0, 2]]</code></pre><p>思路：</p><p>与三数之和类似，使用双指针的解法，只不过多了一层嵌套。其中的一些剪枝条件：</p><p>在确定第一个数之后，如果 $\textit{nums}[i]+\textit{nums}[i+1]+\textit{nums}[i+2]+\textit{nums}[i+3]&gt;\textit{target}$，说明此时剩下的三个数无论取什么值，四数之和一定大于 $\textit{target}$，因此退出第一重循环；<br>在确定第一个数之后，如果 $\textit{nums}[i]+\textit{nums}[n-3]+\textit{nums}[n-2]+\textit{nums}[n-1]&lt;\textit{target}$，说明此时剩下的三个数无论取什么值，四数之和一定小于$ \textit{target}$，因此第一重循环直接进入下一轮，枚举$ \textit{nums}[i+1]$；<br>在确定前两个数之后，如果$ \textit{nums}[i]+\textit{nums}[j]+\textit{nums}[j+1]+\textit{nums}[j+2]&gt;\textit{target}$，说明此时剩下的两个数无论取什么值，四数之和一定大于$\textit{target}$，因此退出第二重循环；<br>在确定前两个数之后，如果 $\textit{nums}[i]+\textit{nums}[j]+\textit{nums}[n-2]+\textit{nums}[n-1]&lt;\textit{target}$，说明此时剩下的两个数无论取什么值，四数之和一定小于$ \textit{target}$，因此第二重循环直接进入下一轮，枚举 $\textit{nums}[j+1]$。</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution&#123;public:    vector<vector<int>> fourSum(vector<int>& nums, int target)&#123;        vector<vector<int>> res;        if(nums.size() < 4)            return res;        sort(nums.begin(), nums.end());        int length = nums.size();        for(int i = 0; i < length - 3; i++)&#123;            if(i > 0 && nums[i] == nums[i-1])&#123;                continue;            &#125;            if(nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target)&#123;                break;            &#125;            if(nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target)&#123;                continue;            &#125;            for(int j = i + 1; j < length - 2; j++)&#123;                if(j > i + 1 && nums[j] == nums[j - 1])&#123;                    continue;                &#125;                if(nums[i] + nums[j] + nums[j+1] + nums[j+2]>target)                    break                if (nums[i] + nums[j] + nums[length - 2] + nums[length - 1] < target) &#123;                    continue;                &#125;                int left = j + 1, right = length - 1;                while (left < right) &#123;                    int sum = nums[i] + nums[j] + nums[left] + nums[right];                    if (sum == target) &#123;                        res.push_back(&#123;nums[i], nums[j], nums[left], nums[right]&#125;);                        while (left < right && nums[left] == nums[left + 1]) &#123;                            left++;                        &#125;                        left++;                        while (left < right && nums[right] == nums[right - 1]) &#123;                            right--;                        &#125;                        right--;                    &#125; else if (sum < target) &#123;                        left++;                    &#125; else &#123;                        right--;                    &#125;                &#125;            &#125;        &#125;        return res;    &#125;&#125;;</code></pre><hr><h3 id="Day16"><a href="#Day16" class="headerlink" title="Day16"></a>Day16</h3><h4 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h4><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">题目链接</a></p><p>题目描述：</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。示例:输入: [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</code></pre><p>思路:</p><p>使用动态规划的思想来进行求解，动态规划的思路关键是列出状态转移方程，对于该题来说我们说着dp[i]表示以A[i]结尾的最大序列和，状态转移方程则为: dp[i] = max(A[i], dp[i-1]+A[i])</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    int maxSubArray(vector<int>& nums) &#123;        vector<int> dp(nums.size());        dp[0] = nums[0];        for(int i = 1; i < nums.size(); i++)&#123;            dp[i] = max(nums[i], dp[i-1]+nums[i]);        &#125;        int k = 0;        for(int i = 0; i < nums.size(); i++)&#123;            if(dp[i] > dp[k])&#123;                k = i;            &#125;        &#125;        return dp[k];    &#125;&#125;;</code></pre><hr><h4 id="最长上升子序列-LIS"><a href="#最长上升子序列-LIS" class="headerlink" title="最长上升子序列(LIS)"></a>最长上升子序列(LIS)</h4><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">题目链接</a></p><p>题目描述</p><pre class=" language-lang-python"><code class="language-lang-python">给定一个无序的整数数组，找到其中最长上升子序列的长度。示例:输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。说明:可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。你算法的时间复杂度应该为 O(n2)</code></pre><p>思路:</p><p>使用动态规划来进行求解，状态量dp[i]表示的是当前这个数的最长上升长度。状态转移方程为$dp[i] = max(1, dp[j] + 1),(j=1,…,n-1 \&amp; A[j] &lt; A[i])$</p><pre class=" language-lang-C++"><code class="language-lang-C++">class Solution &#123;public:    int lengthOfLIS(vector<int>& nums) &#123;        vector<int> dp(nums.size());        if(nums.empty())&#123;            return 0;        &#125;        int ans = -1;        for(int i = 0; i < nums.size(); i++)&#123;            dp[i] = 1;            for(int j = 0; j < i; j++)&#123;                if(nums[j] < nums[i] && dp[j] + 1 > dp[i])                    dp[i] = dp[j] + 1;            &#125;            ans = max(ans, dp[i]);        &#125;        return ans;    &#125;&#125;;</code></pre><hr><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>DP最重要的是找出状态量，定义是什么意思，并确定状态转移方程。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 回溯算法 </tag>
            
            <tag> DFS </tag>
            
            <tag> 链表 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献阅读方法</title>
      <link href="2020/09/16/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95/"/>
      <url>2020/09/16/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="文献阅读方法"><a href="#文献阅读方法" class="headerlink" title="文献阅读方法"></a>文献阅读方法</h1><h4 id="阅读初期"><a href="#阅读初期" class="headerlink" title="阅读初期"></a>阅读初期</h4><ol><li><p><strong>收集关注主题的资源(注意文献整理)</strong></p><ul><li>关键词，主题词检索</li><li>检索某个学者</li><li>参考综述检索</li><li>注意文章参考价值</li></ul></li><li><p><strong>按照完成程度构建一个表格</strong></p></li><li><strong>结构性笔记：用自己的语言总结论文的关键发现，结果和技术</strong></li></ol><h4 id="如何阅读"><a href="#如何阅读" class="headerlink" title="如何阅读"></a>如何阅读</h4><ol><li>第一遍从title，abstract和figures开始阅读</li><li>第二遍阅读introduction，conclusion过一遍figures</li><li>阅读整个论文整个部分，跳过不熟悉的</li></ol><h4 id="阅读后"><a href="#阅读后" class="headerlink" title="阅读后"></a>阅读后</h4><p>必须问自己问题：</p><ol><li>作者目的是什么，实现了什么</li><li>引入了什么新型的方法，新方法的要素是什么</li><li>论文中什么对我比较重要</li><li>有什么参考文献需要跟踪</li></ol><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><strong>提高阅读效率</strong></p><ul><li>集中时间看文献</li><li>做好记录和标记</li><li>注重如何阅读</li></ul><p>阅读文献时候，要总结常用句型和常用短语（以英文为母语者）</p>]]></content>
      
      
      <categories>
          
          <category> Method </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Method </tag>
            
            <tag> 文献阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标检测常用数据集</title>
      <link href="2020/08/25/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
      <url>2020/08/25/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="目标检测常用数据集"><a href="#目标检测常用数据集" class="headerlink" title="目标检测常用数据集"></a>目标检测常用数据集</h1><h2 id="Pascal-VOC-2012数据集"><a href="#Pascal-VOC-2012数据集" class="headerlink" title="Pascal VOC 2012数据集"></a>Pascal VOC 2012数据集</h2><p><a href="http://host.robots.ox.ac.uk/pascal/VOC/voc2012/VOCtrainval_11-May-2012.tar"><strong>下载地址</strong></a></p><h3 id="Pascal-VOC简介"><a href="#Pascal-VOC简介" class="headerlink" title="Pascal VOC简介"></a>Pascal VOC简介</h3><p>首先入门深度学习的小盆友，肯定了解ImageNet Pascal VOC挑战赛是一个世界级的计算机视觉挑战赛，是一个由欧盟资助的网络组织。</p><p>该挑战赛产生了一大批特别优秀的深度学习算法，例如two-stage的：R-CNN系列，one-stage的：YOLO，SSD等，虽然该比赛在2012年就已经停止举办但是它的数据集还是被广大的研究者作为测验自己模型性能的标准，Pascal VOC官方也持续开放服务器给研究者评估模型性能。</p><h3 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h3><p><a href="https://blog.csdn.net/On_theway10/article/details/93533733"><strong>转自</strong></a></p><p>下载该数据集之后可以看到该数据集由五个文件夹构成:Annotation, ImageSets, JPEGImaes, SegmentationClass, SegmentationObject。</p><p><strong>Annotation</strong>：文件夹包含所有文件的标注信息，以XML格式存储。</p><p><strong>JPEGImages</strong>：该文件夹存放的是Pascal VOC2012数据集的所有图片，一共17125张。</p><p><strong>ImageSets</strong>：包含四个文件夹</p><ul><li><p>Action：包含10类常见人体动作{jumping,phoning,playing instrument, reading,riding bike,riding horse,running,taking photo, using computer,walking}每组分为train，val，trainval三类文本文件，还包含一个整体的划分文件。具体数目下图所示。<img src="/2020/08/25/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E9%9B%86/Action.png" alt></p><p>并且每个文本文件包含三列，依次是图片的名称，图片中object的index和label（正样本1，负样本-1）。</p></li><li><p>Layout：包含三个文本文件，train，trainval，val三类文件，用于预测人体的头，手，jio三个部分的bbox，并对bbox的object分类，文本文件有俩列，图片名称，图片包含的人数。</p></li><li><p>Main：文件夹包含63个文本文件，其中一共20个类，三个分文件，20各类的类别如下图所示</p><p><img src="/2020/08/25/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E9%9B%86/Main.png" alt></p><p>文本文件包含俩列，依次表示文件名，label（正样本1，负样本-1）。</p></li><li><p>Segmentation：包含一组总的train，trainval，val文本文件，该文件只有一列，为图片名称。</p></li></ul><p><strong>SegmentationClass</strong>：以png格式存储图片，一个2913张图片，语义分割(Semantic Segmentation)的结果。每个颜色对应一种类别。</p><p><strong>SegmentationObject</strong>：以png格式存储图片，一个2913张图片，实例分割(Instance Segmentation)的结果。</p><p><em>区别</em>：</p><ul><li>语义分割：分出每一个像素所属的类别，但是并不区分同一类别的不同物体</li><li>实力分割：区分每一个像素所属的物体。（进一步的语义分割）</li></ul><h3 id="数据集初步提取"><a href="#数据集初步提取" class="headerlink" title="数据集初步提取"></a>数据集初步提取</h3><p>首先使用read_voc_images提取图片的vector形式</p><pre class=" language-lang-python"><code class="language-lang-python">def read_voc_images(root="data/VOCdevkit/VOC2012", is_train = True, max_num = None):    txt_fname = '%s/ImageSets/Segmentation/%s' %(root, 'train.txt' if is_train else 'val.txt')    with open(txt_fname, 'r') as f:        images = f.read().split()    if max_num is not None:        images = images[:min(max_num, len(images))]    features, labels = [None]*len(images), [None]*len(images)    for i, fname in tqdm(enumerate(images)):#tqdm第三方库是用来显示进度的        feature_tmp = tf.io.read_file('%s/JPEGImages/%s.jpg' % (root, fname))#使用tf.io.read_file来读取图片        features[i] = tf.image.decode_jpeg(feature_tmp)#tf.image.decode_jpeg将图片解析        label_tmp = tf.io.read_file('%s/SegmentationClass/%s.png' % (root, fname))        labels[i] = tf.image.decode_png(label_tmp)    return features, labels #shape=(h, w, c)</code></pre><p>使用show_images来展示相对应的Semantic Segmentation</p><pre class=" language-lang-python"><code class="language-lang-python">def show_images(imgs, num_rows, num_cols, scale = 2):    figsize = (num_cols * scale, num_rows * scale)    _, axes = plt.subplots(num_rows, num_cols, figsize = figsize)    for i in range(num_rows):        for j in range(num_cols):            axes[i][j].imshow(imgs[i*num_cols+j])            axes[i][j].axes.get_xaxis().set_visible(False)            axes[i][j].axes.get_yaxis().set_visible(False)    return axes</code></pre><p>像素点的颜色对应于不同的种类</p><pre class=" language-lang-python"><code class="language-lang-python">VOC_COLORMAP = [[0, 0, 0], [128, 0, 0], [0, 128, 0], [128, 128, 0],                [0, 0, 128], [128, 0, 128], [0, 128, 128], [128, 128, 128],                [64, 0, 0], [192, 0, 0], [64, 128, 0], [192, 128, 0],                [64, 0, 128], [192, 0, 128], [64, 128, 128], [192, 128, 128],                [0, 64, 0], [128, 64, 0], [0, 192, 0], [128, 192, 0],                [0, 64, 128]]VOC_CLASSES = ['background', 'aeroplane', 'bicycle', 'bird', 'boat',               'bottle', 'bus', 'car', 'cat', 'chair', 'cow',               'diningtable', 'dog', 'horse', 'motorbike', 'person',               'potted plant', 'sheep', 'sofa', 'train', 'tv/monitor']#构建256**3的向量，并且对每个对应的位置进行类别标注#可以使用第二个类别aeroplane进行尝试，可以看到colormap2label[128*256*256]标注的是1，表示是aeroplanecolormap2label = np.zeros(256**3, dtype = np.uint8)for i, colormap in enumerate(VOC_COLORMAP):    colormap2label[(colormap[0]*256 + colormap[1]) * 256 +colormap[2]] = icolormap2label = tf.convert_to_tensor(colormap2label)#对每个像素打标签def voc_label_indices(colormap, colormap2label):    """    convert colormap (tf image) to colormap2label (uint8 tensor).    """    colormap = tf.cast(colormap, dtype=tf.int32)    idx = tf.add(tf.multiply(colormap[:, :, 0], 256), colormap[:, :, 1])    idx = tf.add(tf.multiply(idx, 256), colormap[:, :, 2])    idx = tf.add(idx, colormap[:, :, 2])    return tf.gather_nd(colormap2label, tf.expand_dims(idx, -1))</code></pre><p>对图片进行裁剪</p><pre class=" language-lang-python"><code class="language-lang-python">def voc_rand_crop(feature, label, height, width):    '''    Random crop feature (tf image) and label(tf.image)    先将channel合并，裁剪之后再分开    '''    combined = tf.concat([feature, label],axis = 2)    last_label_dim = tf.shape(label)[-1]    last_feature_dim = tf.shape(feature)[-1]    combined_crop = tf.image.random_crop(combined,                        size=tf.concat([(height, width), [last_label_dim + last_feature_dim]],axis=0))    return combined_crop[:, :, :last_feature_dim], combined_crop[:, :, last_feature_dim:]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object detection </tag>
            
            <tag> dataset </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>faster-R-CNN</title>
      <link href="2020/08/20/faster-R-CNN/"/>
      <url>2020/08/20/faster-R-CNN/</url>
      
        <content type="html"><![CDATA[<h1 id="Faster-R-CNN"><a href="#Faster-R-CNN" class="headerlink" title="Faster R-CNN"></a>Faster R-CNN</h1><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>Faster R-CNN的主结构如下图所示：</p><p><img src="/2020/08/20/faster-R-CNN/faster R-CNN.jpg" alt="avatar"></p><p>Faster R-CNN的大体过程：</p><ol><li>使用backbone来进行特征提取，生成一个feature map</li><li>然后使用RPN(Region Proposal Network)网络来对feature map进行处理，生成region proposals(难点: 使用anchor进行处理)</li><li>对于生成的region proposals进行筛选，放入Fast R-CNN进行生成最后目标框</li></ol><p>Faster R-CNN的基本组成部分分为：</p><ol><li>Dataset输入</li><li>Extractor特征提取器，即backbone</li><li>RPN(Region Proposal Network)，负责生成候选区域rois</li><li>RoIHead，负责对rois进行分类和微调</li></ol><h3 id="Extractor-特征提取"><a href="#Extractor-特征提取" class="headerlink" title="Extractor(特征提取)"></a><strong>Extractor(特征提取)</strong></h3><p>VGG：13个conv层，13个relu层，4个pooling层</p><p>Conv层的参数：kernel_size = 3, pad = 1, stride = 1 因此Conv layers种的conv层不改变输入和输出矩阵大小</p><p>Pooling层：kernel_size = 2, pad = 0, stride = 2</p><p>因此M$\times$N的图片经过VGG网络之后变为$(M/16)\times(N/16)$</p><h3 id="RPN网络"><a href="#RPN网络" class="headerlink" title="RPN网络"></a><strong>RPN网络</strong></h3><p>如结构图所示，RPN网络的流程：</p><ol><li>首先使用一个$3\times3$卷积核来对feature map进行卷积处理</li><li>之后分俩条线对卷积后的数据进行处理，一个是分类(判断是否属于背景)，一个是回归(生成anchor的位置信息)</li></ol><p>RPN是一个fully-convolutional network(FCN)，输入是任意一张大小的图片，输出是系列候选框(位置信息，置信度信息)。</p><p>并且在RPN网络中有一个核心概念是anchor。</p><h4 id="Anchor"><a href="#Anchor" class="headerlink" title="Anchor"></a><strong>Anchor</strong></h4><p>anchor按照我的理解，其实就是基于一个中心点，根据不同的比例(scale)和高宽比(aspect ratios)形成的一系列的待检测框(自己命名的)，其中这些待检测框是相对于原图来说的.</p><p>anchor锚点的含义：即特征图上某一个像素对应在原图上的某个像素，<font color="red">本质使特征图上当前滑窗的中心在原来像素空间的映射点叫做anchor，anchor是在原始图像上的，但是个数确实feature map的$w\times h$.</font></p><p>生成anchor的作用和目的：由于训练RPN网络是有监督训练，需要数据和类标签，因此生成anchor的目的是得到类标签，这个待检测框是正类还是负类样本。</p><h4 id="cls-layer-full-conv-全卷积网络"><a href="#cls-layer-full-conv-全卷积网络" class="headerlink" title="cls layer(full conv 全卷积网络)"></a>cls layer(full conv 全卷积网络)</h4><p>输入：经过$3\times3$卷积的feature map</p><p>输出：经过softmax进行判断anchor是positive还是negative（2k）、</p><p>确定正样本的俩种方法：1. 与ground truth box有最大的IoU的anchor最为正样本 2. 与ground truth box的IoU大于0.7作为正样本。</p><p>负样本的确定是与ground truth box的IoU小于0.3</p><h4 id="reg-layer-full-conv-全卷积网络"><a href="#reg-layer-full-conv-全卷积网络" class="headerlink" title="reg layer(full conv 全卷积网络)"></a>reg layer(full conv 全卷积网络)</h4><p><strong>bounding box regression原理</strong></p><p>PS:下述的*表示的是x,y,w,h.</p><p>首先我们的目的是为了让预测的边框和真实的边框更加贴近，即Positive anchor和Ground Truth(GT)更加接近。因此对于$P_x,P_y$需要进行平移操作，$\Delta{x}=P_w<em>d_x(P),\Delta{y}=P_h</em>d_y(P)$：</p><script type="math/tex; mode=display">\begin{split}\hat{G_x} = P_w*d_x(P)+P_x\\\hat{G_y} = P_h*d_y(P)+P_y\\\end{split}\tag{1}</script><p>之后进行尺度的缩放，将其大小进行调整：</p><script type="math/tex; mode=display">\begin{split}\hat{G_w} = P_w*exp(d_w(P))\\\hat{G_h} = P_h*exp(d_h(P))\\\end{split}\tag{2}</script><p>其中$\hat{G_*}$表示的是预测边框的中心坐标以及宽高。</p><p>看上述的式子可以看出bounding box regression就是为了学习$d_*(P)$这四个变换，因此当positive anchor和Ground Truth很接近的时候，就可以将这个看成是一种线性变换。</p><p>之后使用线性回归来进行$d_<em>(P)$的学习，对于该线性回归，输入的是CNN feature map，记作$\phi$，同时设置$t_</em>$表示Positive anchor和GT之间的变换量，即标签值。</p><script type="math/tex; mode=display">\begin{split}Y = \hat{W_*}·\phi(P)\\\end{split}\tag{3}</script><p>其中$\phi(P)$表示的anchor的feature map组成的特征向量，标签表示的是Positive anchor和Ground Truth之间的变换$t_*$(如式子4定义）。</p><script type="math/tex; mode=display">\begin{split}\begin{cases}t_x = (G_x-P_x)/P_w\\{t_y} = (G_y-P_y)/P_h\\{t_w} = log(G_w/P_w)\\{t_h} = log(G_h/P_h)\\\end{cases}\end{split}\tag{4}</script><p>损失函数使用smooth L1损失函数(为了避免梯度爆炸)</p><script type="math/tex; mode=display">\begin{split}Smooth_{L1}(x)=\begin{cases}0.5x^2&, &if|x|<1\\|x|-0.5&, & otherwise\\\end{cases}\end{split}\tag{5}</script><p>其中$x=f(x_i)-y_i$。</p><hr><p>了解了bounding box regression之后，再看reg layer。</p><p>输入：经过$3\times3$卷积的feature map</p><p>输出：每个anchor的坐标位置信息（4k）</p><hr><p>RPN训练:</p><p>loss function：</p><script type="math/tex; mode=display">L(\{p_i\},\{t_i\}) = \frac{1}{N_{cls}}\sum_{i}L_{cls}(p_i,p_i^*)+\lambda\frac{1}{N_{reg}}\sum_{i}p_i^*L_{reg}(t_i,t_i^*)</script><p>前半部分是cls的损失函数，后半部分是reg的损失函数。其中i表示mini-batch中的第i个anchor。</p><p>cls的loss：$p_i$表示第i个anchor的前景的概率，$L_{cls}$表示的是交叉熵损失函数</p><p>reg的loss：$p_i^*$表示的是前景，因此reg只计算前景的损失，其中$L_{reg}$表示的Smooth L1损失函数。</p><h4 id="提供RoI-region-of-interests"><a href="#提供RoI-region-of-interests" class="headerlink" title="提供RoI(region of interests)"></a>提供RoI(region of interests)</h4><ol><li>对于每个图片，按照上述操作，生成prob和位置参数</li><li>选取概率较大的12000个anchor，利用回归的位置参数，修正，之后使用NMS来选取2000个RoIs</li></ol><h4 id="Proposal-layer"><a href="#Proposal-layer" class="headerlink" title="Proposal layer"></a>Proposal layer</h4><p><strong>目的</strong>：负责综合前面的cls，reg layer获取proposals</p><p>输入：分类的结果，回归的结果(变换的$d_*(P)$)和im_info</p><p><em>im_info</em>:[M,N,Scale_factor]保存了输入图片的尺寸和缩放信息</p><ol><li>生成anchors，利用reg layer的输出$d_*$对所有anchor进行bounding box regression</li><li>按照cls layer的输出，将anchors进行由大到小的排序，并且提取前N个anchors</li><li>限定超出图像边界的前景</li><li>提出非常小的前景</li><li>使用NMS算法进行anchor的筛选</li><li>之后按照NMS后的前景由大到小排序，提取前M个作为输出</li></ol><h3 id="RoI-pooling层"><a href="#RoI-pooling层" class="headerlink" title="RoI pooling层"></a>RoI pooling层</h3><p>因为提取到的proposals的尺寸并不是固定的，因此需要使用RoI Pooling解决这个问题。</p><ol><li><p>因为proposals的尺寸是对应于$M\times N$尺度的，所以使用spatial_scale映射到feature map上。</p></li><li><p>对于每个proposal所对应的feature map区域分为$pooled_w\times pooled_h$的网格。</p></li><li><p>对于网格的每一份进行max pooling处理</p></li></ol><p><img src="/2020/08/20/faster-R-CNN/RoI-Pooling.jpg" alt="avatar"></p><p>feature map尺寸是$8\times 8$,RoI的尺寸是$5\times 7$,$pooled_w = 2,pooled_h=2$,因此将RoI划分成$2\times 2$的size，其中第一个宽$\lfloor 5÷2 \rfloor = 2$，以此类推可以得出如上图。</p><h3 id="Classificatin"><a href="#Classificatin" class="headerlink" title="Classificatin"></a>Classificatin</h3><p>输入：proposal feature maps</p><p>输出：其中一个是通过全连接和softmax输出类别的概率，另外一个进行bounding box regression获得更高精度的检测框。</p><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>（图中第二行应为Fast R-CNN）</p><p><img src="/2020/08/20/faster-R-CNN/train.jpg" alt="avatar"></p><ol><li>首先将已经训练好的model的权重参数对RPN进行初始化，并训练，获取region proposals</li><li>训练Fast R-CNN网络，使用RPN提供的proposal（由imageNet训练好的Fast R-CNN模型的权重来提供）</li><li>固定shared conv layer的参数，训练RPN</li><li>固定shared conv layer的参数，训练Fast R-CNN</li></ol>]]></content>
      
      
      <categories>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object detection </tag>
            
            <tag> R-CNN系列 </tag>
            
            <tag> two-stage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++笔记</title>
      <link href="2020/03/12/C-%E7%AC%94%E8%AE%B0/"/>
      <url>2020/03/12/C-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>string与char</strong></p><p>string str1, char str2[50]</p><p><em>length</em>: str1.length() / strlen(str2) <strong>其他都是类似的：string的都是后缀型，char都是调用函数</strong></p><p>在char类型的数组中，\0是结尾符。</p><p><u><strong>对char类型数组定义</strong></u>：</p><ol><li>直接定义char name[30] = “cb”</li><li>间接定义char name[30]; strcpy(name,”cb”);或者name[30]={‘c’,’b’};</li></ol><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><hr><h4 id="STL库"><a href="#STL库" class="headerlink" title="STL库"></a>STL库</h4><p><strong>sort函数</strong>：sort（begin，end，排序）</p><p>注：不使用排序时，默认从小到大(看return的是大于号还是小于号)</p><p>要使用倒序</p><pre class=" language-lang-c++"><code class="language-lang-c++">bool cmp(int a, int b)&#123;    return a>b;&#125;</code></pre><p><em>vector</em>：</p><pre class=" language-lang-C++"><code class="language-lang-C++">vector<int> v;sort(v.begin(),v.end());</code></pre><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><pre class=" language-lang-C++"><code class="language-lang-C++">//相邻俩个交换，大的往后放void mpSort(int a[],int n)&#123;    for(int i = 0; i < n; i++)&#123;        for(int j = 0; j < n-i; j++)&#123;            if(a[j] > a[j+1])&#123;                temp = a[j];                a[j] = a[j+1];                a[j+1] = temp;            &#125;        &#125;    &#125;&#125;</code></pre><hr><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><pre class=" language-lang-C++"><code class="language-lang-C++">//将最小的选出来，放在前面void selectSort(int A[], int n)&#123;    for(int i = 0; i < n; i++)&#123;        int k = i;        for(int j = i+1; j < n; j++)&#123;            if(A[j] < A[k])&#123;                k = j;            &#125;        &#125;        temp = A[k];        A[k] = A[i];        A[i] = temp;    &#125;&#125;</code></pre><hr><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><pre class=" language-lang-C++"><code class="language-lang-C++">//将后一位数插入前面void insertSort(int A[], int n)&#123;    for(int i = 1; i < n; i++)&#123;        int temp = A[i],j = i;        while(j > 1 && temp < A[j-1])&#123;            A[j] = A[j-1];            j--;        &#125;        A[j] = temp;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>真华为机试题目</title>
      <link href="2020/03/11/%E7%9C%9F%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
      <url>2020/03/11/%E7%9C%9F%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述回忆版"><a href="#题目描述回忆版" class="headerlink" title="题目描述回忆版"></a>题目描述回忆版</h2><h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><p>在linux系统中${xxx}代表一个变量xxx所对应的值。</p><p>第一行输入的是行数，之后总共要输入多少行数据，之后输入数据。</p><p>例如：</p><p>4<br>xxx=/lyf/${ttt}/test<br>ttt=www<br>yyy=seeyou<br>aa=/aa/${xxx}/bbb/${yyy}/ccc</p><hr><pre class=" language-lang-python"><code class="language-lang-python">import sysimport mathfor line in sys.stdin:    line = line.strip().split(' ')    line = list(map(int,line))    zb = []    for i in range(len(line)):        if i%2 == 0:            zb.append([line[i],line[i+1]])    start = [0,0]    dis = 0    while zb != []:        find_min_dis = []        for i in range(len(zb)):            d = math.sqrt((zb[i][0]-start[0])**2+(zb[i][1]-start[1])**2)            find_min_dis.append(d)        min_dis = min(find_min_dis)        pop_index = find_min_dis.index(min_dis)        dis += min_dis        start[0] = zb[pop_index][0]        start[1] = zb[pop_index][1]        zb.pop(pop_index)    last_dis = math.sqrt((start[0]*start[0])+(start[1]*start[1]))    dis += last_dis    print(math.floor(dis))</code></pre><p>通过率百分之75，错误的地方我还没想到。</p><hr><h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><p>有一只小蜜蜂从蜂巢去五片花田采蜜，采完回家，假设以蜂巢为坐标原点(0,0)，花田位置为A(50,0)、B(50,5)、C(50,20)、D(50,30)、E(50,50)，规划小蜜蜂采蜜路线，求解蜜蜂飞行最短距离（输出为整数）</p><p>输入</p><p>50 0 50 5 50 20 50 30 50 50</p><pre class=" language-lang-python"><code class="language-lang-python">import sysimport mathfor line in sys.stdin:    line = line.strip().split(' ')    line = list(map(int,line))    zb = []    for i in range(len(line)):        if i%2 == 0:            zb.append([line[i],line[i+1]])    start = [0,0]    dis = 0    while zb != []:        find_min_dis = []        for i in range(len(zb)):            d = math.sqrt((zb[i][0]-start[0])**2+(zb[i][1]-start[1])**2)            find_min_dis.append(d)        min_dis = min(find_min_dis)        pop_index = find_min_dis.index(min_dis)        dis += min_dis        start[0] = zb[pop_index][0]        start[1] = zb[pop_index][1]        zb.pop(pop_index)    last_dis = math.sqrt((start[0]*start[0])+(start[1]*start[1]))    dis += last_dis    print(math.floor(dis))</code></pre><p>通过率55.56%</p><p>应该使用Dijkstra算法去求取才对。</p><hr><h3 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h3><p>C语言中include都是前序深度遍历。</p><p>输入a b表示a include b，不存在a b;b c;d e因为d不是a include的。</p><p>输入</p><p>a b;a c;b e;e c;e b;c d;d a</p><p>输出的是一条通路和回环</p><p>通路:a b e c d</p><p>回环: b e b;a c d a</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为笔试day04</title>
      <link href="2020/03/10/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95day04/"/>
      <url>2020/03/10/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95day04/</url>
      
        <content type="html"><![CDATA[<h1 id="牛客——华为机试题"><a href="#牛客——华为机试题" class="headerlink" title="牛客——华为机试题"></a>牛客——华为机试题</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>密码是我们生活中非常重要的东东，我们的那么一点不能说的秘密就全靠它了。哇哈哈. 接下来渊子要在密码之上再加一套密码，虽然简单但也安全。</p><p>假设渊子原来一个BBS上的密码为zvbo9441987,为了方便记忆，他通过一种算法把这个密码变换成YUANzhi1987，这个密码是他的名字和出生年份，怎么忘都忘不了，而且可以明目张胆地放在显眼的地方而不被别人知道真正的密码。</p><p>他是这么变换的，大家都知道手机上的字母： 1—1， abc—2, def—3, ghi—4, jkl—5, mno—6, pqrs—7, tuv—8 wxyz—9, 0—0,就这么简单，渊子把密码中出现的小写字母都变成对应的数字，数字和其他的符号都不做变换，</p><p>声明：密码中没有空格，而密码中出现的大写字母则变成小写之后往后移一位，如：X，先变成小写，再往后移一位，不就是y了嘛，简单吧。记住，z往后移是a哦。</p><hr><h3 id="解法与思路"><a href="#解法与思路" class="headerlink" title="解法与思路"></a>解法与思路</h3><pre class=" language-lang-python"><code class="language-lang-python">import sysimport reupper_digit = &#123;2:'abc',3:'def',4:'ghi',5:'jkl',6:'mno',7:'pqrs',8:'tuv',9:'wxyz'&#125;try:    while True:        line = sys.stdin.readline().strip()        if line == '':            break        line = list(map(str,str(line)))        for i in range(len(line)):            if re.search('[0-9]',line[i]):                line[i] = line[i]                continue            if re.search('[A-Z]',line[i]):                ASCII_a = ord('a')                num = ASCII_a+(ord(line[i].lower())-ASCII_a+1)%26                line[i] = chr(num)                continue            if re.search('[a-z]',line[i]):                for key,value in upper_digit.items():                    if value.find(line[i]) != -1:                        line[i] = str(key)                        break        output = ''.join(line)        print(output)except:    pass</code></pre><p>转化成列表，然后再去处理每个单词</p><hr><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？</p><hr><p><strong>解法与思路</strong></p><p>喝掉的 = 空瓶//3，那么空瓶数 = 喝掉的+剩下的。</p><p>注:剩下俩个空瓶时候，可以去借一个，然后就可以再喝一瓶</p><pre class=" language-lang-python"><code class="language-lang-python">import sysdef water(x):    drink = 0    while(x >= 3):        divd = x//3        yushu = x%3        x = divd + yushu        drink += divd    if x == 2:        drink += 1    return drinktry:    while True:        line = sys.stdin.readline().strip()        if line == '':            break        w = water(eval(line))        print(w)except:    pass</code></pre><hr><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现删除字符串中出现次数最少的字符，若多个字符出现次数一样，则都删除。输出删除这些单词后的字符串，字符串中其它字符保持原来的顺序。</p><p>注意每个输入文件有多组输入，即多个字符串用回车隔开</p><pre class=" language-lang-python"><code class="language-lang-python">import systry:    while True:        dict = &#123;&#125;#存放字符        line = sys.stdin.readline().strip()        if line == '':            break        line = list(map(str,str(line)))        error_str = []        for i in line:            if 'a'<=i<='z':                if dict.__contains__(i):                    dict[i] += 1                else:                    dict[i] = 1            else:                error_str.append(i)        for i in error_str:            line.remove(i)        print(line)        value = dict.values()        mini_value = list(set(sorted(value)))[0]        delete_key = []        for key,value in dict.items():            if value == mini_value:                delete_key.append(key)        for i in delete_key:            line.remove(i)        print(''.join(line))except:    pass</code></pre><p>根据题目理解，我觉得不是小写字母应该删除。</p><p>删除的方法，就是将要删除的字符放入list，然后使用遍历的方式进行删除。</p><hr><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个程序，将输入字符串中的字符按如下规则排序。</p><p>规则 1 ：英文字母从 A 到 Z 排列，不区分大小写。</p><p>如，输入： Type 输出： epTy</p><p>规则 2 ：同一个英文字母的大小写同时存在时，按照输入顺序排列。</p><p>如，输入： BabA 输出： aABb</p><p>规则 3 ：非英文字母的其它字符保持原来的位置。</p><p>如，输入： By?e 输出： Be?y</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-lang-python"><code class="language-lang-python">import sysimport retry:    while True:        line = sys.stdin.readline().strip()        if line == '':            break        error_str = [0 for i in range(len(line))]        char = []        #规则三：如果是不规则字符，那么不变        for i in range(len(line)):            if re.search(r'[^a-zA-Z]',line[i]):                error_str[i] = line[i]            else:                char.append(line[i])        char.sort(key=lambda x:x.lower())#所有字符排序        for i in range(len(line)):            if error_str[i] == 0:                error_str[i] = char[0]                char.remove(char[0])        print(''.join(error_str))except:    pass</code></pre><p>设置一个同样长度的0列表，然后将排序的数据放入其中</p><p>sort(key=)这个是排序的规则，用什么方法排序</p>]]></content>
      
      
      
        <tags>
            
            <tag> 华为笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式re</title>
      <link href="2020/03/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre/"/>
      <url>2020/03/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><strong>正则表达式</strong></p><p>[]表示一个字符类，比如[abc]那么就是匹配‘a’,’b’,’c’这三个字符</p><p><sup><a href="#fn_" id="reffn_"></a></sup>表示不取这些数字^a 表示除了a这个字符都可以</p><p> $表示匹配行的末尾</p><p>\A表示匹配字符串的开头，与^是一个意思。但是使用\A必须搭配r’ ‘</p><p>\b表示字边界，可以使用p = re.compile(r’\bclass\b’)来表示class这个单词</p><p><strong>Python的re包</strong></p><p>re.search(pattern,string,flag=0)</p><p>pattern：正则中的模式字符串，string：被查找替换的原始字符串</p><p>flags：标志位，用于控制正则表达式的匹配方式。可以检测string的任何位置</p><pre class=" language-lang-python"><code class="language-lang-python">re.search('[0-9]','sdfs9300')#就会找到其中的字符</code></pre><p>re.match(pattern,string,flag=0)</p><p>只能从字符串的开头找起</p><pre class=" language-lang-python"><code class="language-lang-python">re.match('com','complier sfsf sf')#就会返回None</code></pre><hr><h3 id="机试题目"><a href="#机试题目" class="headerlink" title="机试题目"></a>机试题目</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>密码要求:</p><p>1.长度超过8位</p><p>2.包括大小写字母.数字.其它符号,以上四种至少三种</p><p>3.不能有相同长度超2的子串重复</p><p>说明:长度超过2的子串</p><hr><p><strong>代码</strong></p><pre class=" language-lang-python"><code class="language-lang-python">import sysimport retry:    while True:        line = sys.stdin.readline().strip()        if line == '':            break        if len(line)<=8:            print('NG')            contine        count = 0        if re.search('[0-9]',line):            count += 1#如果有数字就加1        if re.search('[a-z]',line):            count += 1        if re.search('[A-Z]',line):            count += 1        if re.search('[^0-9a-zA-Z]',line):            count += 1        if count < 3:            print("NG")            contine        if re.search(r'.*(...).*\1',line):            print("NG")            continue        print("OK")</code></pre><p>r’.*(…).*\1’表示前面有任意数，(…)表示三个任意数,\1表示重复上面引用分组。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 华为笔试 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为笔试day03</title>
      <link href="2020/03/06/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95day03/"/>
      <url>2020/03/06/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95day03/</url>
      
        <content type="html"><![CDATA[<h1 id="牛客——华为机试题"><a href="#牛客——华为机试题" class="headerlink" title="牛客——华为机试题"></a>牛客——华为机试题</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。从（0,0）点开始移动，从输入字符串里面读取一些坐标，并将最终输入结果输出到输出文件里面。</p><p>输入：</p><p>合法坐标为A(或者D或者W或者S) + 数字（两位以内）</p><p>坐标之间以;分隔。</p><p>非法坐标点需要进行丢弃。如AA10; A1A; $%$; YAD; 等。</p><p>下面是一个简单的例子 如：</p><p>A10;S20;W10;D30;X;A1A;B10A11;;A10;</p><p>处理过程：</p><p>起点（0,0）</p><p>+  A10  = （-10,0）</p><p>+  S20  = (-10,-20)</p><p>+  W10 = (-10,-10)</p><p>+  D30 = (20,-10)</p><p>+  x  = 无效</p><p>+  A1A  = 无效</p><p>+  B10A11  = 无效</p><p>+ 一个空 不影响</p><p>+  A10 = (10,-10)</p><p>结果 （10， -10）</p><p><strong>注意请处理多组输入输出</strong></p><hr><h3 id="解法与思路"><a href="#解法与思路" class="headerlink" title="解法与思路"></a>解法与思路</h3><p>首先以；分隔输入的字符串，然后去掉空字符串。</p><p>构造一个字典，存放各个方向的单位向量</p><p>构造一个list，存放数字的字符形式</p><p>之后就是对输入的字符每个进行判断，并移动</p><pre class=" language-lang-python"><code class="language-lang-python">import sys#输入的按照;分隔，放入list中for line in sys.stdin:    string  = line.split(";")    #去除空字符    string = list(filter(None, string))    num = [i for i in range(10)]    num = list(map(str,num))    direct = &#123;'A':[-1,0],'D':[1,0],'W':[0,1],'S':[0,-1]&#125;    place = [0,0]    #判断这个坐标是否有效,有效就移动    for ch in string:        if ch[0] in direct:            if len(ch) == 3 and ch[1] in num and ch[2] in num:                dir = direct[ch[0]]                move = list(map(lambda x,y:x*y,dir,[int(ch[1:])]*2))                place = list(map(lambda x,y:x+y,place,move))            elif len(ch) == 2 and ch[1] in num:                dir = direct[ch[0]]                move = list(map(lambda x,y:x*y,dir,[int(ch[1:])]*2))                place = list(map(lambda x, y: x + y, place, move))    print(str(place[0])+','+str(place[1]))</code></pre><p><strong>注意</strong> 多行输入输出:使用sys.stdin</p><hr><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>请解析IP地址和对应的掩码，进行分类识别。要求按照A/B/C/D/E类地址归类，不合法的地址和掩码单独归类。</p><p>所有的IP地址划分为 A,B,C,D,E五类</p><p>A类地址1.0.0.0~126.255.255.255;</p><p>B类地址128.0.0.0~191.255.255.255;</p><p>C类地址192.0.0.0~223.255.255.255;</p><p>D类地址224.0.0.0~239.255.255.255；</p><p>E类地址240.0.0.0~255.255.255.255</p><p>私网IP范围是：</p><p>10.0.0.0～10.255.255.255</p><p>172.16.0.0～172.31.255.255</p><p>192.168.0.0～192.168.255.255</p><p>子网掩码为二进制下前面是连续的1，然后全是0。（例如：255.255.255.32就是一个非法的掩码）</p><p>注意二进制下全是1或者全是0均为非法</p><p>注意：</p><p>\1. 类似于【0.<em>.</em>.*】的IP地址不属于上述输入的任意一类，也不属于不合法ip地址，计数时可以忽略</p><p>\2. 私有IP地址和A,B,C,D,E类地址是不冲突的</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code>多行字符串。每行一个IP地址和掩码，用~隔开。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code>统计A、B、C、D、E、错误IP地址或错误掩码、私有IP的个数，之间以空格隔开。</code></pre><hr><h3 id="解法与思路-1"><a href="#解法与思路-1" class="headerlink" title="解法与思路"></a>解法与思路</h3><p>设置俩个函数用于检测IP与子网掩码</p><p>然后就直接判断IP属于哪一类</p><pre class=" language-lang-python"><code class="language-lang-python">import sysA = 0B = 0C = 0D = 0E = 0privateIP = 0noneIP = 0lastcode=[ 254 , 252 , 248 , 240 , 224 , 192 , 128 , 0 ]def CheckIp(ip):    if len(ip) !=4:        return False    else:        for i in range(4):            if (ip[i] < 0) or (ip[i] > 255):                return False    return Truedef CheckMask(mask):    if len(mask) != 4:        return False    else:        if mask[0]== 255 :            if mask[1]== 255 :                if mask[2]== 255 :                    if mask[3] in lastcode:                        return True                    else:                        return False                elif mask[2] in lastcode and mask[3]== 0 :                     return True                else:                     return False            elif mask[1] in lastcode and mask[2]==mask[3]== 0 :                return True            else:                return False        elif mask[0] in lastcode and mask[1]==mask[2]==mask[3]== 0 :            return True        else:            return Falsewhile True:    line = sys.stdin.readline().strip()    if line == '':        break    ip_mask = line.split('~')    ip = list(filter(None,ip_mask[0].split('.')))#去除空的字符    ip = list(map(int,ip))    mask = list(filter(None, ip_mask[1].split('.')))  # 去除空的字符    mask = list(map(int, mask))    if CheckIp(ip) == False or CheckMask(mask) == False:        noneIP += 1    else:        if ip[0] == 0:            continue        if ip[0] > 0 and ip[0] <= 126:            A += 1        if ip[0] > 127 and ip[0] <= 191:            B += 1        if ip[0] > 191 and ip[0] <= 223:            C += 1        if ip[0] > 223 and ip[0] <= 239:            D += 1        if ip[0] > 239 and ip[0] <= 255:            E += 1        if (ip[0]==10) or (ip[0]==172 and ip[1]>=16 and ip[1]<=31) or (ip[0]==192 and ip[1]==168):            privateIP +=1print('&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;'.format(A,B,C,D,E,noneIP,privateIP))</code></pre><hr><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。</p><p>处理：</p><p>1、 记录最多8条错误记录，循环记录（或者说最后只输出最后出现的八条错误记录），对相同的错误记录（净文件名称和行号完全匹配）只记录一条，<strong>错误计数增加；</strong></p><p>2、 超过16个字符的文件名称，只记录文件的最后有效16个字符；</p><p>3、 输入的文件可能带路径，记录文件名称不能带路径。</p><hr><h2 id="思路与想法"><a href="#思路与想法" class="headerlink" title="思路与想法"></a>思路与想法</h2><p><strong>题目分析</strong></p><ol><li>不重复记录错误，意思如果错误相同那么加一</li><li>如果文件名超过16那么取最后16个</li><li>最后是输出最后八个数据</li></ol><p>比较麻烦的是上面那个不重复记录错误。</p><p>我的思路是：设置一个list，存放输入的数据，文件名，行数，和错误数据</p><p>那么加一就很好办了，用输入的重复数据与list中的存放数据比较，然后错误数据加一。</p><pre class=" language-lang-python"><code class="language-lang-python">import syslines = []errors = []try:    while True:        line = sys.stdin.readline().strip()        if line == '':            break        if line not in lines:            error = 1            lines.append(line)            line = line.split(' ')            line = list(filter(None,line))            file = line[0].split('\\')            if len(file[-1]) > 16:                file[-1] = file[-1][-16:]            errorfile = file[-1]            a = [line,errorfile,line[1],error]            errors.append(a)        else:            for i in range(len(errors)):                num = ' '.join(errors[i][0])                if line == num:                    errors[i][3] += 1except:    passif len(errors)>8:    for i in range(8):        print("&#123;&#125; &#123;&#125; &#123;&#125;".format(errors[-8+i][1],errors[-8+i][2],errors[-8+i][3]))else:    for i in range(len(errors)):        print("&#123;&#125; &#123;&#125; &#123;&#125;".format(errors[i][1],errors[i][2],errors[i][3]))</code></pre><p>与牛客网的数据匹配度是30%，他的答案应该有问题，我发现他的数据重复是按照最后文件名来操作的，不带上前面的路径，我觉得应该需要带上路径。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 华为笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="2020/03/05/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>2020/03/05/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="简易的背包算法"><a href="#简易的背包算法" class="headerlink" title="简易的背包算法"></a>简易的背包算法</h3><p>有5间商品，容量为20的背包，问最多能够带走最大价值为多少的货物。</p><div class="table-container"><table><thead><tr><th style="text-align:center">重量</th><th style="text-align:center">价值</th></tr></thead><tbody><tr><td style="text-align:center">2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">10</td></tr></tbody></table></div><hr><p><strong>思路与算法</strong></p><p>算法：就是下面这个</p><p><img src="/2020/03/05/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/Blog\knapsack1.jpg" alt="image-20200305185212960"></p><pre class=" language-lang-C++"><code class="language-lang-C++">#include <iostream>using namespace std;const int N = 6;const int K = 21;int B[N][K];int Weight[] = &#123;0,2,3,4,6,9&#125;;int Value[] = &#123;0,3,4,5,7,10&#125;;void knapsack()&#123;    int i,j;    for(i = 1; i < N; i++)&#123;        for(j = 1; j < K; j++)&#123;            if(Weight[i] > j)&#123;                B[i][j] = B[i-1][j];            &#125;            else&#123;                int value1 = B[i-1][j];                int value2 = B[i-1][j-Weight[i]]+Value[i];                if(value1 > value2)                    B[i][j] = value1;                else                    B[i][j] = value2;            &#125;        &#125;    &#125;&#125;int main()&#123;    knapsack();    cout<<B[5][20]<<endl;&#125;</code></pre><hr><h2 id="华为机试题"><a href="#华为机试题" class="headerlink" title="华为机试题"></a>华为机试题</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>王强今天很开心，公司发给N元的年终奖。王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p><div class="table-container"><table><thead><tr><th>主件</th><th>附件</th></tr></thead><tbody><tr><td>电脑</td><td>打印机，扫描仪</td></tr><tr><td>书柜</td><td>图书</td></tr><tr><td>书桌</td><td>台灯，文具</td></tr><tr><td>工作椅</td><td>无</td></tr></tbody></table></div><p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。王强想买的东西很多，为了不超出预算，他把每件物品规定了一个重要度，分为 5 等：用整数 1 <strong>~</strong> 5 表示，第 5 等最重要。他还从因特网上查到了每件物品的价格（都是 10 元的整数倍）。他希望在不超过 N 元（可以等于 N 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。</p><p>  设第 j 件物品的价格为 v[j] ，重要度为 w[j] ，共选中了 k 件物品，编号依次为 j 1 ， j 2 ，……， j k ，则所求的总和为：</p><p>v[j 1 ]<em>w[j 1 ]+v[j 2 ]</em>w[j 2 ]+ … +v[j k ]<em>w[j k ] 。（其中 </em> 为乘号）</p><p>  请你帮助王强设计一个满足要求的购物单。</p><h3 id="算法与思路"><a href="#算法与思路" class="headerlink" title="算法与思路"></a>算法与思路</h3><p>将附件属性独立放入一个list，然后判断list值是否等于0，来进行讨论，如果不是0，那么就要附件加上主件一起来进行判断，最后用背包问题的一般解法就好。</p><pre class=" language-lang-python"><code class="language-lang-python">import numpy as npprice, num = map(int,input().split())D = np.zeros([num+1,price+1])P = [0]dpi = [0]M = [0]Value = [0]for i in range(num):    a,b,c = map(int,input().split())    P.append(a)    dpi.append(b)    M.append(c)    Value.append(a*b)def knapsack():    for i in range(1,num+1):        for j in range(1,price+1):            if(M[i] == 0):#这是主件                if(P[i]>j):                    D[i][j] = D[i-1][j]                else:                    D[i][j] = max(D[i-1][j], D[i-1][j-P[i]]+Value[i])            else:                if(P[M[i]] + P[i] > j):                    D[i][j] = D[i-1][j]                else:                    D[i][j] = max(D[i-1][j], D[i-1][j-P[M[i]]-P[i]]+Value[M[i]]+Value[i])knapsack()print(D[num][price])</code></pre><p>PS:这个代码过不了牛客网所有的例子，说明思路还是有点问题。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华为笔试 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题笔记-python</title>
      <link href="2020/03/05/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-python/"/>
      <url>2020/03/05/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-python/</url>
      
        <content type="html"><![CDATA[<p><strong>Python</strong></p><ol><li><p>将一个int类型的数据逐个放入list中</p><pre class=" language-lang-python"><code class="language-lang-python">list(map(str,str(num)))</code></pre></li><li><p>将list逐个输出转化成字符串</p><pre class=" language-lang-python"><code class="language-lang-python">''.join(list)</code></pre></li><li><p>转化二进制，八进制，十六进制</p><pre class=" language-lang-python"><code class="language-lang-python">bin(dec)/oct(dec)/hex(dec)</code></pre></li><li><p>多行输入输出—牛客网</p><pre class=" language-lang-python"><code class="language-lang-python">import sysfor line in sys.stdin:</code></pre></li><li><p>在list中去除空字符或者none</p><pre class=" language-lang-python"><code class="language-lang-python">string = list(filter(None, string))</code></pre></li></ol><ol><li><p>切片</p><pre class=" language-lang-python"><code class="language-lang-python">list[:-1]//读取到最后一位数</code></pre></li></ol><ol><li><p>转化成ACSII码</p><pre class=" language-lang-python"><code class="language-lang-python">ord(c)#转化成ASCII码chr(c)#转化成字符</code></pre></li><li><p>find函数</p><pre class=" language-lang-python"><code class="language-lang-python">a.find(str,beg,end)#找到返回下标，如果没有找到返回-1</code></pre></li><li><p>大小写转化</p><pre class=" language-lang-python"><code class="language-lang-python">str.lower()#转化成小写str.upper()#转化成大写</code></pre></li><li></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 华为笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为笔试day02</title>
      <link href="2020/03/05/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95day02/"/>
      <url>2020/03/05/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95day02/</url>
      
        <content type="html"><![CDATA[<h1 id="牛客——华为机试题"><a href="#牛客——华为机试题" class="headerlink" title="牛客——华为机试题"></a>牛客——华为机试题</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个函数，计算字符串中含有的不同字符的个数。字符在ACSII码范围内(0~127)，换行表示结束符，不算在字符里。不在范围内的不作统计。</p><h3 id="思路与解法"><a href="#思路与解法" class="headerlink" title="思路与解法"></a>思路与解法</h3><p><strong>思路</strong></p><p>首先将重复的数据剔除，然后判断剩余的字符是否在ASCII范围内。</p><pre class=" language-lang-python"><code class="language-lang-python">num = input()ch = ""count = 0for i in range(len(num)):    if num[i] not in ch:        ch += num[i]for i in range(len(ch)):    if(ord(ch[i])>0 and ord(ch[i])<127):        count +=1print(count)</code></pre><p>或者使用set这样更加简洁</p><pre class=" language-lang-python"><code class="language-lang-python">print(len(set([i for i in input() if ord(i) in range(128)])))</code></pre><hr><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数，将这个整数以字符串的形式逆序输出</p><p>程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001</p><h3 id="思路与解法-1"><a href="#思路与解法-1" class="headerlink" title="思路与解法"></a>思路与解法</h3><p><strong>思路</strong></p><p>将输入的整数逐个放入list中，然后list转置，之后逐个输出。</p><pre class=" language-lang-python"><code class="language-lang-python">num = eval(input())a = list(map(str,str(num)))a.reverse()print(int(''.join(a)))</code></pre><hr><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000）</p><h3 id="思路与解法-2"><a href="#思路与解法-2" class="headerlink" title="思路与解法"></a>思路与解法</h3><p><strong>思路</strong></p><p>将字符串放入list，之后转置，并逐个输出list</p><pre class=" language-lang-python"><code class="language-lang-python">string = input()a = list(map(str,string))a.reverse()print(''.join(a))</code></pre><hr><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I”<br>所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符</p><p>接口说明</p><p>/<em>*<br> \</em> 反转句子<br> *<br> * @param sentence 原句子<br> * @return 反转后的句子<br> */<br>public String reverse(String sentence);</p><h3 id="思路与解法-3"><a href="#思路与解法-3" class="headerlink" title="思路与解法"></a>思路与解法</h3><p><strong>思路</strong></p><p>以空格分隔，放入list中，然后转置。</p><pre class=" language-lang-python"><code class="language-lang-python">string = input()a = string.split()a.reverse()print(' '.join(a))</code></pre><hr><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定n个字符串，请对n个字符串按照字典序排列。</p><h3 id="思路与解法-4"><a href="#思路与解法-4" class="headerlink" title="思路与解法"></a>思路与解法</h3><p><strong>思路</strong></p><p>将字符串放入list中，然后进行排序，之后逐个输出</p><pre class=" language-lang-python"><code class="language-lang-python">num = eval(input())a = []for i in range(num):    b = input()    a.append(b)a = sorted(a)for i in range(len(a)):    print(a[i])</code></pre><hr><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定n个字符串，请对n个字符串按照字典序排列。</p><h3 id="思路与解法-5"><a href="#思路与解法-5" class="headerlink" title="思路与解法"></a>思路与解法</h3><p><strong>思路</strong></p><ol><li><p>使用python的库，将10进制的数转化成2进制，之后使用count函数统计1的个数</p><pre class=" language-lang-python"><code class="language-lang-python">num = eval(input())num = bin(num)print(num.count("1"))</code></pre></li><li><p>10进制的数除以2，余数为1，那么就有存在1，然后逐一进行</p><pre class=" language-lang-python"><code class="language-lang-python">def change(x):    count = 0    while x>0:        if x%2 == 1:            count +=1        x = x//2    return count</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 华为笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为笔试5</title>
      <link href="2020/03/04/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%955/"/>
      <url>2020/03/04/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%955/</url>
      
        <content type="html"><![CDATA[<h1 id="牛客——华为机试题"><a href="#牛客——华为机试题" class="headerlink" title="牛客——华为机试题"></a>牛客——华为机试题</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。</p><span id="more"></span><h3 id="解法与思路"><a href="#解法与思路" class="headerlink" title="解法与思路"></a>解法与思路</h3><p><strong>思路</strong></p><p>首先将int类型的数据逐个放入list中，然后倒转，并去重，然后在重新输出</p><pre class=" language-lang-python"><code class="language-lang-python">num = eval(input())a = list(map(str,str(num)))a.reverse()b = []for i in range(len(a)):    if a[i] not in b:        b.append(a[i])num =int( ''.join(b))print(num)</code></pre><p>‘’.join(b):将list的数据输出成str</p>]]></content>
      
      
      
        <tags>
            
            <tag> 华为笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为笔试4</title>
      <link href="2020/03/04/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%954/"/>
      <url>2020/03/04/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%954/</url>
      
        <content type="html"><![CDATA[<h1 id="牛客——华为机试题"><a href="#牛客——华为机试题" class="headerlink" title="牛客——华为机试题"></a>牛客——华为机试题</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>数据表记录包含表索引和数值（int范围的整数），请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照key值升序进行输出。</p><span id="more"></span><h3 id="解法与思路"><a href="#解法与思路" class="headerlink" title="解法与思路"></a>解法与思路</h3><p>首先读取每行数据，用空格分开，然后判断这个key是否存在字典中，若存在则相加，否则直接放入。然后取出key进行排序，之后对key逐一输出。</p><pre class=" language-lang-python"><code class="language-lang-python">num = eval(input())dict = &#123;&#125;for i in range(num):    m, n = map(int,input().split())    if dict.has_keys(m):        dict[m] += n    else:        dict[m] = nkeys = sorted(dict.keys())for key in keys:    print(key,dict[key])</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 华为笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为笔试3</title>
      <link href="2020/03/04/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%953/"/>
      <url>2020/03/04/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%953/</url>
      
        <content type="html"><![CDATA[<h1 id="牛客——华为机试题"><a href="#牛客——华为机试题" class="headerlink" title="牛客——华为机试题"></a>牛客——华为机试题</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于5,向上取整；小于5，则向下取整。</p><span id="more"></span><h4 id="解法与思路"><a href="#解法与思路" class="headerlink" title="解法与思路"></a>解法与思路</h4><p>判断后面小数是否大于0.5如果大于0.5那么进位，否则不进位</p><pre class=" language-lang-python"><code class="language-lang-python">import mathnum = eval(input())small = num - math.floor(num)jinwei = 0if(small >= 0.5):    jinwei = 1else:    jinwei = 0num = math.floor(num)+jinweiprint(num)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 华为笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为笔试2</title>
      <link href="2020/03/04/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%952/"/>
      <url>2020/03/04/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%952/</url>
      
        <content type="html"><![CDATA[<h1 id="牛客——华为机试题"><a href="#牛客——华为机试题" class="headerlink" title="牛客——华为机试题"></a>牛客——华为机试题</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组；<br>长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。</p><span id="more"></span><h3 id="解法与思路"><a href="#解法与思路" class="headerlink" title="解法与思路"></a>解法与思路</h3><p><strong>python</strong></p><pre class=" language-lang-python"><code class="language-lang-python">import sysdef cut(obj,length):    if len(obj) > length:        return [obj[i:i+length] for i in range(0,len(obj),length)]    else:        return [obj]def fill0(obj):    if(len(obj) < 8):        obj = obj.ljust(8,"0")    return objtry:    while True:        line = []        line1 = sys.stdin.readline().strip()        line.append(line1)        if line == '':            break        line2 = sys.stdin.readline().strip()        line.append(line2)        lineStr = []        for i in range(0,len(line)):            lineStr.extend(cut(line[i],8))        for i in range(0,len(lineStr)):            lineStr[i] = fill0(lineStr[i])            print(lineStr[i])except:    pass</code></pre><p>这个先设置俩个函数，分别达到切割与加0操作，但是fail，因为跑的时间太长了，不满足。</p><p>看了网上大神的py精简</p><pre class=" language-lang-python"><code class="language-lang-python">import systry:    while True:        line = []        line1 = sys.stdin.readline().strip()        if line1 != '':            line.append(line1)#处理空字符串        line2 = sys.stdin.readline().strip()        if line2 != '':            line.append(line2)#处理空字符串        for i in range(0,len(line)):            s = line[i]            if len(s) > 8:                print(s[:8])                s = s[8:]            print(s.ljust(8,"0"))except:    pass</code></pre><p>这俩种思路都是先进行判断是否需要切片，然后补0，但是都由于运行时间过长，而导致不能通过</p><pre><code>str1 = raw_input()str2 = raw_input()def myTrim(str):    tmp = len(str) % 8    if tmp != 0:        str += &quot;0&quot;* (8- tmp)    for i in range(len(str) / 8):        print(str[i * 8: i * 8+ 8])myTrim(str1)myTrim(str2)</code></pre><p>这一种方法是先补0在进行切割，方法更加简单</p>]]></content>
      
      
      
        <tags>
            
            <tag> 华为笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为笔试1</title>
      <link href="2020/03/04/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%951/"/>
      <url>2020/03/04/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%951/</url>
      
        <content type="html"><![CDATA[<h1 id="牛客——华为机试题"><a href="#牛客——华为机试题" class="headerlink" title="牛客——华为机试题"></a>牛客——华为机试题</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。（多组同时输入 ）</p><span id="more"></span><h3 id="解法与思路"><a href="#解法与思路" class="headerlink" title="解法与思路"></a>解法与思路</h3><p><strong>python</strong></p><pre class=" language-lang-python"><code class="language-lang-python">import sysfor line in sys.stdin:    a = line.split()    output = list(map(lambda x:eval(x),a))    for i in range(0,len(output)):        print(output[i])</code></pre><p><strong>eval()</strong>:将执行一个字符串表达式，并返回相应的值。如0x就会返回16进制</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 华为笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为笔试</title>
      <link href="2020/03/03/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95/"/>
      <url>2020/03/03/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="牛客——华为机试题"><a href="#牛客——华为机试题" class="headerlink" title="牛客——华为机试题"></a>牛客——华为机试题</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子（如180的质因子为2 2 3 3 5 ）</p><p>最后一个数后面也要有空格</p><span id="more"></span><p>详细描述：</p><p>函数接口说明：</p><p>public String getResult(long ulDataInput)</p><p>输入参数：</p><p>long ulDataInput：输入的正整数</p><p>返回值：</p><p>String</p><hr><h3 id="解法与思路"><a href="#解法与思路" class="headerlink" title="解法与思路"></a>解法与思路</h3><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>对于一个数只要遍历根号X就可以找出他所有的因数，并且对于质数只要反复遍历，那么下一次遍历的也将会是质数(因为不是质数的话，就会遍历之前小的质数)</p><p><strong>Python</strong></p><pre class=" language-lang-python"><code class="language-lang-python">import matha = int(input())res = []for i in range(2,math.floor(math.sqrt(a))):    while a%i == 0:        a /= i        res.append(i)print(" ".join(map(str, res)) + " " if res else str(a) + " ")</code></pre><p><strong>C++</strong></p><pre class=" language-lang-C++"><code class="language-lang-C++">#include<iostream>#include<cmath>using namespace std;int main()&#123;    int num;    cin>>num;    for(int i = 2;i <= num; i++)&#123;        while(num%i == 0)&#123;            num /= i;            cout<<i<<" ";        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 华为笔试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
